From b5e12e69ec2204b9eada690a31a70cc9be20b3eb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=C3=86var=20Arnfj=C3=B6r=C3=B0=20Bjarmason?=
 <avarab@gmail.com>
Date: Wed, 19 Sep 2018 13:30:59 +0000
Subject: [PATCH 1/3] trace

---
 builtin/reflog.c     | 27 ++++++++++++++++++++++-----
 refs/files-backend.c |  5 +++++
 2 files changed, 27 insertions(+), 5 deletions(-)

diff --git a/builtin/reflog.c b/builtin/reflog.c
index 3acef5a0ab..5a3f8ab0ee 100644
--- a/builtin/reflog.c
+++ b/builtin/reflog.c
@@ -257,6 +257,7 @@ static void mark_reachable(struct expire_reflog_policy_cb *cb)
 
 static int unreachable(struct expire_reflog_policy_cb *cb, struct commit *commit, struct object_id *oid)
 {
+	fprintf(stderr, "unreachable b\n");
 	/*
 	 * We may or may not have the commit yet - if not, look it
 	 * up using the supplied sha1.
@@ -292,27 +293,43 @@ static int should_expire_reflog_ent(struct object_id *ooid, struct object_id *no
 				    const char *email, timestamp_t timestamp, int tz,
 				    const char *message, void *cb_data)
 {
+	fprintf(stderr, "should_expire_reflog_ent b\n");
 	struct expire_reflog_policy_cb *cb = cb_data;
 	struct commit *old_commit, *new_commit;
 
-	if (timestamp < cb->cmd.expire_total)
+	fprintf(stderr, "should_expire_reflog_ent b.1\n");
+	if (timestamp < cb->cmd.expire_total) {
+		fprintf(stderr, "should_expire_reflog_ent e\n");
 		return 1;
+	}
 
+	fprintf(stderr, "should_expire_reflog_ent b.2\n");
 	old_commit = new_commit = NULL;
 	if (cb->cmd.stalefix &&
-	    (!keep_entry(&old_commit, ooid) || !keep_entry(&new_commit, noid)))
+	    (!keep_entry(&old_commit, ooid) || !keep_entry(&new_commit, noid))) {
+		fprintf(stderr, "should_expire_reflog_ent e\n");
 		return 1;
+	}
 
+	fprintf(stderr, "should_expire_reflog_ent b.3\n");
 	if (timestamp < cb->cmd.expire_unreachable) {
-		if (cb->unreachable_expire_kind == UE_ALWAYS)
+		if (cb->unreachable_expire_kind == UE_ALWAYS) {
+			fprintf(stderr, "should_expire_reflog_ent e\n");
 			return 1;
-		if (unreachable(cb, old_commit, ooid) || unreachable(cb, new_commit, noid))
+		}
+		if (unreachable(cb, old_commit, ooid) || unreachable(cb, new_commit, noid)) {
+			fprintf(stderr, "should_expire_reflog_ent e\n");
 			return 1;
+		}
 	}
 
-	if (cb->cmd.recno && --(cb->cmd.recno) == 0)
+	fprintf(stderr, "should_expire_reflog_ent b.4\n");
+	if (cb->cmd.recno && --(cb->cmd.recno) == 0) {
+		fprintf(stderr, "should_expire_reflog_ent e\n");
 		return 1;
+	}
 
+	fprintf(stderr, "should_expire_reflog_ent e\n");
 	return 0;
 }
 
diff --git a/refs/files-backend.c b/refs/files-backend.c
index 16ef9325e0..44b38b359a 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
@@ -2950,6 +2950,7 @@ static int expire_reflog_ent(struct object_id *ooid, struct object_id *noid,
 	struct expire_reflog_cb *cb = cb_data;
 	struct expire_reflog_policy_cb *policy_cb = cb->policy_cb;
 
+	fprintf(stderr, "now expiring ent\n");
 	if (cb->flags & EXPIRE_REFLOGS_REWRITE)
 		ooid = &cb->last_kept_oid;
 
@@ -2991,6 +2992,7 @@ static int files_reflog_expire(struct ref_store *ref_store,
 	int type;
 	struct strbuf err = STRBUF_INIT;
 
+	fprintf(stderr, "fre b\n");
 	memset(&cb, 0, sizeof(cb));
 	cb.flags = flags;
 	cb.policy_cb = policy_cb_data;
@@ -3039,9 +3041,11 @@ static int files_reflog_expire(struct ref_store *ref_store,
 		}
 	}
 
+	fprintf(stderr, "fre pp %s\n", refname);
 	(*prepare_fn)(refname, oid, cb.policy_cb);
 	refs_for_each_reflog_ent(ref_store, refname, expire_reflog_ent, &cb);
 	(*cleanup_fn)(cb.policy_cb);
+	fprintf(stderr, "fre cu\n");
 
 	if (!(flags & EXPIRE_REFLOGS_DRY_RUN)) {
 		/*
@@ -3074,6 +3078,7 @@ static int files_reflog_expire(struct ref_store *ref_store,
 			status |= error("couldn't set %s", lock->ref_name);
 		}
 	}
+	fprintf(stderr, "fre e\n");
 	free(log_file);
 	unlock_ref(lock);
 	return status;
-- 
2.19.0.444.g18242da7ef

