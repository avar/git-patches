From 062fb3f454e79a7cf8dcb73d7ab44f0ea41d40d7 Mon Sep 17 00:00:00 2001
Message-Id: <cover-0.3-00000000000-20220607T154420Z-avarab@gmail.com>
In-Reply-To: <RFC-cover-00.15-00000000000-20220603T183608Z-avarab@gmail.com>
References: <RFC-cover-00.15-00000000000-20220603T183608Z-avarab@gmail.com>
From: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
Date: Tue, 7 Jun 2022 17:44:20 +0200
Subject: [PATCH 0/3] *** SUBJECT HERE ***
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

*** BLURB HERE ***

Ævar Arnfjörð Bjarmason (3):
  remote.c: remove braces from one-statement "for"-loops
  remote.c: don't dereference NULL in freeing loop
  remote API: don't buggily FREE_AND_NULL(), free() instead

 remote.c     | 23 ++++++++++-------------
 remote.h     | 10 +++++++++-
 repository.c |  2 +-
 3 files changed, 20 insertions(+), 15 deletions(-)

Range-diff:
 1:  b3a678d934a !  1:  1879ed2826e remote.c: don't dereference NULL in freeing loop
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    remote.c: don't dereference NULL in freeing loop
    +    remote.c: remove braces from one-statement "for"-loops
     
    -    Fix a bug in fd3cb0501e1 (remote: move static variables into
    -    per-repository struct, 2021-11-17) where we'd free(remote->pushurl[i])
    -    after having NULL'd out remote->pushurl. itself.
    -
    -    While we're at it let's get rid of the redundant braces per the
    -    CodingGuidelines, which also serves to show in the diff context that
    -    we were doing a FREE_AND_NULL(remote->pushurl) afterwards too, let's
    -    keep that one.
    +    Remove braces that don't follow the CodingGuidelines from code added
    +    in fd3cb0501e1 (remote: move static variables into per-repository
    +    struct, 2021-11-17). A subsequent commit will edit code adjacent to
    +    this.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
    @@ remote.c: static void remote_clear(struct remote *remote)
     +	for (i = 0; i < remote->url_nr; i++)
      		free((char *)remote->url[i]);
     -	}
    --	FREE_AND_NULL(remote->pushurl);
    --
    + 	FREE_AND_NULL(remote->pushurl);
    + 
     -	for (i = 0; i < remote->pushurl_nr; i++) {
     +	for (i = 0; i < remote->pushurl_nr; i++)
      		free((char *)remote->pushurl[i]);
    @@ remote.c: static void remote_clear(struct remote *remote)
      	FREE_AND_NULL(remote->pushurl);
      	free((char *)remote->receivepack);
      	free((char *)remote->uploadpack);
    +@@ remote.c: void remote_state_clear(struct remote_state *remote_state)
    + {
    + 	int i;
    + 
    +-	for (i = 0; i < remote_state->remotes_nr; i++) {
    ++	for (i = 0; i < remote_state->remotes_nr; i++)
    + 		remote_clear(remote_state->remotes[i]);
    +-	}
    + 	FREE_AND_NULL(remote_state->remotes);
    + 	remote_state->remotes_alloc = 0;
    + 	remote_state->remotes_nr = 0;
 2:  4a055969ea5 <  -:  ----------- pull.c: don't feed NULL to strcmp() on get_rebase_fork_point() path
 3:  0b570d112fc <  -:  ----------- reftable: don't memset() a NULL from failed malloc()
 4:  3a287c19d7e <  -:  ----------- diff-lib.c: don't dereference NULL in oneway_diff()
 5:  46e0c307941 <  -:  ----------- refs/packed-backend.c: add a BUG() if iter is NULL
 6:  2d04035d7aa <  -:  ----------- ref-filter.c: BUG() out on show_ref() with NULL refname
 7:  cf1a5f3ed0f <  -:  ----------- strbuf.c: placate -fanalyzer in strbuf_grow()
 8:  2c4b7832144 <  -:  ----------- strbuf.c: use st_add3(), not unsigned_add_overflows()
 9:  de0f7722608 !  2:  0e258c230f6 add-patch: assert parse_diff() expectations with BUG()
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    add-patch: assert parse_diff() expectations with BUG()
    +    remote.c: don't dereference NULL in freeing loop
     
    -    Assert that this code added in [1], [2] and other related commits
    -    expects that once we see a "diff " line we should have a non-NULL
    -    "file_diff" and "hunk".
    +    Fix a bug in fd3cb0501e1 (remote: move static variables into
    +    per-repository struct, 2021-11-17) where we'd free(remote->pushurl[i])
    +    after having NULL'd out remote->pushurl. itself. We free
    +    "remote->pushurl" in the next "for"-loop, so doing this appears to
    +    have been a copy/paste error.
     
    -    In practice this would have always been the case, as we are parsing
    -    our own "diff" output, but e.g. GCC v12's -fanalyzer doesn't know
    -    that, and will alert us that in the "else if" and below in this
    -    function we could be dereferencing NULL if we were processing anything
    -    except our expected input.
    +    Before this change GCC 12's -fanalyzer would correctly note that we'd
    +    dereference NULL in this case, this change fixes that:
     
    -    1. f6aa7ecc343 (built-in add -i: start implementing the `patch`
    -       functionality in C, 2019-12-13)
    -    2. 80399aec5ab (built-in add -p: support multi-file diffs, 2019-12-13)
    +            remote.c: In function ‘remote_clear’:
    +            remote.c:153:17: error: dereference of NULL ‘*remote.pushurl’ [CWE-476] [-Werror=analyzer-null-dereference]
    +              153 |                 free((char *)remote->pushurl[i]);
    +                  |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    +                  [...]
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
    - ## add-patch.c ##
    -@@ add-patch.c: static int parse_diff(struct add_p_state *s, const struct pathspec *ps)
    - 	while (p != pend) {
    - 		char *eol = memchr(p, '\n', pend - p);
    - 		const char *deleted = NULL, *mode_change = NULL;
    -+		const char *const diff_l = "diff ";
    -+		int is_diff_line = starts_with(p, diff_l);
    + ## remote.c ##
    +@@ remote.c: static void remote_clear(struct remote *remote)
      
    - 		if (!eol)
    - 			eol = pend;
    + 	for (i = 0; i < remote->url_nr; i++)
    + 		free((char *)remote->url[i]);
    +-	FREE_AND_NULL(remote->pushurl);
    ++	FREE_AND_NULL(remote->url);
      
    --		if (starts_with(p, "diff ")) {
    -+		if (!is_diff_line && (!file_diff || !hunk))
    -+			BUG("expected '%s' line to follow a '%s' line", p, diff_l);
    -+
    -+		if (is_diff_line) {
    - 			complete_file(marker, hunk);
    - 			ALLOC_GROW_BY(s->file_diff, s->file_diff_nr, 1,
    - 				   file_diff_alloc);
    + 	for (i = 0; i < remote->pushurl_nr; i++)
    + 		free((char *)remote->pushurl[i]);
10:  b50558d3b24 <  -:  ----------- reftable: don't have reader_get_block() confuse -fanalyzer
11:  66518467e1d <  -:  ----------- blame.c: clarify the state of "final_commit" for -fanalyzer
12:  9f0f515ed3a <  -:  ----------- pack.h: wrap write_*file*() functions
13:  63eeb66185a !  3:  062fb3f454e pack-write API: pass down "verify" not arbitrary flags
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    pack-write API: pass down "verify" not arbitrary flags
    +    remote API: don't buggily FREE_AND_NULL(), free() instead
     
    -    Change the pack-write API to accept a boolean "verify" parameter
    -    instead of passing down the "struct pack_idx_option" flags directly.
    +    Change the buggy "remote_clear()" function to stop pretending to to be
    +    able to zero out a "struct remote". Setting "url" and "pushurl" to
    +    NULL results in an invalid state unless the corresponding "url_nr" and
    +    "pushurl_nr" are also set to zero.
     
    -    This simplifies the code for both humans and machines, e.g. GCC's
    -    -fanalyzer would correctly note that there were potential paths
    -    through this code where we'd deference NULL, but in reality we
    -    wouldn't hit them because certain flags would always go hand-in-hand.
    +    In this case however we do not use the "struct remote", so the
    +    FREE_AND_NULL() pattern added in fd3cb0501e1 (remote: move static
    +    variables into per-repository struct, 2021-11-17) can be replaced with
    +    free().
     
    -    Let's instead separate the underlying API from the total set of flags,
    -    and stop passing the flags down to functions that don't need the full
    -    set of flags, they'll just get the specific state they need.
    +    The API was also odd in that remote_state_new() would xmalloc() for us,
    +    but the user had to free() it themselves, let's instead change the
    +    behavior to have the destructor free() what we malloc() in the
    +    constructer.
     
    -    See e37d0b8730b (builtin/index-pack.c: write reverse indexes,
    -    2021-01-25) for the initial implementation, and [1] for the initial
    -    WIP version of this commit on the ML.
    -
    -    1. https://lore.kernel.org/git/87v93bidhn.fsf@evledraar.gmail.com/
    +    In this case this appears to have been done for consistency with
    +    repo_clear(), let's instead have repo_clear() handle the NULL-ing of
    +    its "remote_state", and not attempt to reset the structure in remote.c
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
    - ## builtin/fast-import.c ##
    -@@ builtin/fast-import.c: static const char *create_index(void)
    - 		die("internal consistency error creating the index");
    - 
    - 	tmpfile = write_idx_file(NULL, idx, object_count, &pack_idx_opts,
    --				 pack_data->hash);
    -+				 pack_data->hash, 0);
    - 	free(idx);
    - 	return tmpfile;
    - }
    -
    - ## builtin/index-pack.c ##
    -@@ builtin/index-pack.c: static int git_index_pack_config(const char *k, const char *v, void *cb)
    - 		}
    - 		return 0;
    - 	}
    --	if (!strcmp(k, "pack.writereverseindex")) {
    --		if (git_config_bool(k, v))
    --			opts->flags |= WRITE_REV;
    --		else
    --			opts->flags &= ~WRITE_REV;
    --	}
    -+	if (!strcmp(k, "pack.writereverseindex"))
    -+		opts->write_rev = git_config_bool(k, v);
    -+
    - 	return git_default_config(k, v, cb);
    + ## remote.c ##
    +@@ remote.c: static void remote_clear(struct remote *remote)
    + 
    + 	for (i = 0; i < remote->url_nr; i++)
    + 		free((char *)remote->url[i]);
    +-	FREE_AND_NULL(remote->url);
    ++	free(remote->url);
    + 
    + 	for (i = 0; i < remote->pushurl_nr; i++)
    + 		free((char *)remote->pushurl[i]);
    +-	FREE_AND_NULL(remote->pushurl);
    ++	free(remote->pushurl);
    + 	free((char *)remote->receivepack);
    + 	free((char *)remote->uploadpack);
    +-	FREE_AND_NULL(remote->http_proxy);
    +-	FREE_AND_NULL(remote->http_proxy_authmethod);
    ++	free(remote->http_proxy);
    ++	free(remote->http_proxy_authmethod);
      }
      
    -@@ builtin/index-pack.c: static void show_pack_info(int stat_only)
    - 
    - int cmd_index_pack(int argc, const char **argv, const char *prefix)
    - {
    --	int i, fix_thin_pack = 0, verify = 0, stat_only = 0, rev_index;
    -+	int i, fix_thin_pack = 0, verify = 0, stat_only = 0;
    - 	const char *curr_index;
    - 	const char *curr_rev_index = NULL;
    - 	const char *index_name = NULL, *pack_name = NULL, *rev_index_name = NULL;
    -@@ builtin/index-pack.c: int cmd_index_pack(int argc, const char **argv, const char *prefix)
    - 	if (prefix && chdir(prefix))
    - 		die(_("Cannot come back to cwd"));
    - 
    --	if (git_env_bool(GIT_TEST_WRITE_REV_INDEX, 0))
    --		rev_index = 1;
    --	else
    --		rev_index = !!(opts.flags & (WRITE_REV_VERIFY | WRITE_REV));
    -+	opts.write_rev = git_env_bool(GIT_TEST_WRITE_REV_INDEX,
    -+				       opts.write_rev);
    - 
    - 	for (i = 1; i < argc; i++) {
    - 		const char *arg = argv[i];
    -@@ builtin/index-pack.c: int cmd_index_pack(int argc, const char **argv, const char *prefix)
    - 					die(_("unknown hash algorithm '%s'"), arg);
    - 				repo_set_hash_algo(the_repository, hash_algo);
    - 			} else if (!strcmp(arg, "--rev-index")) {
    --				rev_index = 1;
    -+				opts.write_rev = 1;
    - 			} else if (!strcmp(arg, "--no-rev-index")) {
    --				rev_index = 0;
    -+				opts.write_rev = 0;
    - 			} else
    - 				usage(index_pack_usage);
    - 			continue;
    -@@ builtin/index-pack.c: int cmd_index_pack(int argc, const char **argv, const char *prefix)
    - 	if (!index_name && pack_name)
    - 		index_name = derive_filename(pack_name, "pack", "idx", &index_name_buf);
    - 
    --	opts.flags &= ~(WRITE_REV | WRITE_REV_VERIFY);
    --	if (rev_index) {
    --		opts.flags |= verify ? WRITE_REV_VERIFY : WRITE_REV;
    -+	if (opts.write_rev) {
    - 		if (index_name)
    - 			rev_index_name = derive_filename(index_name,
    - 							 "idx", "rev",
    -@@ builtin/index-pack.c: int cmd_index_pack(int argc, const char **argv, const char *prefix)
    - 		if (!index_name)
    - 			die(_("--verify with no packfile name given"));
    - 		read_idx_option(&opts, index_name);
    --		opts.flags |= WRITE_IDX_VERIFY | WRITE_IDX_STRICT;
    - 	}
    - 	if (strict)
    --		opts.flags |= WRITE_IDX_STRICT;
    -+		opts.write_idx_strict = 1;
    - 
    - 	if (HAVE_THREADS && !nr_threads) {
    - 		nr_threads = online_cpus();
    -@@ builtin/index-pack.c: int cmd_index_pack(int argc, const char **argv, const char *prefix)
    - 	ALLOC_ARRAY(idx_objects, nr_objects);
    - 	for (i = 0; i < nr_objects; i++)
    - 		idx_objects[i] = &objects[i].idx;
    --	curr_index = write_idx_file(index_name, idx_objects, nr_objects, &opts, pack_hash);
    --	if (rev_index)
    -+	curr_index = write_idx_file(index_name, idx_objects, nr_objects, &opts,
    -+				    pack_hash, verify);
    -+	if (opts.write_rev)
    - 		curr_rev_index = write_rev_file(rev_index_name, idx_objects,
    - 						nr_objects, pack_hash,
    --						opts.flags);
    -+						verify);
    - 	free(idx_objects);
    - 
    - 	if (!verify)
    -
    - ## builtin/pack-objects.c ##
    -@@ builtin/pack-objects.c: static int git_pack_config(const char *k, const char *v, void *cb)
    - 		return 0;
    - 	}
    - 	if (!strcmp(k, "pack.writereverseindex")) {
    --		if (git_config_bool(k, v))
    --			pack_idx_opts.flags |= WRITE_REV;
    --		else
    --			pack_idx_opts.flags &= ~WRITE_REV;
    -+		pack_idx_opts.write_rev = git_config_bool(k, v);
    - 		return 0;
    - 	}
    - 	if (!strcmp(k, "uploadpack.blobpackfileuri")) {
    -@@ builtin/pack-objects.c: int cmd_pack_objects(int argc, const char **argv, const char *prefix)
    - 
    - 	reset_pack_idx_option(&pack_idx_opts);
    - 	git_config(git_pack_config, NULL);
    --	if (git_env_bool(GIT_TEST_WRITE_REV_INDEX, 0))
    --		pack_idx_opts.flags |= WRITE_REV;
    -+	pack_idx_opts.write_rev = git_env_bool(GIT_TEST_WRITE_REV_INDEX,
    -+					       pack_idx_opts.write_rev);
    - 
    - 	progress = isatty(2);
    - 	argc = parse_options(argc, argv, prefix, pack_objects_options,
    -
    - ## midx.c ##
    -@@ midx.c: static void write_midx_reverse_index(char *midx_name, unsigned char *midx_hash,
    - 	strbuf_addf(&buf, "%s-%s.rev", midx_name, hash_to_hex(midx_hash));
    - 
    - 	tmp_file = write_rev_file_order(NULL, ctx->pack_order, ctx->entries_nr,
    --					midx_hash, WRITE_REV);
    -+					midx_hash, 0);
    + static void add_merge(struct branch *branch, const char *name)
    +@@ remote.c: void remote_state_clear(struct remote_state *remote_state)
      
    - 	if (finalize_object_file(tmp_file, buf.buf))
    - 		die(_("cannot store reverse index file"));
    -
    - ## pack-write.c ##
    -@@ pack-write.c: static int need_large_offset(off_t offset, const struct pack_idx_option *opts)
    -  */
    - const char *write_idx_file(const char *index_name, struct pack_idx_entry **objects,
    - 			   int nr_objects, const struct pack_idx_option *opts,
    --			   const unsigned char *sha1)
    -+			   const unsigned char *sha1, int verify)
    - {
    - 	struct hashfile *f;
    - 	struct pack_idx_entry **sorted_by_sha, **list, **last;
    -@@ pack-write.c: const char *write_idx_file(const char *index_name, struct pack_idx_entry **objec
    - 	else
    - 		sorted_by_sha = list = last = NULL;
    - 
    --	if (opts->flags & WRITE_IDX_VERIFY) {
    -+	if (verify) {
    - 		assert(index_name);
    - 		f = hashfd_check(index_name);
    - 	} else {
    -@@ pack-write.c: const char *write_idx_file(const char *index_name, struct pack_idx_entry **objec
    - 		if (index_version < 2)
    - 			hashwrite_be32(f, obj->offset);
    - 		hashwrite(f, obj->oid.hash, the_hash_algo->rawsz);
    --		if ((opts->flags & WRITE_IDX_STRICT) &&
    -+		if (opts->write_idx_strict &&
    - 		    (i && oideq(&list[-2]->oid, &obj->oid)))
    - 			die("The same object %s appears twice in the pack",
    - 			    oid_to_hex(&obj->oid));
    -@@ pack-write.c: const char *write_idx_file(const char *index_name, struct pack_idx_entry **objec
    - 	}
    + 	for (i = 0; i < remote_state->remotes_nr; i++)
    + 		remote_clear(remote_state->remotes[i]);
    +-	FREE_AND_NULL(remote_state->remotes);
    +-	remote_state->remotes_alloc = 0;
    +-	remote_state->remotes_nr = 0;
    ++	free(remote_state->remotes);
      
    - 	hashwrite(f, sha1, the_hash_algo->rawsz);
    + 	hashmap_clear_and_free(&remote_state->remotes_hash, struct remote, ent);
    + 	hashmap_clear_and_free(&remote_state->branches_hash, struct remote, ent);
     +
    - 	finalize_hashfile(f, NULL, FSYNC_COMPONENT_PACK_METADATA,
    - 			  CSUM_HASH_IN_STREAM | CSUM_CLOSE |
    --			  ((opts->flags & WRITE_IDX_VERIFY) ? 0 : CSUM_FSYNC));
    -+			  (verify ? 0 : CSUM_FSYNC));
    - 	return index_name;
    ++	free(remote_state);
      }
      
    -@@ pack-write.c: const char *write_rev_file(const char *rev_name,
    - 			   struct pack_idx_entry **objects,
    - 			   uint32_t nr_objects,
    - 			   const unsigned char *hash,
    --			   unsigned flags)
    -+			   int verify)
    - {
    - 	uint32_t *pack_order;
    - 	uint32_t i;
    - 	const char *ret;
    - 
    --	if (!(flags & WRITE_REV) && !(flags & WRITE_REV_VERIFY))
    --		return NULL;
    --
    - 	ALLOC_ARRAY(pack_order, nr_objects);
    - 	for (i = 0; i < nr_objects; i++)
    - 		pack_order[i] = i;
    - 	QSORT_S(pack_order, nr_objects, pack_order_cmp, objects);
    - 
    - 	ret = write_rev_file_order(rev_name, pack_order, nr_objects, hash,
    --				   flags);
    -+				   verify);
    - 
    - 	free(pack_order);
    - 
    -@@ pack-write.c: const char *write_rev_file_order(const char *rev_name,
    - 				 uint32_t *pack_order,
    - 				 uint32_t nr_objects,
    - 				 const unsigned char *hash,
    --				 unsigned flags)
    -+				 int verify)
    - {
    - 	struct hashfile *f;
    - 	int fd;
    - 
    --	if ((flags & WRITE_REV) && (flags & WRITE_REV_VERIFY))
    --		die(_("cannot both write and verify reverse index"));
    --
    --	if (flags & WRITE_REV) {
    -+	if (!verify) {
    - 		if (!rev_name) {
    - 			struct strbuf tmp_file = STRBUF_INIT;
    - 			fd = odb_mkstemp(&tmp_file, "pack/tmp_rev_XXXXXX");
    -@@ pack-write.c: const char *write_rev_file_order(const char *rev_name,
    - 			fd = xopen(rev_name, O_CREAT|O_EXCL|O_WRONLY, 0600);
    - 		}
    - 		f = hashfd(fd, rev_name);
    --	} else if (flags & WRITE_REV_VERIFY) {
    -+	} else {
    - 		struct stat statbuf;
    - 		if (stat(rev_name, &statbuf)) {
    - 			if (errno == ENOENT) {
    -@@ pack-write.c: const char *write_rev_file_order(const char *rev_name,
    - 				die_errno(_("could not stat: %s"), rev_name);
    - 		}
    - 		f = hashfd_check(rev_name);
    --	} else
    --		return NULL;
    -+	}
    - 
    - 	write_rev_header(f);
    - 
    -@@ pack-write.c: const char *write_rev_file_order(const char *rev_name,
    - 
    - 	finalize_hashfile(f, NULL, FSYNC_COMPONENT_PACK_METADATA,
    - 			  CSUM_HASH_IN_STREAM | CSUM_CLOSE |
    --			  ((flags & WRITE_IDX_VERIFY) ? 0 : CSUM_FSYNC));
    -+			  (verify ? 0 : CSUM_FSYNC));
    + /*
    +
    + ## remote.h ##
    +@@ remote.h: struct remote_state {
    + 	int initialized;
    + };
    + 
    +-void remote_state_clear(struct remote_state *remote_state);
    ++/**
    ++ * xmalloc() a "struct remote_state" and initialize it. The resulting
    ++ * data should be free'd with remote_state_clear().
    ++ */
    + struct remote_state *remote_state_new(void);
    + 
    ++/**
    ++ * free() the structure returned by remote_state_new().
    ++ */
    ++void remote_state_clear(struct remote_state *remote_state);
     +
    + struct remote {
    + 	struct hashmap_entry ent;
      
    - 	return rev_name;
    - }
    -@@ pack-write.c: void stage_tmp_packfiles(struct strbuf *name_buffer,
    - 		die_errno("unable to make temporary pack file readable");
    - 
    - 	*idx_tmp_name = (char *)write_idx_file(NULL, written_list, nr_written,
    --					       pack_idx_opts, hash);
    -+					       pack_idx_opts, hash, 0);
    - 	if (adjust_shared_perm(*idx_tmp_name))
    - 		die_errno("unable to make temporary index file readable");
    - 
    --	rev_tmp_name = write_rev_file(NULL, written_list, nr_written, hash,
    --				      pack_idx_opts->flags);
    -+	if (pack_idx_opts->write_rev)
    -+		rev_tmp_name = write_rev_file(NULL, written_list, nr_written, hash,
    -+					      0);
    - 
    - 	rename_tmp_packfile(name_buffer, pack_tmp_name, "pack");
    - 	if (rev_tmp_name)
     
    - ## pack.h ##
    -@@ pack.h: struct pack_header {
    - #define PACK_IDX_SIGNATURE 0xff744f63	/* "\377tOc" */
    - 
    - struct pack_idx_option {
    --	unsigned flags;
    --	/* flag bits */
    --#define WRITE_IDX_VERIFY 01 /* verify only, do not write the idx file */
    --#define WRITE_IDX_STRICT 02
    --#define WRITE_REV 04
    --#define WRITE_REV_VERIFY 010
    -+	unsigned int write_idx_strict:1,
    -+		     write_rev:1;
    + ## repository.c ##
    +@@ repository.c: void repo_clear(struct repository *repo)
      
    - 	uint32_t version;
    - 	uint32_t off32_limit;
    -@@ pack.h: typedef int (*verify_fn)(const struct object_id *, enum object_type, unsigned lo
    - const char *write_idx_file(const char *index_name,
    - 			   struct pack_idx_entry **objects, int nr_objects,
    - 			   const struct pack_idx_option *opts,
    --			   const unsigned char *sha1);
    -+			   const unsigned char *sha1,
    -+			   int verify);
    - int check_pack_crc(struct packed_git *p, struct pack_window **w_curs, off_t offset, off_t len, unsigned int nr);
    - int verify_pack_index(struct packed_git *);
    - int verify_pack(struct repository *, struct packed_git *, verify_fn fn, struct progress *, uint32_t);
    -@@ pack.h: void write_promisor_file(const char *promisor_name, struct ref **sought, int nr_
    - const char *write_rev_file(const char *rev_name,
    - 			   struct pack_idx_entry **objects,
    - 			   uint32_t nr_objects,
    --			   const unsigned char *hash, unsigned flags);
    -+			   const unsigned char *hash, int verify);
    - const char *write_rev_file_order(const char *rev_name, uint32_t *pack_order,
    - 				 uint32_t nr_objects,
    - 				 const unsigned char *hash,
    --				 unsigned flags);
    -+				 int verify);
    + 	if (repo->remote_state) {
    + 		remote_state_clear(repo->remote_state);
    +-		FREE_AND_NULL(repo->remote_state);
    ++		repo->remote_state = NULL;
    + 	}
      
    - /*
    -  * The "hdr" output buffer should be at least this big, which will handle sizes
    + 	repo_clear_path_cache(&repo->cached_paths);
14:  9cf550688d4 <  -:  ----------- config.mak.dev: add a DEVOPTS=analyzer mode to use GCC's -fanalyzer
15:  16bd2270b4c <  -:  ----------- config.mak.dev: add and use ASSERT_FOR_FANALYZER() macro
-- 
2.36.1.1178.g0c3594a0ba5

