From b28a9c76b30b624108c59667e266647815e856c8 Mon Sep 17 00:00:00 2001
Message-Id: <cover-v4-00.80-00000000000-20210804T164956Z-avarab@gmail.com>
In-Reply-To: <cover-00.12-00000000000-20210721T233307Z-avarab@gmail.com>
References: <cover-00.12-00000000000-20210721T233307Z-avarab@gmail.com>
From: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
Date: Wed, 4 Aug 2021 18:49:56 +0200
Subject: [PATCH v4 00/80] *** SUBJECT HERE ***
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

*** BLURB HERE ***

Denton Liu (2):
  pkt-line: replace "stateless separator" with "response end"
  git-diff: fix missing --merge-base docs

Derrick Stolee (16):
  sparse-index: skip indexes with unmerged entries
  sparse-index: include EXTENDED flag when expanding
  t1092: replace incorrect 'echo' with 'cat'
  t1092: expand repository data shape
  t1092: add tests for status/add and sparse files
  unpack-trees: preserve cache_bottom
  unpack-trees: compare sparse directories correctly
  unpack-trees: rename unpack_nondirectories()
  unpack-trees: unpack sparse directory entries
  dir.c: accept a directory as part of cone-mode patterns
  diff-lib: handle index diffs with sparse dirs
  status: skip sparse-checkout percentage with sparse-index
  status: use sparse-index throughout
  wt-status: expand added sparse directory entries
  fsmonitor: integrate with sparse index
  t1092: document bad sparse-checkout behavior

Elijah Newren (4):
  diff: correct warning message when renameLimit exceeded
  doc: clarify documentation for rename/copy limits
  diffcore-rename: treat a rename_limit of 0 as unlimited
  rename: bump limit defaults yet again

Eric Wong (5):
  speed up alt_odb_usable() with many alternates
  avoid strlen via strbuf_addstr in link_alt_odb_entry
  make object_directory.loose_objects_subdir_seen a bitmap
  oidcpy_with_padding: constify `src' arg
  oidtree: a crit-bit tree for odb_loose_cache

Felipe Contreras (1):
  doc: pull: fix rebase=false documentation

Han-Wen Nienhuys (1):
  refs/debug: quote prefix

Hu Jialun (2):
  commit: reorganise commit hint strings
  commit: remove irrelavent prompt on `--allow-empty-message`

Jeff King (14):
  pretty.h: update and expand docstring for
    userformat_find_requirements()
  log: avoid loading decorations for userformats that don't need it
  object.h: expand docstring for lookup_unknown_object()
  object.h: add lookup_object_by_type() function
  load_ref_decorations(): avoid parsing non-tag objects
  add_ref_decoration(): rename s/type/deco_type/
  load_ref_decorations(): fix decoration with tags
  t0000: clear GIT_SKIP_TESTS before running sub-tests
  doc/git-config: explain --file instead of referring to GIT_CONFIG
  doc/git-config: clarify GIT_CONFIG environment variable
  doc/git-config: simplify "override" advice for FILES section
  pack-bitmap: check pack validity when opening bitmap
  ci: run "apt-get update" before "apt-get install"
  ci/install-dependencies: handle "sparse" job package installs

Johannes Schindelin (3):
  ci: run `make sparse` as part of the GitHub workflow
  ci(check-whitespace): stop requiring a read/write token
  ci(check-whitespace): restrict to the intended commits

Jonathan Tan (2):
  unpack-trees: refactor prefetching code
  cache-tree: prefetch in partial clone read-tree

Junio C Hamano (3):
  CodingGuidelines: recommend gender-neutral description
  The seventh batch
  Git 2.33-rc0

Patrick Steinhardt (2):
  perf: fix when running with TEST_OUTPUT_DIRECTORY
  t0000: fix test if run with TEST_OUTPUT_DIRECTORY

Philippe Blain (2):
  parse-options: don't complete option aliases by default
  doc: clarify description of 'submodule.recurse'

Stephen Manz (3):
  t2400: clean up '"add" worktree with lock' test
  worktree: mark lock strings with `_()` for translation
  worktree: teach `add` to accept --reason <string> with --lock

Taylor Blau (2):
  multi-pack-index: fix potential segfault without sub-command
  pack-bitmap: clarify comment in filter_bitmap_exclude_type()

Ævar Arnfjörð Bjarmason (18):
  *.c static functions: don't forward-declare __attribute__
  sequencer.c: move static function to avoid forward decl
  *.c static functions: add missing __attribute__((format))
  *.h: add a few missing __attribute__((format))
  advice.h: add missing __attribute__((format)) & fix usage
  test-lib-functions: use test-tool for [de]packetize()
  bundle tests: use ">file" not ": >file"
  bundle tests: use test_cmp instead of grep
  serve: mark has_capability() as static
  transport: rename "fetch" in transport_vtable to "fetch_refs"
  transport: use designated initializers
  serve: use designated initializers
  serve: move transfer.advertiseSID check into session_id_advertise()
  serve.c: move version line to advertise_capabilities()
  serve.[ch]: don't pass "struct strvec *keys" to commands
  serve.[ch]: remove "serve_options", split up --advertise-refs code
  {upload,receive}-pack tests: add --advertise-refs tests
  upload-pack: document and rename --advertise-refs

Range-diff against v3:
  -:  ----------- >   1:  ecc4ee9cac6 send-email tests: support GIT_TEST_PERL_FATAL_WARNINGS=true
  -:  ----------- >   2:  879be4319f7 send-email tests: test for boolean variables without a value
  -:  ----------- >   3:  671818ab0b8 send-email: remove non-working support for "sendemail.smtpssl"
  -:  ----------- >   4:  119974e9e7f send-email: refactor sendemail.smtpencryption config parsing
  -:  ----------- >   5:  2b110e9ba25 send-email: copy "config_regxp" into git-send-email.perl
 21:  99eeff6f890 !   6:  9264d29bf6d serve.c: add call_{advertise,command}() indirection
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    serve.c: add call_{advertise,command}() indirection
    +    send-email: lazily load config for a big speedup
     
    -    Instead of directly calling the callbacks defined in the "struct
    -    protocol_capability", let's call them via new
    -    "call_{advertise,command}()" functions. There's no use in this
    -    indirection now, but it'll be used in a subsequent commit to ensure
    -    that config is read before they're called.
    +    Reduce the time it takes git-send-email to get to even the most
    +    trivial of tasks (such as serving up its "-h" output) by first listing
    +    config keys that exist, and only then only call e.g. "git config
    +    --bool" on them if they do.
     
    -    See ed10cb952d3 (serve: introduce git-serve, 2018-03-15) for the
    -    introduction of the code being changed here.
    +    Over a lot of runs this speeds the time to "-h" up for me from ~250ms
    +    to ~150ms, and the runtime of t9001-send-email.sh goes from ~25s to
    +    ~20s.
    +
    +    This introduces a race condition where we'll do the "wrong" thing if a
    +    config key were to be inserted between us discovering the list and
    +    calling read_config(), i.e. we won't know about the racily added
    +    key. In theory this is a change in behavior, in practice it doesn't
    +    matter.
    +
    +    The config_regexp() function being changed here was added in
    +    dd84e528a34 (git-send-email: die if sendmail.* config is set,
    +    2020-07-23) for use by git-send-email. So we can change its odd return
    +    value in the case where no values are found by "git config". The
    +    difference in the *.pm code would matter if it was invoked in scalar
    +    context, but now it no longer is.
    +
    +    Arguably this caching belongs in Git.pm itself, but in lieu of
    +    modifying it for all its callers let's only do this for "git
    +    send-email". The other big potential win would be "git svn", but
    +    unlike "git send-email" it doesn't check tens of config variables one
    +    at a time at startup (in my brief testing it doesn't check any).
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    - ## serve.c ##
    -@@ serve.c: static int session_id_advertise(struct repository *r, struct strbuf *value)
    - 	return 1;
    - }
    + ## git-send-email.perl ##
    +@@ git-send-email.perl: sub signal_handler {
      
    -+typedef int (*advertise_fn_t)(struct repository *r, struct strbuf *value);
    -+typedef int (*command_fn_t)(struct repository *r, struct strvec *keys,
    -+			    struct packet_reader *request);
    -+
    - struct protocol_capability {
    - 	/*
    - 	 * The name of the capability.  The server uses this name when
    -@@ serve.c: struct protocol_capability {
    - 	 * If a value is added to 'value', the server will advertise this
    - 	 * capability as "<name>=<value>" instead of "<name>".
    - 	 */
    --	int (*advertise)(struct repository *r, struct strbuf *value);
    -+	advertise_fn_t advertise;
    + # Read our sendemail.* config
    + sub read_config {
    +-	my ($configured, $prefix) = @_;
    ++	my ($known_keys, $configured, $prefix) = @_;
    + 
    + 	foreach my $setting (keys %config_bool_settings) {
    + 		my $target = $config_bool_settings{$setting};
    +-		my $v = Git::config_bool(@repo, "$prefix.$setting");
    ++		my $key = "$prefix.$setting";
    ++		next unless exists $known_keys->{$key};
    ++		my $v = Git::config_bool(@repo, $key);
    + 		next unless defined $v;
    + 		next if $configured->{$setting}++;
    + 		$$target = $v;
    +@@ git-send-email.perl: sub read_config {
      
    - 	/*
    - 	 * Function called when a client requests the capability as a command.
    -@@ serve.c: struct protocol_capability {
    - 	 *
    - 	 * This field should be NULL for capabilities which are not commands.
    - 	 */
    --	int (*command)(struct repository *r,
    --		       struct strvec *keys,
    --		       struct packet_reader *request);
    -+	command_fn_t command;
    - };
    + 	foreach my $setting (keys %config_path_settings) {
    + 		my $target = $config_path_settings{$setting};
    ++		my $key = "$prefix.$setting";
    ++		next unless exists $known_keys->{$key};
    + 		if (ref($target) eq "ARRAY") {
    +-			my @values = Git::config_path(@repo, "$prefix.$setting");
    ++			my @values = Git::config_path(@repo, $key);
    + 			next unless @values;
    + 			next if $configured->{$setting}++;
    + 			@$target = @values;
    +@@ git-send-email.perl: sub read_config {
      
    - static struct protocol_capability capabilities[] = {
    -@@ serve.c: static struct protocol_capability capabilities[] = {
    - 	},
    - };
    + 	foreach my $setting (keys %config_settings) {
    + 		my $target = $config_settings{$setting};
    ++		my $key = "$prefix.$setting";
    ++		next unless exists $known_keys->{$key};
    + 		if (ref($target) eq "ARRAY") {
    +-			my @values = Git::config(@repo, "$prefix.$setting");
    ++			my @values = Git::config(@repo, $key);
    + 			next unless @values;
    + 			next if $configured->{$setting}++;
    + 			@$target = @values;
    + 		}
    + 		else {
    +-			my $v = Git::config(@repo, "$prefix.$setting");
    ++			my $v = Git::config(@repo, $key);
    + 			next unless defined $v;
    + 			next if $configured->{$setting}++;
    + 			$$target = $v;
    +@@ git-send-email.perl: sub config_regexp {
    + 	return @ret;
    + }
      
    -+static int call_advertise(struct protocol_capability *command,
    -+			  struct repository *r, struct strbuf *value)
    ++# Save ourselves a lot of work of shelling out to 'git config' (it
    ++# parses 'bool' etc.) by only doing so for config keys that exist.
    ++my %known_config_keys;
     +{
    -+	return command->advertise(r, value);
    ++	my @known_config_keys = config_regexp("^sende?mail[.]");
    ++	@known_config_keys{@known_config_keys} = ();
     +}
     +
    -+static int call_command(struct protocol_capability *command,
    -+			struct repository *r, struct strvec *keys,
    -+			struct packet_reader *request)
    + # sendemail.identity yields to --identity. We must parse this
    + # special-case first before the rest of the config is read.
    +-$identity = Git::config(@repo, "sendemail.identity");
     +{
    -+	return command->command(r, keys, request);
    ++	my $key = "sendemail.identity";
    ++	$identity = Git::config(@repo, $key) if exists $known_config_keys{$key};
     +}
    -+
    - static void advertise_capabilities(void)
    + my $rc = GetOptions(
    + 	"identity=s" => \$identity,
    + 	"no-identity" => \$no_identity,
    +@@ git-send-email.perl: sub config_regexp {
    + # Now we know enough to read the config
      {
    - 	struct strbuf capability = STRBUF_INIT;
    -@@ serve.c: static void advertise_capabilities(void)
    - 	for (i = 0; i < ARRAY_SIZE(capabilities); i++) {
    - 		struct protocol_capability *c = &capabilities[i];
    - 
    --		if (c->advertise(the_repository, &value)) {
    -+		if (call_advertise(c, the_repository, &value)) {
    - 			strbuf_addstr(&capability, c->name);
    - 
    - 			if (value.len) {
    -@@ serve.c: static struct protocol_capability *get_capability(const char *key)
    - 
    - static int is_valid_capability(const char *key)
    - {
    --	const struct protocol_capability *c = get_capability(key);
    -+	struct protocol_capability *c = get_capability(key);
    - 
    --	return c && c->advertise(the_repository, NULL);
    -+	return c && call_advertise(c, the_repository, NULL);
    +     my %configured;
    +-    read_config(\%configured, "sendemail.$identity") if defined $identity;
    +-    read_config(\%configured, "sendemail");
    ++    read_config(\%known_config_keys, \%configured, "sendemail.$identity") if defined $identity;
    ++    read_config(\%known_config_keys, \%configured, "sendemail");
      }
      
    - static int is_command(const char *key, struct protocol_capability **command)
    -@@ serve.c: static int is_command(const char *key, struct protocol_capability **command)
    - 		if (*command)
    - 			die("command '%s' requested after already requesting command '%s'",
    - 			    out, (*command)->name);
    --		if (!cmd || !cmd->advertise(the_repository, NULL) || !cmd->command)
    -+		if (!cmd || !call_advertise(cmd, the_repository, NULL) || !cmd->command)
    - 			die("invalid command '%s'", out);
    - 
    - 		*command = cmd;
    -@@ serve.c: static int process_request(void)
    - 	if (has_capability(&keys, "session-id", &client_sid))
    - 		trace2_data_string("transfer", NULL, "client-sid", client_sid);
    - 
    --	command->command(the_repository, &keys, &reader);
    -+	call_command(command, the_repository, &keys, &reader);
    + # Begin by accumulating all the variables (defined above), that we will end up
    +@@ git-send-email.perl: sub config_regexp {
    +     usage();
    + }
      
    - 	strvec_clear(&keys);
    - 	return 0;
    +-if ($forbid_sendmail_variables && (scalar config_regexp("^sendmail[.]")) != 0) {
    ++if ($forbid_sendmail_variables && grep { /^sendmail/s } keys %known_config_keys) {
    + 	die __("fatal: found configuration options for 'sendmail'\n" .
    + 		"git-send-email is configured with the sendemail.* options - note the 'e'.\n" .
    + 		"Set sendemail.forbidSendmailVariables to false to disable this check.\n");
  -:  ----------- >   7:  fef381e6dcb send-email: lazily shell out to "git var"
  -:  ----------- >   8:  4adbf387bfd send-email: use function syntax instead of barewords
  -:  ----------- >   9:  447ed29c0d4 send-email: get rid of indirect object syntax
  5:  f291cee5387 !  10:  f4dc9432fd2 upload-pack: run is_repository_shallow() before setup_revisions()
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    upload-pack: run is_repository_shallow() before setup_revisions()
    +    send-email: lazily load modules for a big speedup
     
    -    Move the is_repository_shallow() added in b790e0f67cd (upload-pack:
    -    send shallow info over stdin to pack-objects, 2014-03-11) to above
    -    setup_revisions().
    +    Optimize the time git-send-email takes to do even the simplest of
    +    things (such as serving up "-h") from around ~150ms to ~80ms-~90ms by
    +    lazily loading the modules it requires.
     
    -    Running is_repository_shallow() before setup_revisions() doesn't
    -    matter now, but in subsequent commits we'll make the code that
    -    followed setup_revisions() happen inside a callback in that
    -    function. This isolated change documents that re-arranging this part
    -    of the code is OK in isolation.
    +    Before this change Devel::TraceUse would report 99/97 used modules
    +    under NO_GETTEXT=[|Y], respectively. Now it's 52/37. It now takes ~15s
    +    to run t9001-send-email.sh, down from ~20s.
    +
    +    Changing File::Spec::Functions::{catdir,catfile} to invoking class
    +    methods on File::Spec itself is idiomatic. See [1] for a more
    +    elaborate explanation, the resulting code behaves the same way, just
    +    without the now-pointless function wrapper.
    +
    +    1. http://lore.kernel.org/git/8735u8mmj9.fsf@evledraar.gmail.com
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    - ## builtin/pack-objects.c ##
    -@@ builtin/pack-objects.c: static void get_object_list(int ac, const char **av)
    + ## git-send-email.perl ##
    +@@
    + use 5.008;
    + use strict;
    + use warnings $ENV{GIT_PERL_FATAL_WARNINGS} ? qw(FATAL all) : ();
    +-use POSIX qw/strftime/;
    +-use Term::ReadLine;
    + use Getopt::Long;
    +-use Text::ParseWords;
    +-use Term::ANSIColor;
    +-use File::Temp qw/ tempdir tempfile /;
    +-use File::Spec::Functions qw(catdir catfile);
    + use Git::LoadCPAN::Error qw(:try);
    +-use Cwd qw(abs_path cwd);
    + use Git;
    + use Git::I18N;
    +-use Net::Domain ();
    +-use Net::SMTP ();
    +-use Git::LoadCPAN::Mail::Address;
    + 
    + Getopt::Long::Configure qw/ pass_through /;
    + 
    +@@ git-send-email.perl: sub format_2822_time {
    + 		       );
    + }
    + 
    +-my $have_email_valid = eval { require Email::Valid; 1 };
    + my $smtp;
    + my $auth;
    + my $num_sent = 0;
    +@@ git-send-email.perl: sub format_2822_time {
    + 
    + my $repo = eval { Git->repository() };
    + my @repo = $repo ? ($repo) : ();
    +-my $term = eval {
    +-	$ENV{"GIT_SEND_EMAIL_NOTTY"}
    +-		? Term::ReadLine->new('git-send-email', \*STDIN, \*STDOUT)
    +-		: Term::ReadLine->new('git-send-email');
    +-};
    +-if ($@) {
    +-	$term = FakeTerm->new("$@: going non-interactive");
    +-}
    + 
    + # Behavior modification variables
    + my ($quiet, $dry_run) = (0, 0);
    +@@ git-send-email.perl: sub do_edit {
    + 
    + # Handle Uncouth Termination
    + sub signal_handler {
    +-
    + 	# Make text normal
    +-	print color("reset"), "\n";
    ++	require Term::ANSIColor;
    ++	print Term::ANSIColor::color("reset"), "\n";
    + 
    + 	# SMTP password masked
    + 	system "stty echo";
    +@@ git-send-email.perl: sub config_regexp {
    + }
      
    - 	repo_init_revisions(the_repository, &revs, NULL);
    - 	save_commit_buffer = 0;
    --	setup_revisions(ac, av, &revs, &s_r_opt);
    + sub parse_address_line {
    ++	require Git::LoadCPAN::Mail::Address;
    + 	return map { $_->format } Mail::Address->parse($_[0]);
    + }
      
    - 	/* make sure shallows are read */
    - 	is_repository_shallow(the_repository);
    + sub split_addrs {
    +-	return quotewords('\s*,\s*', 1, @_);
    ++	require Text::ParseWords;
    ++	return Text::ParseWords::quotewords('\s*,\s*', 1, @_);
    + }
      
    -+	setup_revisions(ac, av, &revs, &s_r_opt);
    + my %aliases;
    +@@ git-send-email.perl: sub parse_sendmail_aliases {
    + 			s/\\"/"/g foreach @addr;
    + 			$aliases{$alias} = \@addr
    + 		}}},
    +-	mailrc => sub { my $fh = shift; while (<$fh>) {
    ++	mailrc => sub {	my $fh = shift; while (<$fh>) {
    + 		if (/^alias\s+(\S+)\s+(.*?)\s*$/) {
    ++			require Text::ParseWords;
    + 			# spaces delimit multiple addresses
    +-			$aliases{$1} = [ quotewords('\s+', 0, $2) ];
    ++			$aliases{$1} = [ Text::ParseWords::quotewords('\s+', 0, $2) ];
    + 		}}},
    + 	pine => sub { my $fh = shift; my $f='\t[^\t]*';
    + 	        for (my $x = ''; defined($x); $x = $_) {
    +@@ git-send-email.perl: sub is_format_patch_arg {
    + 		opendir my $dh, $f
    + 			or die sprintf(__("Failed to opendir %s: %s"), $f, $!);
    + 
    +-		push @files, grep { -f $_ } map { catfile($f, $_) }
    ++		require File::Spec;
    ++		push @files, grep { -f $_ } map { File::Spec->catfile($f, $_) }
    + 				sort readdir $dh;
    + 		closedir $dh;
    + 	} elsif ((-f $f or -p $f) and !is_format_patch_arg($f)) {
    +@@ git-send-email.perl: sub is_format_patch_arg {
    + if (@rev_list_opts) {
    + 	die __("Cannot run git format-patch from outside a repository\n")
    + 		unless $repo;
    +-	push @files, $repo->command('format-patch', '-o', tempdir(CLEANUP => 1), @rev_list_opts);
    ++	require File::Temp;
    ++	push @files, $repo->command('format-patch', '-o', File::Temp::tempdir(CLEANUP => 1), @rev_list_opts);
    + }
    + 
    + @files = handle_backup_files(@files);
    +@@ git-send-email.perl: sub get_patch_subject {
    + if ($compose) {
    + 	# Note that this does not need to be secure, but we will make a small
    + 	# effort to have it be unique
    ++	require File::Temp;
    + 	$compose_filename = ($repo ?
    +-		tempfile(".gitsendemail.msg.XXXXXX", DIR => $repo->repo_path()) :
    +-		tempfile(".gitsendemail.msg.XXXXXX", DIR => "."))[1];
    ++		File::Temp::tempfile(".gitsendemail.msg.XXXXXX", DIR => $repo->repo_path()) :
    ++		File::Temp::tempfile(".gitsendemail.msg.XXXXXX", DIR => "."))[1];
    + 	open my $c, ">", $compose_filename
    + 		or die sprintf(__("Failed to open for writing %s: %s"), $compose_filename, $!);
    + 
    +@@ git-send-email.perl: sub get_patch_subject {
    + 	do_edit(@files);
    + }
    + 
    ++sub term {
    ++	my $term = eval {
    ++		require Term::ReadLine;
    ++		$ENV{"GIT_SEND_EMAIL_NOTTY"}
    ++			? Term::ReadLine->new('git-send-email', \*STDIN, \*STDOUT)
    ++			: Term::ReadLine->new('git-send-email');
    ++	};
    ++	if ($@) {
    ++		$term = FakeTerm->new("$@: going non-interactive");
    ++	}
    ++	return $term;
    ++}
     +
    - 	save_warning = warn_on_object_refname_ambiguity;
    - 	warn_on_object_refname_ambiguity = 0;
    + sub ask {
    + 	my ($prompt, %arg) = @_;
    + 	my $valid_re = $arg{valid_re};
    +@@ git-send-email.perl: sub ask {
    + 	my $confirm_only = $arg{confirm_only};
    + 	my $resp;
    + 	my $i = 0;
    ++	my $term = term();
    + 	return defined $default ? $default : undef
    + 		unless defined $term->IN and defined fileno($term->IN) and
    + 		       defined $term->OUT and defined fileno($term->OUT);
    +@@ git-send-email.perl: sub extract_valid_address {
    + 	return $address if ($address =~ /^($local_part_regexp)$/);
    + 
    + 	$address =~ s/^\s*<(.*)>\s*$/$1/;
    ++	my $have_email_valid = eval { require Email::Valid; 1 };
    + 	if ($have_email_valid) {
    + 		return scalar Email::Valid->address($address);
    + 	}
    +@@ git-send-email.perl: sub validate_address_list {
    + sub make_message_id {
    + 	my $uniq;
    + 	if (!defined $message_id_stamp) {
    +-		$message_id_stamp = strftime("%Y%m%d%H%M%S.$$", gmtime(time));
    ++		require POSIX;
    ++		$message_id_stamp = POSIX::strftime("%Y%m%d%H%M%S.$$", gmtime(time));
    + 		$message_id_serial = 0;
    + 	}
    + 	$message_id_serial++;
    +@@ git-send-email.perl: sub valid_fqdn {
    + sub maildomain_net {
    + 	my $maildomain;
    + 
    ++	require Net::Domain;
    + 	my $domain = Net::Domain::domainname();
    + 	$maildomain = $domain if valid_fqdn($domain);
    + 
    +@@ git-send-email.perl: sub maildomain_mta {
    + 	my $maildomain;
    + 
    + 	for my $host (qw(mailhost localhost)) {
    ++		require Net::SMTP;
    + 		my $smtp = Net::SMTP->new($host);
    + 		if (defined $smtp) {
    + 			my $domain = $smtp->domain;
    +@@ git-send-email.perl: sub validate_patch {
      
    + 	if ($repo) {
    + 		my $hooks_path = $repo->command_oneline('rev-parse', '--git-path', 'hooks');
    +-		my $validate_hook = catfile($hooks_path,
    ++		require File::Spec;
    ++		my $validate_hook = File::Spec->catfile($hooks_path,
    + 					    'sendemail-validate');
    + 		my $hook_error;
    + 		if (-x $validate_hook) {
    +-			my $target = abs_path($fn);
    ++			require Cwd;
    ++			my $target = Cwd::abs_path($fn);
    + 			# The hook needs a correct cwd and GIT_DIR.
    +-			my $cwd_save = cwd();
    ++			my $cwd_save = Cwd::cwd();
    + 			chdir($repo->wc_path() or $repo->repo_path())
    + 				or die("chdir: $!");
    + 			local $ENV{"GIT_DIR"} = $repo->repo_path();
  3:  302d82365d5 !  11:  5a544a4e11e SANITIZE tests: fix memory leaks in t5701*, add to whitelist
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    SANITIZE tests: fix memory leaks in t5701*, add to whitelist
    +    perl: lazily load some common Git.pm setup code
     
    -    Fix a memory leak in a2ba162cda (object-info: support for retrieving
    -    object info, 2021-04-20) which appears to have been based on a
    -    misunderstanding of how the pkt-line.c API works, there is no need to
    -    strdup() input to, it's just a printf()-like format function.
    +    Instead of unconditionally requiring modules such as File::Spec, let's
    +    only load them when needed. This speeds up code that only needs a
    +    subset of the features Git.pm provides.
     
    -    This fixes a potentially large memory leak, since the number of OID
    -    lines the "object-info" call can be arbitrarily large (or a small one
    -    if the request is small).
    +    This brings a plain invocation of "git send-email" down from 52/37
    +    loaded modules under NO_GETTEXT=[|Y] to 39/18, and it now takes
    +    ~60-~70ms instead of ~80-~90ms. The runtime of t9001-send-email.sh
    +    test is down to ~13s from ~15s.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    - ## protocol-caps.c ##
    -@@ protocol-caps.c: static void send_info(struct repository *r, struct packet_writer *writer,
    + ## perl/Git.pm ##
    +@@ perl/Git.pm: package Git;
    + use strict;
    + use warnings $ENV{GIT_PERL_FATAL_WARNINGS} ? qw(FATAL all) : ();
    + 
    +-use File::Temp ();
    +-use File::Spec ();
    +-
    + BEGIN {
    + 
    + our ($VERSION, @ISA, @EXPORT, @EXPORT_OK);
    +@@ perl/Git.pm: =head1 DESCRIPTION
    + =cut
    + 
    + 
    +-use Carp qw(carp croak); # but croak is bad - throw instead
    ++sub carp { require Carp; goto &Carp::carp }
    ++sub croak { require Carp; goto &Carp::croak }
    + use Git::LoadCPAN::Error qw(:try);
    +-use Cwd qw(abs_path cwd);
    +-use IPC::Open2 qw(open2);
    +-use Fcntl qw(SEEK_SET SEEK_CUR);
    +-use Time::Local qw(timegm);
    + }
    + 
    + 
    +@@ perl/Git.pm: sub repository {
    + 			$dir = undef;
    + 		};
    + 
    ++		require Cwd;
    + 		if ($dir) {
    ++			require File::Spec;
    + 			File::Spec->file_name_is_absolute($dir) or $dir = $opts{Directory} . '/' . $dir;
    +-			$opts{Repository} = abs_path($dir);
    ++			$opts{Repository} = Cwd::abs_path($dir);
    + 
    + 			# If --git-dir went ok, this shouldn't die either.
    + 			my $prefix = $search->command_oneline('rev-parse', '--show-prefix');
    +-			$dir = abs_path($opts{Directory}) . '/';
    ++			$dir = Cwd::abs_path($opts{Directory}) . '/';
    + 			if ($prefix) {
    + 				if (substr($dir, -length($prefix)) ne $prefix) {
    + 					throw Error::Simple("rev-parse confused me - $dir does not have trailing $prefix");
    +@@ perl/Git.pm: sub repository {
    + 				throw Error::Simple("fatal: Not a git repository: $dir");
      			}
    + 
    +-			$opts{Repository} = abs_path($dir);
    ++			$opts{Repository} = Cwd::abs_path($dir);
      		}
      
    --		packet_writer_write(writer, "%s",
    --				    strbuf_detach(&send_buffer, NULL));
    -+		packet_writer_write(writer, "%s", send_buffer.buf);
    -+		strbuf_reset(&send_buffer);
    + 		delete $opts{Directory};
    +@@ perl/Git.pm: sub command_bidi_pipe {
    + 	my $cwd_save = undef;
    + 	if ($self) {
    + 		shift;
    +-		$cwd_save = cwd();
    ++		require Cwd;
    ++		$cwd_save = Cwd::cwd();
    + 		_setup_git_cmd_env($self);
      	}
    -+	strbuf_release(&send_buffer);
    +-	$pid = open2($in, $out, 'git', @_);
    ++	require IPC::Open2;
    ++	$pid = IPC::Open2::open2($in, $out, 'git', @_);
    + 	chdir($cwd_save) if $cwd_save;
    + 	return ($pid, $in, $out, join(' ', @_));
      }
    +@@ perl/Git.pm: sub get_tz_offset {
    + 	my $t = shift || time;
    + 	my @t = localtime($t);
    + 	$t[5] += 1900;
    +-	my $gm = timegm(@t);
    ++	require Time::Local;
    ++	my $gm = Time::Local::timegm(@t);
    + 	my $sign = qw( + + - )[ $gm <=> $t ];
    + 	return sprintf("%s%02d%02d", $sign, (gmtime(abs($t - $gm)))[2,1]);
    + }
    +@@ perl/Git.pm: sub _temp_cache {
    + 		my $n = $name;
    + 		$n =~ s/\W/_/g; # no strange chars
      
    - int cap_object_info(struct repository *r, struct strvec *keys,
    -
    - ## t/t5701-git-serve.sh ##
    -@@ t/t5701-git-serve.sh: test_description='test protocol v2 server commands'
    - GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME=main
    - export GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME
    ++		require File::Temp;
    + 		($$temp_fd, $fname) = File::Temp::tempfile(
    + 			"Git_${n}_XXXXXX", UNLINK => 1, DIR => $tmpdir,
    + 			) or throw Error::Simple("couldn't open new temp file");
    +@@ perl/Git.pm: sub temp_reset {
      
    -+GIT_TEST_SANITIZE_LEAK=true
    - . ./test-lib.sh
    + 	truncate $temp_fd, 0
    + 		or throw Error::Simple("couldn't truncate file");
    +-	sysseek($temp_fd, 0, SEEK_SET) and seek($temp_fd, 0, SEEK_SET)
    ++	sysseek($temp_fd, 0, Fcntl::SEEK_SET()) and seek($temp_fd, 0, Fcntl::SEEK_SET())
    + 		or throw Error::Simple("couldn't seek to beginning of file");
    +-	sysseek($temp_fd, 0, SEEK_CUR) == 0 and tell($temp_fd) == 0
    ++	sysseek($temp_fd, 0, Fcntl::SEEK_CUR()) == 0 and tell($temp_fd) == 0
    + 		or throw Error::Simple("expected file position to be reset");
    + }
      
    - test_expect_success 'test capability advertisement' '
  -:  ----------- >  12:  c95e3a3f0b8 send-email: move trivial config handling to Perl
  -:  ----------- >  13:  17530b2ed2e perl: nano-optimize by replacing Cwd::cwd() with Cwd::getcwd()
  -:  ----------- >  14:  3c7e2e8f0ac pretty.h: update and expand docstring for userformat_find_requirements()
  -:  ----------- >  15:  b2086b51836 log: avoid loading decorations for userformats that don't need it
  -:  ----------- >  16:  542d6abbb4e object.h: expand docstring for lookup_unknown_object()
  -:  ----------- >  17:  7463064b280 object.h: add lookup_object_by_type() function
  -:  ----------- >  18:  88473c8baee load_ref_decorations(): avoid parsing non-tag objects
  -:  ----------- >  19:  6afb265b967 add_ref_decoration(): rename s/type/deco_type/
  -:  ----------- >  20:  0eb6c189a35 ci: use the new GitHub Action to download git-sdk-64-minimal
  -:  ----------- >  21:  abb2b389f76 ci (vs-build): use `cmd` to copy the DLLs, not `powershell`
  -:  ----------- >  22:  e9f79acb28c ci: upgrade to using actions/{up,down}load-artifacts v2
  4:  3e21dd9526a !  23:  3663e5904d7 SANITIZE tests: fix leak in mailmap.c
    @@
      ## Metadata ##
    -Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +Author: Patrick Steinhardt <ps@pks.im>
     
      ## Commit message ##
    -    SANITIZE tests: fix leak in mailmap.c
    +    perf: fix when running with TEST_OUTPUT_DIRECTORY
     
    -    Get closer to being able to run t4203-mailmap.sh by fixing a couple of
    -    memory leak in mailmap.c.
    +    When the TEST_OUTPUT_DIRECTORY is defined, then all test data will be
    +    written in that directory instead of the default directory located in
    +    "t/". While this works as expected for our normal tests, performance
    +    tests fail to locate and aggregate performance data because they don't
    +    know to handle TEST_OUTPUT_DIRECTORY correctly and always look at the
    +    default location.
     
    -    In the free_mailmap_entry() code added in 0925ce4d49 (Add map_user()
    -    and clear_mailmap() to mailmap, 2009-02-08) the intent was clearly to
    -    clear the "me" structure, but while we freed parts of the
    -    mailmap_entry structure, we didn't free the structure itself. The same
    -    goes for the "mailmap_info" structure.
    +    Fix the issue by adding a `--results-dir` parameter to "aggregate.perl"
    +    which identifies the directory where results are and by making the "run"
    +    script awake of the TEST_OUTPUT_DIRECTORY variable.
     
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +    Signed-off-by: Patrick Steinhardt <ps@pks.im>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    - ## mailmap.c ##
    -@@ mailmap.c: static void free_mailmap_info(void *p, const char *s)
    - 		 s, debug_str(mi->name), debug_str(mi->email));
    - 	free(mi->name);
    - 	free(mi->email);
    -+	free(mi);
    + ## t/perf/aggregate.perl ##
    +@@ t/perf/aggregate.perl: sub usage {
    +   Options:
    +     --codespeed          * Format output for Codespeed
    +     --reponame    <str>  * Send given reponame to codespeed
    ++    --results-dir <str>  * Directory where test results are located
    +     --sort-by     <str>  * Sort output (only "regression" criteria is supported)
    +     --subsection  <str>  * Use results from given subsection
    + 
    +@@ t/perf/aggregate.perl: sub sane_backticks {
    + 
    + my (@dirs, %dirnames, %dirabbrevs, %prefixes, @tests,
    +     $codespeed, $sortby, $subsection, $reponame);
    ++my $resultsdir = "test-results";
    + 
    + Getopt::Long::Configure qw/ require_order /;
    + 
    + my $rc = GetOptions("codespeed"     => \$codespeed,
    + 		    "reponame=s"    => \$reponame,
    ++		    "results-dir=s" => \$resultsdir,
    + 		    "sort-by=s"     => \$sortby,
    + 		    "subsection=s"  => \$subsection);
    + usage() unless $rc;
    +@@ t/perf/aggregate.perl: sub sane_backticks {
    + 	@tests = glob "p????-*.sh";
      }
      
    - static void free_mailmap_entry(void *p, const char *s)
    -@@ mailmap.c: static void free_mailmap_entry(void *p, const char *s)
    +-my $resultsdir = "test-results";
    +-
    + if (! $subsection and
    +     exists $ENV{GIT_PERF_SUBSECTION} and
    +     $ENV{GIT_PERF_SUBSECTION} ne "") {
    +
    + ## t/perf/perf-lib.sh ##
    +@@ t/perf/perf-lib.sh: export TEST_DIRECTORY TRASH_DIRECTORY GIT_BUILD_DIR GIT_TEST_CMP
    + MODERN_GIT=$GIT_BUILD_DIR/bin-wrappers/git
    + export MODERN_GIT
      
    - 	me->namemap.strdup_strings = 1;
    - 	string_list_clear_func(&me->namemap, free_mailmap_info);
    -+	free(me);
    +-perf_results_dir=$TEST_OUTPUT_DIRECTORY/test-results
    ++perf_results_dir=$TEST_RESULTS_DIR
    + test -n "$GIT_PERF_SUBSECTION" && perf_results_dir="$perf_results_dir/$GIT_PERF_SUBSECTION"
    + mkdir -p "$perf_results_dir"
    + rm -f "$perf_results_dir"/$(basename "$0" .sh).subtests
    +@@ t/perf/perf-lib.sh: test_size () {
    + # and does it after running everything)
    + test_at_end_hook_ () {
    + 	if test -z "$GIT_PERF_AGGREGATING_LATER"; then
    +-		( cd "$TEST_DIRECTORY"/perf && ./aggregate.perl $(basename "$0") )
    ++		(
    ++			cd "$TEST_DIRECTORY"/perf &&
    ++			./aggregate.perl --results-dir="$TEST_RESULTS_DIR" $(basename "$0")
    ++		)
    + 	fi
      }
      
    - /*
     
    - ## t/t4203-mailmap.sh ##
    -@@ t/t4203-mailmap.sh: test_expect_success 'check-mailmap bogus contact --stdin' '
    - 	test_must_fail git check-mailmap --stdin bogus </dev/null
    - '
    + ## t/perf/run ##
    +@@ t/perf/run: run_subsection () {
    + 
    + 	if test -z "$GIT_PERF_SEND_TO_CODESPEED"
    + 	then
    +-		./aggregate.perl $codespeed_opt "$@"
    ++		./aggregate.perl --results-dir="$TEST_RESULTS_DIR" $codespeed_opt "$@"
    + 	else
    +-		json_res_file="test-results/$GIT_PERF_SUBSECTION/aggregate.json"
    +-		./aggregate.perl --codespeed "$@" | tee "$json_res_file"
    ++		json_res_file=""$TEST_RESULTS_DIR"/$GIT_PERF_SUBSECTION/aggregate.json"
    ++		./aggregate.perl --results-dir="$TEST_RESULTS_DIR" --codespeed "$@" | tee "$json_res_file"
    + 		send_data_url="$GIT_PERF_SEND_TO_CODESPEED/result/add/json/"
    + 		curl -v --request POST --data-urlencode "json=$(cat "$json_res_file")" "$send_data_url"
    + 	fi
    +@@ t/perf/run: get_var_from_env_or_config "GIT_PERF_SEND_TO_CODESPEED" "perf" "sendToCodespeed"
    + cd "$(dirname $0)"
    + . ../../GIT-BUILD-OPTIONS
      
    -+if test_have_prereq SANITIZE_LEAK
    +-mkdir -p test-results
    +-get_subsections "perf" >test-results/run_subsections.names
    ++if test -n "$TEST_OUTPUT_DIRECTORY"
     +then
    -+	skip_all='skipping the rest of mailmap tests under SANITIZE_LEAK'
    -+	test_done
    ++	TEST_RESULTS_DIR="$TEST_OUTPUT_DIRECTORY/test-results"
    ++else
    ++	TEST_RESULTS_DIR=test-results
     +fi
     +
    - test_expect_success 'No mailmap' '
    - 	cat >expect <<-EOF &&
    - 	$GIT_AUTHOR_NAME (1):
    ++mkdir -p "$TEST_RESULTS_DIR"
    ++get_subsections "perf" >"$TEST_RESULTS_DIR"/run_subsections.names
    + 
    +-if test $(wc -l <test-results/run_subsections.names) -eq 0
    ++if test $(wc -l <"$TEST_RESULTS_DIR"/run_subsections.names) -eq 0
    + then
    + 	if test -n "$GIT_PERF_SUBSECTION"
    + 	then
    +@@ t/perf/run: then
    + 	)
    + elif test -n "$GIT_PERF_SUBSECTION"
    + then
    +-	egrep "^$GIT_PERF_SUBSECTION\$" test-results/run_subsections.names >/dev/null ||
    ++	egrep "^$GIT_PERF_SUBSECTION\$" "$TEST_RESULTS_DIR"/run_subsections.names >/dev/null ||
    + 		die "subsection '$GIT_PERF_SUBSECTION' not found in '$GIT_PERF_CONFIG_FILE'"
    + 
    +-	egrep "^$GIT_PERF_SUBSECTION\$" test-results/run_subsections.names | while read -r subsec
    ++	egrep "^$GIT_PERF_SUBSECTION\$" "$TEST_RESULTS_DIR"/run_subsections.names | while read -r subsec
    + 	do
    + 		(
    + 			GIT_PERF_SUBSECTION="$subsec"
    +@@ t/perf/run: else
    + 			echo "======== Run for subsection '$GIT_PERF_SUBSECTION' ========"
    + 			run_subsection "$@"
    + 		)
    +-	done <test-results/run_subsections.names
    ++	done <"$TEST_RESULTS_DIR"/run_subsections.names
    + fi
  -:  ----------- >  24:  d681d0dc3a7 ci (windows): transfer also the Git-tracked files to the test jobs
  -:  ----------- >  25:  43488240593 artifacts-tar: respect NO_GETTEXT
  -:  ----------- >  26:  9ab0b661291 ci (vs-build): build with NO_GETTEXT
  -:  ----------- >  27:  0dc787a9f23 ci: accelerate the checkout
  -:  ----------- >  28:  e04170697a2 docs: .gitignore parsing is to the top of the repo
  -:  ----------- >  29:  351bca2d1f8 imap-send.c: use less verbose strbuf_fread() idiom
 27:  2d4c3d0d463 !  30:  cf2dc1c238c upload-pack.c: convert to new serve.c "startup" config cb
    @@
      ## Metadata ##
    -Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +Author: Eric Wong <e@80x24.org>
     
      ## Commit message ##
    -    upload-pack.c: convert to new serve.c "startup" config cb
    +    speed up alt_odb_usable() with many alternates
     
    -    Convert the config reading code in upload-pack.c to use the new
    -    "startup_config" callback when we're using the v2 protocol, and
    -    lightly fake up the same when we're using v0 and v1.
    +    With many alternates, the duplicate check in alt_odb_usable()
    +    wastes many cycles doing repeated fspathcmp() on every existing
    +    alternate.  Use a khash to speed up lookups by odb->path.
     
    -    Before the series that fixed 08450ef7918 (upload-pack: clear
    -    filter_options for each v2 fetch command, 2020-05-08) landed, most of
    -    what's now "struct upload_pack_data" used to be static variables at
    -    the top of this file.
    +    Since the kh_put_* API uses the supplied key without
    +    duplicating it, we also take advantage of it to replace both
    +    xstrdup() and strbuf_release() in link_alt_odb_entry() with
    +    strbuf_detach() to avoid the allocation and copy.
     
    -    This moves some of them back. See f203a88cf14 (upload-pack: move
    -    keepalive to upload_pack_data, 2020-06-04), f1514c6aad0 (upload-pack:
    -    move allow_unadvertised_object_request to upload_pack_data,
    -    2020-06-11) etc.
    +    In a test repository with 50K alternates and each of those 50K
    +    alternates having one alternate each (for a total of 100K total
    +    alternates); this speeds up lookup of a non-existent blob from
    +    over 16 minutes to roughly 2.7 seconds on my busy workstation.
     
    -    I think this makes it easier to understand the this code, as we're now
    -    clearly separating data and config that changes on a
    -    request-to-request basis (see 08450ef7918), and the sort of config
    -    that serve.c's "startup_config" is aimed at.
    +    Note: all underlying git object directories were small and
    +    unpacked with only loose objects and no packs.  Having to load
    +    packs increases times significantly.
     
    -    Thus it's clear that the "allow_uor" passed to functions like
    -    "is_our_ref()" is constant after startup (usually it'll never change
    -    for a given server's configuration, or change once).
    +    Signed-off-by: Eric Wong <e@80x24.org>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    -    This requires a very light compatibility layer with the serve.c
    -    callback mechanism in the form of "upload_pack" for the v0 and v1
    -    protocols.
    -
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    -
    - ## serve.c ##
    -@@ serve.c: static struct protocol_capability capabilities[] = {
    - 	},
    - 	{
    - 		.name = "fetch",
    -+		.startup_config = serve_upload_pack_startup_config,
    - 		.advertise = upload_pack_advertise,
    - 		.command = upload_pack_v2,
    - 	},
    -
    - ## upload-pack.c ##
    -@@ upload-pack.c: enum allow_uor {
    - 	ALLOW_ANY_SHA1 = 0x07
    - };
    - 
    -+/*
    -+ * "Global" configuration that won't be affected by the type of
    -+ * request we're doing, or by other request data in "struct
    -+ * upload_pack_data" below.
    -+ */
    -+static int v1_have_startup_config;
    -+static int config_keepalive_secs = 5;
    -+static enum allow_uor config_allow_uor;
    -+static unsigned config_advertise_sid;
    -+static const char *config_pack_objects_hook;
    -+static unsigned config_v2_allow_ref_in_want;
    -+static unsigned config_v2_allow_sideband_all;
    -+
    - /*
    -  * Please annotate, and if possible group together, fields used only
    -  * for protocol v0 or only for protocol v2.
    -@@ upload-pack.c: struct upload_pack_data {
    - 	timestamp_t deepen_since;
    - 	int deepen_rev_list;
    - 	int deepen_relative;
    --	int keepalive;
    - 	int shallow_nr;
    - 	timestamp_t oldest_have;
    - 
    -@@ upload-pack.c: struct upload_pack_data {
    - 	int use_sideband;
    - 
    - 	struct string_list uri_protocols;
    --	enum allow_uor allow_uor;
    - 
    - 	struct list_objects_filter_options filter_options;
    - 	struct string_list allowed_filters;
    - 
    - 	struct packet_writer writer;
    - 
    --	const char *pack_objects_hook;
    --
    - 	unsigned stateless_rpc : 1;				/* v0 only */
    - 	unsigned no_done : 1;					/* v0 only */
    - 	unsigned daemon_mode : 1;				/* v0 only */
    -@@ upload-pack.c: struct upload_pack_data {
    - 	unsigned long tree_filter_max_depth;
    - 
    - 	unsigned done : 1;					/* v2 only */
    --	unsigned allow_ref_in_want : 1;				/* v2 only */
    --	unsigned allow_sideband_all : 1;			/* v2 only */
    --	unsigned advertise_sid : 1;
    - };
    - 
    - static void upload_pack_data_init(struct upload_pack_data *data)
    -@@ upload-pack.c: static void upload_pack_data_init(struct upload_pack_data *data)
    - 	data->allow_filter_fallback = 1;
    - 	data->tree_filter_max_depth = ULONG_MAX;
    - 	packet_writer_init(&data->writer, 1);
    --
    --	data->keepalive = 5;
    --	data->advertise_sid = 0;
    + ## dir.c ##
    +@@ dir.c: int fspathcmp(const char *a, const char *b)
    + 	return ignore_case ? strcasecmp(a, b) : strcmp(a, b);
      }
      
    - static void upload_pack_data_clear(struct upload_pack_data *data)
    -@@ upload-pack.c: static void upload_pack_data_clear(struct upload_pack_data *data)
    - 	object_array_clear(&data->extra_edge_obj);
    - 	list_objects_filter_release(&data->filter_options);
    - 	string_list_clear(&data->allowed_filters, 0);
    --
    --	free((char *)data->pack_objects_hook);
    ++int fspatheq(const char *a, const char *b)
    ++{
    ++	return !fspathcmp(a, b);
    ++}
    ++
    + int fspathncmp(const char *a, const char *b, size_t count)
    + {
    + 	return ignore_case ? strncasecmp(a, b, count) : strncmp(a, b, count);
      }
      
    - static void reset_timeout(unsigned int timeout)
    -@@ upload-pack.c: static void create_pack_file(struct upload_pack_data *pack_data,
    - 	int i;
    - 	FILE *pipe_fd;
    - 
    --	if (!pack_data->pack_objects_hook)
    -+	if (!config_pack_objects_hook)
    - 		pack_objects.git_cmd = 1;
    - 	else {
    --		strvec_push(&pack_objects.args, pack_data->pack_objects_hook);
    -+		strvec_push(&pack_objects.args, config_pack_objects_hook);
    - 		strvec_push(&pack_objects.args, "git");
    - 		pack_objects.use_shell = 1;
    - 	}
    -@@ upload-pack.c: static void create_pack_file(struct upload_pack_data *pack_data,
    - 		if (!pollsize)
    - 			break;
    - 
    --		polltimeout = pack_data->keepalive < 0
    -+		polltimeout = config_keepalive_secs < 0
    - 			? -1
    --			: 1000 * pack_data->keepalive;
    -+			: 1000 * config_keepalive_secs;
    - 
    - 		ret = poll(pfd, pollsize, polltimeout);
    ++unsigned int fspathhash(const char *str)
    ++{
    ++	return ignore_case ? strihash(str) : strhash(str);
    ++}
    ++
    + int git_fnmatch(const struct pathspec_item *item,
    + 		const char *pattern, const char *string,
    + 		int prefix)
    +
    + ## dir.h ##
    +@@ dir.h: int remove_dir_recursively(struct strbuf *path, int flag);
    + int remove_path(const char *path);
      
    -@@ upload-pack.c: static int get_common_commits(struct upload_pack_data *data,
    - 	}
    - }
    + int fspathcmp(const char *a, const char *b);
    ++int fspatheq(const char *a, const char *b);
    + int fspathncmp(const char *a, const char *b, size_t count);
    ++unsigned int fspathhash(const char *str);
      
    --static int is_our_ref(struct object *o, enum allow_uor allow_uor)
    -+static int is_our_ref(struct object *o)
    - {
    --	int allow_hidden_ref = (allow_uor &
    -+	int allow_hidden_ref = (config_allow_uor &
    - 				(ALLOW_TIP_SHA1 | ALLOW_REACHABLE_SHA1));
    - 	return o->flags & ((allow_hidden_ref ? HIDDEN_REF : 0) | OUR_REF);
    - }
    -@@ upload-pack.c: static int is_our_ref(struct object *o, enum allow_uor allow_uor)
    + /*
    +  * The prefix part of pattern must not contains wildcards.
    +
    + ## object-file.c ##
    +@@ object-file.c: const char *loose_object_path(struct repository *r, struct strbuf *buf,
       */
    - static int do_reachable_revlist(struct child_process *cmd,
    - 				struct object_array *src,
    --				struct object_array *reachable,
    --				enum allow_uor allow_uor)
    -+				struct object_array *reachable)
    + static int alt_odb_usable(struct raw_object_store *o,
    + 			  struct strbuf *path,
    +-			  const char *normalized_objdir)
    ++			  const char *normalized_objdir, khiter_t *pos)
      {
    - 	static const char *argv[] = {
    - 		"rev-list", "--stdin", NULL,
    -@@ upload-pack.c: static int do_reachable_revlist(struct child_process *cmd,
    - 			continue;
    - 		if (reachable && o->type == OBJ_COMMIT)
    - 			o->flags &= ~TMP_MARK;
    --		if (!is_our_ref(o, allow_uor))
    -+		if (!is_our_ref(o))
    - 			continue;
    - 		if (fprintf(cmd_in, "^%s\n", oid_to_hex(&o->oid)) < 0)
    - 			goto error;
    +-	struct object_directory *odb;
    ++	int r;
    + 
    + 	/* Detect cases where alternate disappeared */
    + 	if (!is_directory(path->buf)) {
    +@@ object-file.c: static int alt_odb_usable(struct raw_object_store *o,
    + 	 * Prevent the common mistake of listing the same
    + 	 * thing twice, or object directory itself.
    + 	 */
    +-	for (odb = o->odb; odb; odb = odb->next) {
    +-		if (!fspathcmp(path->buf, odb->path))
    +-			return 0;
    ++	if (!o->odb_by_path) {
    ++		khiter_t p;
    ++
    ++		o->odb_by_path = kh_init_odb_path_map();
    ++		assert(!o->odb->next);
    ++		p = kh_put_odb_path_map(o->odb_by_path, o->odb->path, &r);
    ++		assert(r == 1); /* never used */
    ++		kh_value(o->odb_by_path, p) = o->odb;
      	}
    - 	for (i = 0; i < src->nr; i++) {
    - 		o = src->objects[i].item;
    --		if (is_our_ref(o, allow_uor)) {
    -+		if (is_our_ref(o)) {
    - 			if (reachable)
    - 				add_object_array(o, NULL, reachable);
    - 			continue;
    -@@ upload-pack.c: static int get_reachable_list(struct upload_pack_data *data,
    - 	char namebuf[GIT_MAX_HEXSZ + 2]; /* ^ + hash + LF */
    - 	const unsigned hexsz = the_hash_algo->hexsz;
    - 
    --	if (do_reachable_revlist(&cmd, &data->shallows, reachable,
    --				 data->allow_uor) < 0)
    -+	if (do_reachable_revlist(&cmd, &data->shallows, reachable) < 0)
    - 		return -1;
    - 
    - 	while ((i = read_in_full(cmd.out, namebuf, hexsz + 1)) == hexsz + 1) {
    -@@ upload-pack.c: static int get_reachable_list(struct upload_pack_data *data,
    - 	return 0;
    +-	if (!fspathcmp(path->buf, normalized_objdir))
    ++	if (fspatheq(path->buf, normalized_objdir))
    + 		return 0;
    +-
    +-	return 1;
    ++	*pos = kh_put_odb_path_map(o->odb_by_path, path->buf, &r);
    ++	/* r: 0 = exists, 1 = never used, 2 = deleted */
    ++	return r == 0 ? 0 : 1;
      }
      
    --static int has_unreachable(struct object_array *src, enum allow_uor allow_uor)
    -+static int has_unreachable(struct object_array *src)
    + /*
    +@@ object-file.c: static int link_alt_odb_entry(struct repository *r, const char *entry,
      {
    - 	struct child_process cmd = CHILD_PROCESS_INIT;
    - 	char buf[1];
    - 	int i;
    + 	struct object_directory *ent;
    + 	struct strbuf pathbuf = STRBUF_INIT;
    ++	khiter_t pos;
    + 
    + 	if (!is_absolute_path(entry) && relative_base) {
    + 		strbuf_realpath(&pathbuf, relative_base, 1);
    +@@ object-file.c: static int link_alt_odb_entry(struct repository *r, const char *entry,
    + 	while (pathbuf.len && pathbuf.buf[pathbuf.len - 1] == '/')
    + 		strbuf_setlen(&pathbuf, pathbuf.len - 1);
    + 
    +-	if (!alt_odb_usable(r->objects, &pathbuf, normalized_objdir)) {
    ++	if (!alt_odb_usable(r->objects, &pathbuf, normalized_objdir, &pos)) {
    + 		strbuf_release(&pathbuf);
    + 		return -1;
    + 	}
      
    --	if (do_reachable_revlist(&cmd, src, NULL, allow_uor) < 0)
    -+	if (do_reachable_revlist(&cmd, src, NULL) < 0)
    - 		return 1;
    + 	CALLOC_ARRAY(ent, 1);
    +-	ent->path = xstrdup(pathbuf.buf);
    ++	/* pathbuf.buf is already in r->objects->odb_by_path */
    ++	ent->path = strbuf_detach(&pathbuf, NULL);
      
    - 	/*
    -@@ upload-pack.c: static void check_non_tip(struct upload_pack_data *data)
    - 	 * uploadpack.allowReachableSHA1InWant,
    - 	 * non-tip requests can never happen.
    - 	 */
    --	if (!data->stateless_rpc && !(data->allow_uor & ALLOW_REACHABLE_SHA1))
    -+	if (!data->stateless_rpc && !(config_allow_uor & ALLOW_REACHABLE_SHA1))
    - 		goto error;
    --	if (!has_unreachable(&data->want_obj, data->allow_uor))
    -+	if (!has_unreachable(&data->want_obj))
    - 		/* All the non-tip ones are ancestors of what we advertised */
    - 		return;
    + 	/* add the alternate entry */
    + 	*r->objects->odb_tail = ent;
    + 	r->objects->odb_tail = &(ent->next);
    + 	ent->next = NULL;
    ++	assert(r->objects->odb_by_path);
    ++	kh_value(r->objects->odb_by_path, pos) = ent;
      
    -@@ upload-pack.c: static void check_non_tip(struct upload_pack_data *data)
    - 	/* Pick one of them (we know there at least is one) */
    - 	for (i = 0; i < data->want_obj.nr; i++) {
    - 		struct object *o = data->want_obj.objects[i].item;
    --		if (!is_our_ref(o, data->allow_uor)) {
    -+		if (!is_our_ref(o)) {
    - 			packet_writer_error(&data->writer,
    - 					    "upload-pack: not our ref %s",
    - 					    oid_to_hex(&o->oid));
    -@@ upload-pack.c: static void receive_needs(struct upload_pack_data *data,
    - 		}
    - 		if (!(o->flags & WANTED)) {
    - 			o->flags |= WANTED;
    --			if (!((data->allow_uor & ALLOW_ANY_SHA1) == ALLOW_ANY_SHA1
    --			      || is_our_ref(o, data->allow_uor)))
    -+			if (!((config_allow_uor & ALLOW_ANY_SHA1) == ALLOW_ANY_SHA1
    -+			      || is_our_ref(o)))
    - 				has_non_tip = 1;
    - 			add_object_array(o, NULL, &data->want_obj);
    - 		}
    -@@ upload-pack.c: static void format_symref_info(struct strbuf *buf, struct string_list *symref)
    - }
    + 	/* recursively add alternates */
    +-	read_info_alternates(r, pathbuf.buf, depth + 1);
    ++	read_info_alternates(r, ent->path, depth + 1);
      
    - static void format_session_id(struct strbuf *buf, struct upload_pack_data *d) {
    --	if (d->advertise_sid)
    -+	if (config_advertise_sid)
    - 		strbuf_addf(buf, " session-id=%s", trace2_session_id());
    - }
    - 
    -@@ upload-pack.c: static int send_ref(const char *refname, const struct object_id *oid,
    - 		packet_write_fmt(1, "%s %s%c%s%s%s%s%s%s%s object-format=%s agent=%s\n",
    - 			     oid_to_hex(oid), refname_nons,
    - 			     0, capabilities,
    --			     (data->allow_uor & ALLOW_TIP_SHA1) ?
    -+			     (config_allow_uor & ALLOW_TIP_SHA1) ?
    - 				     " allow-tip-sha1-in-want" : "",
    --			     (data->allow_uor & ALLOW_REACHABLE_SHA1) ?
    -+			     (config_allow_uor & ALLOW_REACHABLE_SHA1) ?
    - 				     " allow-reachable-sha1-in-want" : "",
    - 			     data->no_done ? " no-done" : "",
    - 			     symref_info.buf,
    -@@ upload-pack.c: static int parse_object_filter_config(const char *var, const char *value,
    +-	strbuf_release(&pathbuf);
      	return 0;
      }
      
    --static int upload_pack_config(const char *var, const char *value, void *cb_data)
    -+static int upload_pack_startup_config(const char *var, const char *value,
    -+				      void *cb_data)
    - {
    --	struct upload_pack_data *data = cb_data;
    --
    - 	if (!strcmp("uploadpack.allowtipsha1inwant", var)) {
    - 		if (git_config_bool(var, value))
    --			data->allow_uor |= ALLOW_TIP_SHA1;
    -+			config_allow_uor |= ALLOW_TIP_SHA1;
    - 		else
    --			data->allow_uor &= ~ALLOW_TIP_SHA1;
    -+			config_allow_uor &= ~ALLOW_TIP_SHA1;
    - 	} else if (!strcmp("uploadpack.allowreachablesha1inwant", var)) {
    - 		if (git_config_bool(var, value))
    --			data->allow_uor |= ALLOW_REACHABLE_SHA1;
    -+			config_allow_uor |= ALLOW_REACHABLE_SHA1;
    - 		else
    --			data->allow_uor &= ~ALLOW_REACHABLE_SHA1;
    -+			config_allow_uor &= ~ALLOW_REACHABLE_SHA1;
    - 	} else if (!strcmp("uploadpack.allowanysha1inwant", var)) {
    - 		if (git_config_bool(var, value))
    --			data->allow_uor |= ALLOW_ANY_SHA1;
    -+			config_allow_uor |= ALLOW_ANY_SHA1;
    - 		else
    --			data->allow_uor &= ~ALLOW_ANY_SHA1;
    -+			config_allow_uor &= ~ALLOW_ANY_SHA1;
    - 	} else if (!strcmp("uploadpack.keepalive", var)) {
    --		data->keepalive = git_config_int(var, value);
    --		if (!data->keepalive)
    --			data->keepalive = -1;
    --	} else if (!strcmp("uploadpack.allowfilter", var)) {
    --		data->allow_filter = git_config_bool(var, value);
    --	} else if (!strcmp("uploadpack.allowrefinwant", var)) {
    --		data->allow_ref_in_want = git_config_bool(var, value);
    --	} else if (!strcmp("uploadpack.allowsidebandall", var)) {
    --		data->allow_sideband_all = git_config_bool(var, value);
    -+		config_keepalive_secs = git_config_int(var, value);
    -+		if (!config_keepalive_secs)
    -+			config_keepalive_secs = -1;
    - 	} else if (!strcmp("core.precomposeunicode", var)) {
    - 		precomposed_unicode = git_config_bool(var, value);
    - 	} else if (!strcmp("transfer.advertisesid", var)) {
    --		data->advertise_sid = git_config_bool(var, value);
    -+		config_advertise_sid = git_config_bool(var, value);
    - 	}
    +
    + ## object-store.h ##
    +@@
    + #include "oid-array.h"
    + #include "strbuf.h"
    + #include "thread-utils.h"
    ++#include "khash.h"
    ++#include "dir.h"
    + 
    + struct object_directory {
    + 	struct object_directory *next;
    +@@ object-store.h: struct object_directory {
    + 	char *path;
    + };
      
    - 	if (current_config_scope() != CONFIG_SCOPE_LOCAL &&
    - 	    current_config_scope() != CONFIG_SCOPE_WORKTREE) {
    - 		if (!strcmp("uploadpack.packobjectshook", var))
    --			return git_config_string(&data->pack_objects_hook, var, value);
    -+			return git_config_string(&config_pack_objects_hook, var, value);
    - 	}
    -+	return 0;
    -+}
    -+
    -+static int upload_pack_startup_config_v2_only(const char *var,
    -+					      const char *value, void *cb_data)
    -+{
    -+	if (!strcmp("uploadpack.allowrefinwant", var))
    -+		config_v2_allow_ref_in_want = git_config_bool(var, value);
    -+	else if (!strcmp("uploadpack.allowsidebandall", var))
    -+		config_v2_allow_sideband_all = git_config_bool(var, value);
    -+	return 0;
    -+}
    ++KHASH_INIT(odb_path_map, const char * /* key: odb_path */,
    ++	struct object_directory *, 1, fspathhash, fspatheq);
     +
    -+int serve_upload_pack_startup_config(const char *var, const char *value, void *data)
    -+{
    -+	upload_pack_startup_config(var, value, data);
    -+	upload_pack_startup_config_v2_only(var, value, data);
    -+	return 0;
    -+}
    -+
    -+static int upload_pack_config(const char *var, const char *value,
    -+			      void *cb_data)
    -+{
    -+	struct upload_pack_data *data = cb_data;
    + void prepare_alt_odb(struct repository *r);
    + char *compute_alternate_path(const char *path, struct strbuf *err);
    + typedef int alt_odb_fn(struct object_directory *, void *);
    +@@ object-store.h: struct raw_object_store {
    + 	 */
    + 	struct object_directory *odb;
    + 	struct object_directory **odb_tail;
    ++	kh_odb_path_map_t *odb_by_path;
     +
    -+	if (!strcmp("uploadpack.allowfilter", var))
    -+		data->allow_filter = git_config_bool(var, value);
    - 
    - 	if (parse_object_filter_config(var, value, data) < 0)
    - 		return -1;
    -@@ upload-pack.c: void upload_pack(const int advertise_refs, const int stateless_rpc,
    - 
    - 	upload_pack_data_init(&data);
    - 
    -+	if (!v1_have_startup_config++)
    -+		git_config(upload_pack_startup_config, NULL);
    - 	git_config(upload_pack_config, &data);
    + 	int loaded_alternates;
      
    - 	data.stateless_rpc = stateless_rpc;
    -@@ upload-pack.c: static void process_args(struct packet_reader *request,
    - 		/* process want */
    - 		if (parse_want(&data->writer, arg, &data->want_obj))
    - 			continue;
    --		if (data->allow_ref_in_want &&
    -+		if (config_v2_allow_ref_in_want &&
    - 		    parse_want_ref(&data->writer, arg, &data->wanted_refs,
    - 				   &data->want_obj))
    - 			continue;
    -@@ upload-pack.c: static void process_args(struct packet_reader *request,
    - 		}
    - 
    - 		if ((git_env_bool("GIT_TEST_SIDEBAND_ALL", 0) ||
    --		     data->allow_sideband_all) &&
    -+		     config_v2_allow_sideband_all) &&
    - 		    !strcmp(arg, "sideband-all")) {
    - 			data->writer.use_sideband = 1;
    - 			continue;
    + 	/*
     
    - ## upload-pack.h ##
    -@@ upload-pack.h: int upload_pack_v2(struct repository *r, struct strvec *keys,
    - struct strbuf;
    - int upload_pack_advertise(struct repository *r,
    - 			  struct strbuf *value);
    -+int serve_upload_pack_startup_config(const char *var, const char *value,
    -+				     void *data);
    + ## object.c ##
    +@@ object.c: static void free_object_directories(struct raw_object_store *o)
    + 		free_object_directory(o->odb);
    + 		o->odb = next;
    + 	}
    ++	kh_destroy_odb_path_map(o->odb_by_path);
    ++	o->odb_by_path = NULL;
    + }
      
    - #endif /* UPLOAD_PACK_H */
    + void raw_object_store_clear(struct raw_object_store *o)
  -:  ----------- >  31:  407532f82d3 avoid strlen via strbuf_addstr in link_alt_odb_entry
  -:  ----------- >  32:  33f379eee63 make object_directory.loose_objects_subdir_seen a bitmap
  -:  ----------- >  33:  90e07f0a342 oidcpy_with_padding: constify `src' arg
 14:  a1e00e20c95 !  34:  92d8ed8ac10 bundle: allow specifying ref names in --stdin input
    @@
      ## Metadata ##
    -Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +Author: Eric Wong <e@80x24.org>
     
      ## Commit message ##
    -    bundle: allow specifying ref names in --stdin input
    +    oidtree: a crit-bit tree for odb_loose_cache
     
    -    The bundle archive format inherently requires specifying reference
    -    names along with the revision tips contained therein, but it doesn't
    -    inherently require that reference names existed in that state in a
    -    repository.
    +    This saves 8K per `struct object_directory', meaning it saves
    +    around 800MB in my case involving 100K alternates (half or more
    +    of those alternates are unlikely to hold loose objects).
     
    -    The current behavior around dwim_ref() is merely a convenience so that
    -    a revision like "master" "master~10..master" will be listed in the
    -    bundle as the fully-qualified. "refs/heads/master". Let's also support
    -    manually specifying reference names along with revisions, so that
    -    revisions like "$(git rev-parse HEAD)" or "master~10..master~5" can be
    -    packaged in a bundle.
    +    This is implemented in two parts: a generic, allocation-free
    +    `cbtree' and the `oidtree' wrapper on top of it.  The latter
    +    provides allocation using alloc_state as a memory pool to
    +    improve locality and reduce free(3) overhead.
     
    -    To do so we use the new handle_stdin_line() callback mechanism in
    -    revision.c to intercept the --stdin input, and effectively extend
    -    handle_revision_arg() to not only understand input like:
    +    Unlike oid-array, the crit-bit tree does not require sorting.
    +    Performance is bound by the key length, for oidtree that is
    +    fixed at sizeof(struct object_id).  There's no need to have
    +    256 oidtrees to mitigate the O(n log n) overhead like we did
    +    with oid-array.
     
    -        <revision>
    +    Being a prefix trie, it is natively suited for expanding short
    +    object IDs via prefix-limited iteration in
    +    `find_short_object_filename'.
     
    -    But also:
    +    On my busy workstation, p4205 performance seems to be roughly
    +    unchanged (+/-8%).  Startup with 100K total alternates with no
    +    loose objects seems around 10-20% faster on a hot cache.
    +    (800MB in memory savings means more memory for the kernel FS
    +    cache).
     
    -        <revision><TAB><refname>
    +    The generic cbtree implementation does impose some extra
    +    overhead for oidtree in that it uses memcmp(3) on
    +    "struct object_id" so it wastes cycles comparing 12 extra bytes
    +    on SHA-1 repositories.  I've not yet explored reducing this
    +    overhead, but I expect there are many places in our code base
    +    where we'd want to investigate this.
     
    -    E.g. this now works:
    +    More information on crit-bit trees: https://cr.yp.to/critbit.html
     
    -        printf "master~10..master~5\trefs/heads/my-recent-master-pushes\n" |
    -        git bundle create master-pushes.bundle --stdin
    +    Signed-off-by: Eric Wong <e@80x24.org>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    -    Before this change "bundle create" would have died with "Refusing to
    -    create empty bundle" if it had gotten that far (but would earlier die
    -    on "bad revision" if that was supplied on stdin).
    + ## Makefile ##
    +@@ Makefile: TEST_BUILTINS_OBJS += test-mergesort.o
    + TEST_BUILTINS_OBJS += test-mktemp.o
    + TEST_BUILTINS_OBJS += test-oid-array.o
    + TEST_BUILTINS_OBJS += test-oidmap.o
    ++TEST_BUILTINS_OBJS += test-oidtree.o
    + TEST_BUILTINS_OBJS += test-online-cpus.o
    + TEST_BUILTINS_OBJS += test-parse-options.o
    + TEST_BUILTINS_OBJS += test-parse-pathspec-file.o
    +@@ Makefile: LIB_OBJS += branch.o
    + LIB_OBJS += bulk-checkin.o
    + LIB_OBJS += bundle.o
    + LIB_OBJS += cache-tree.o
    ++LIB_OBJS += cbtree.o
    + LIB_OBJS += chdir-notify.o
    + LIB_OBJS += checkout.o
    + LIB_OBJS += chunk-format.o
    +@@ Makefile: LIB_OBJS += object.o
    + LIB_OBJS += oid-array.o
    + LIB_OBJS += oidmap.o
    + LIB_OBJS += oidset.o
    ++LIB_OBJS += oidtree.o
    + LIB_OBJS += pack-bitmap-write.o
    + LIB_OBJS += pack-bitmap.o
    + LIB_OBJS += pack-check.o
     
    -    This doesn't make anything possible that wasn't possible before this
    -    change, merely a lot more convenient.
    -
    -    Before you could manually search/replace/edit the contents of the
    -    bundle header if you wanted to rename/insert/edit/delete
    -    references. In other cases such as the "master~10..master~5" case, you
    -    would have had to create a temporary branch "tmp" whose tip was at
    -    "master~5", and then refer to the revision range as "tmp~5..tmp".
    -
    -    Implementation notes:
    -
    -    I think the whole use of "refname_to_pending" here is rather nasty,
    -    but could not think of a better alternative to track a
    -    "rev_info->pending" from the outside.
    -
    -    The semantics are rather straightforward though: As we parse lines on
    -    stdin we have the revision.c API parse the revision part, and it
    -    pushes a revision (or none, or two) to "rev_info->pending".
    -
    -    Our "handle_stdin_line" callback then runs, sees how much (if
    -    anything) got added to "rev_info->pending". It then extends a
    -    string-list correspondingly such that we end up with a 1=1 positional
    -    mapping between the "rev_info->pending" and our own
    -    "refname_to_pending" string-list.
    -
    -    It results in some complexity in the stdin handler, but means that by
    -    the time we get to write_bundle_refs() we merely need to check if
    -    there's something in the equivalent of refname_to_pending[i] for the
    -    revs_pending[i] we're looking at. If there is we'll use that name,
    -    otherwise fall back on the existing dwim_ref() behavior. See the
    -    commentary in write_bundle_after_stdin_line_again() for how we satisfy
    -    that criteria.
    -
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    -
    - ## Documentation/git-bundle.txt ##
    -@@ Documentation/git-bundle.txt: $ git bundle create recent-updates.bundle master~10..master next~5..next
    - ----------------
    - 
    - A revision name or a range whose right-hand-side cannot be resolved to
    --a reference is not accepted:
    -+a reference is not accepted unless an explicit reference name is
    -+provided for it:
    - 
    - ----------------
    - $ git bundle create HEAD.bundle $(git rev-parse HEAD)
    -@@ Documentation/git-bundle.txt: $ git bundle create master-yesterday.bundle master~10..master~5
    - fatal: Refusing to create empty bundle.
    - ----------------
    - 
    -+To manally specify a reference name for the bundled revision(s) you'll
    -+need to provide them with the `<git-rev-list-args>` input on
    -+`--stdin`. This is supported by extending the linkgit:git-rev-list[1]
    -+syntax with a small bundle-specific extension: Provide the rev-list
    -+argument that the "simple" mode accepts, followed by a tab character
    -+and a (fully-qualified) reference name.
    -+
    -+This allows for crafting bundles from arbitrary revision names or
    -+ranges without having to alter the local set of references
    -+accordingly:
    -+
    -+----------------
    -+$ printf "e83c5163316f89bfbde7\trefs/heads/first-git-dot-git-commit\n" |
    -+  git bundle create initial.bundle --stdin
    -+$ printf "master~10..master~5\trefs/tags/some-master-pushes\n" |
    -+  git bundle create master-pushes.bundle --stdin
    -+----------------
    -+
    -+It is also possible to mix and match the two forms, i.e. to have some
    -+lines be tab-separated, and have others implicitly parse reference
    -+from the provided revision:
    -+1;5A
    -+----------------
    -+$ (echo next ; printf "master~10..master~5\trefs/tags/some-master-pushes\n" |
    -+  git bundle create next-and-some-master-pushes.bundle --stdin
    -+----------------
    -+
    -+For convenience we'll accept the output emitted by
    -+linkgit:git-for-each-ref[1], i.e. the `%(objectname) SPC %(objecttype)
    -+TAB %(refname)` format. The `SPC %(objecttype)` part of it is accepted
    -+but otherwise ignored (we don't validate the supposed type). This is
    -+for the convenience of piping linkgit:git-for-each-ref[1] output into
    -+`git bundle create`:
    -+
    -+----------------
    -+$ git for-each-ref 'refs/remotes/origin' |
    -+  git bundle create origin.bundle --stdin
    -+----------------
    -+
    -+When providing names for revisions the reference name validation is
    -+loose. You should probably use fully-qualified names such as
    -+`refs/heads/master`, which is what we'll do for you in the simpler
    -+mode where you don't specify a reference name.
    -+
    -+In order to provide the flexibility of having a `HEAD` reference and
    -+other such `.git/NAME` references, even a name like `top-level` is
    -+supported. A name such as `top:level` is not, as it is not a valid ref
    -+name in any context within git (characters like ":" are not allowed).
    -+
    -+Thus it's possible to create bundles with nonsensical names that would
    -+not be semantically accepted by some of git's more stricter checking,
    -+e.g. tag object tips in a `refs/heads/*` namespace:
    -+
    -+----------------
    -+$ git for-each-ref 'refs/tags/v*' |
    -+  sed 's!refs/tags/!refs/heads/!' |
    -+  git bundle create bad-heads.bdl --stdin
    -+----------------
    -+
    -+The objects in such an odd bundle can be extracted, but "git fetch"
    -+might not accept some of them.
    -+
    - OBJECT PREREQUISITES
    - --------------------
    - 
    -
    - ## bundle.c ##
    -@@ bundle.c: static int write_pack_data(int bundle_fd, struct rev_info *revs, struct strvec *
    - 	return 0;
    - }
    - 
    -+struct stdin_line_cb {
    -+	struct strbuf *seen_refname;
    -+	struct string_list refname_to_pending;
    -+	int after_handle_revision_arg;
    -+	unsigned int last_pending_nr;
    -+};
    + ## cbtree.c (new) ##
    +@@
    ++/*
    ++ * crit-bit tree implementation, does no allocations internally
    ++ * For more information on crit-bit trees: https://cr.yp.to/critbit.html
    ++ * Based on Adam Langley's adaptation of Dan Bernstein's public domain code
    ++ * git clone https://github.com/agl/critbit.git
    ++ */
    ++#include "cbtree.h"
    ++
    ++static struct cb_node *cb_node_of(const void *p)
    ++{
    ++	return (struct cb_node *)((uintptr_t)p - 1);
    ++}
     +
    -+static enum rev_info_stdin_line write_bundle_after_stdin_line_again(struct rev_info *revs,
    -+								    struct stdin_line_cb *line_cb)
    ++/* locate the best match, does not do a final comparision */
    ++static struct cb_node *cb_internal_best_match(struct cb_node *p,
    ++					const uint8_t *k, size_t klen)
     +{
    -+	struct strbuf *seen_refname = line_cb->seen_refname;
    -+	struct string_list *refname_to_pending = &line_cb->refname_to_pending;
    -+	unsigned int last_pending_nr = line_cb->last_pending_nr;
    -+	unsigned int pending_nr = revs->pending.nr;
    -+	unsigned nr;
    ++	while (1 & (uintptr_t)p) {
    ++		struct cb_node *q = cb_node_of(p);
    ++		uint8_t c = q->byte < klen ? k[q->byte] : 0;
    ++		size_t direction = (1 + (q->otherbits | c)) >> 8;
     +
    -+	/*
    -+	 * We may not have a revision to attribute the manually
    -+	 * specified refname to, but we should have a refname.
    -+	 */
    -+	if (!seen_refname->len)
    -+		BUG("should have a seen refname in 'again' callback!");
    ++		p = q->child[direction];
    ++	}
    ++	return p;
    ++}
     +
    -+	/*
    -+	 * A deleted item won't add to pending_nr. See the
    -+	 * "^topic/deleted" test.
    -+	 */
    -+	if (last_pending_nr == pending_nr)
    -+		goto cleanup;
    ++/* returns NULL if successful, existing cb_node if duplicate */
    ++struct cb_node *cb_insert(struct cb_tree *t, struct cb_node *node, size_t klen)
    ++{
    ++	size_t newbyte, newotherbits;
    ++	uint8_t c;
    ++	int newdirection;
    ++	struct cb_node **wherep, *p;
     +
    -+	/*
    -+	 * With non-tabular input we append an empty line for the
    -+	 * convenience of having a 1=1 mapping between the "refnames"
    -+	 * string-list and "revs->pending" in write_bundle_refs()
    -+	 * below.
    -+	 *
    -+	 * If we've had previous deleted items we'll need to pad out
    -+	 * the list up to -1 of our current item...
    -+	 */
    -+	for (nr = refname_to_pending->nr; nr < pending_nr - 1; nr++)
    -+		string_list_append(refname_to_pending, "");
    ++	assert(!((uintptr_t)node & 1)); /* allocations must be aligned */
     +
    -+	/*
    -+	 * ... and with the gaps covered, and cases of e.g. "LHS..RHS"
    -+	 * being advanced to the "RHS" we can push our seen refname to
    -+	 * associated with either a good "REV" the "RHS" part of a
    -+	 * "LHS..RHS" range.
    -+	 */
    -+	string_list_append(refname_to_pending, seen_refname->buf);
    ++	if (!t->root) {		/* insert into empty tree */
    ++		t->root = node;
    ++		return NULL;	/* success */
    ++	}
     +
    -+cleanup:
    -+	strbuf_reset(seen_refname);
    -+	line_cb->after_handle_revision_arg = 0;
    -+	line_cb->last_pending_nr = pending_nr;
    ++	/* see if a node already exists */
    ++	p = cb_internal_best_match(t->root, node->k, klen);
     +
    -+	return REV_INFO_STDIN_LINE_CONTINUE;
    ++	/* find first differing byte */
    ++	for (newbyte = 0; newbyte < klen; newbyte++) {
    ++		if (p->k[newbyte] != node->k[newbyte])
    ++			goto different_byte_found;
    ++	}
    ++	return p;	/* element exists, let user deal with it */
    ++
    ++different_byte_found:
    ++	newotherbits = p->k[newbyte] ^ node->k[newbyte];
    ++	newotherbits |= newotherbits >> 1;
    ++	newotherbits |= newotherbits >> 2;
    ++	newotherbits |= newotherbits >> 4;
    ++	newotherbits = (newotherbits & ~(newotherbits >> 1)) ^ 255;
    ++	c = p->k[newbyte];
    ++	newdirection = (1 + (newotherbits | c)) >> 8;
    ++
    ++	node->byte = newbyte;
    ++	node->otherbits = newotherbits;
    ++	node->child[1 - newdirection] = node;
    ++
    ++	/* find a place to insert it */
    ++	wherep = &t->root;
    ++	for (;;) {
    ++		struct cb_node *q;
    ++		size_t direction;
    ++
    ++		p = *wherep;
    ++		if (!(1 & (uintptr_t)p))
    ++			break;
    ++		q = cb_node_of(p);
    ++		if (q->byte > newbyte)
    ++			break;
    ++		if (q->byte == newbyte && q->otherbits > newotherbits)
    ++			break;
    ++		c = q->byte < klen ? node->k[q->byte] : 0;
    ++		direction = (1 + (q->otherbits | c)) >> 8;
    ++		wherep = q->child + direction;
    ++	}
    ++
    ++	node->child[newdirection] = *wherep;
    ++	*wherep = (struct cb_node *)(1 + (uintptr_t)node);
    ++
    ++	return NULL; /* success */
     +}
     +
    -+static enum rev_info_stdin_line write_bundle_handle_stdin_line(
    -+	struct rev_info *revs, struct strbuf *line, void *stdin_line_priv)
    ++struct cb_node *cb_lookup(struct cb_tree *t, const uint8_t *k, size_t klen)
     +{
    -+	struct stdin_line_cb *line_cb = stdin_line_priv;
    -+	struct strbuf *seen_refname = line_cb->seen_refname;
    -+	const char delim = '\t';
    -+	struct strbuf **s;
    -+	struct strbuf *refname;
    -+	struct strbuf *revname;
    -+	struct strbuf **fields;
    -+	int i;
    -+
    -+	if (line_cb->after_handle_revision_arg)
    -+		return write_bundle_after_stdin_line_again(revs, line_cb);
    -+
    -+	/* Parse "<revision>" or "<revision>\t<refname>" input */
    -+	fields = strbuf_split_buf(line->buf, line->len, delim, -1);
    -+	for (s = fields, i = 0; *s; s++, i++) {
    -+		struct strbuf *field = *s;
    -+		enum object_type type;
    -+
    -+		/*
    -+		 * Have a <revision>, maybe followed by a "\t" if
    -+		 * there's another field.
    -+		 */
    -+		if (!i) {
    -+			revname = field;
    -+			continue;
    -+		}
    ++	struct cb_node *p = cb_internal_best_match(t->root, k, klen);
     +
    -+		/* ... trim off that "\t" */
    -+		if (revname->len > 0 && revname->buf[revname->len - 1] == delim)
    -+			revname->buf[--revname->len] = '\0';
    -+
    -+		/*
    -+		 * We don't need to explicitly validate >2 fields,
    -+		 * since check_refname_format() will refuse a refname
    -+		 * with a trailing tab.
    -+		 *
    -+		 * We could supply a max of "2" to strbuf_split_buf()
    -+		 * above instead of -1; but accepting N fields there
    -+		 * makes for better error messages here, as the
    -+		 * invalid ref will contain the trailing tab.
    -+		 */
    -+		refname = field;
    -+		if (check_refname_format(refname->buf, REFNAME_ALLOW_ONELEVEL))
    -+			die(_("'%s' is not a valid ref name"), refname->buf);
    -+		strbuf_addbuf(seen_refname, refname);
    -+
    -+		/*
    -+		 * We haven't validated "<revname>" which could
    -+		 * contain arbitrary non-"\t" characters at this
    -+		 * point, e.g. "<oid> commit".
    -+		 *
    -+		 * Here we strip " commit", " tree", " blob" and " tag" as a
    -+		 * special-case for consuming the default for-each-ref
    -+		 * format. We're permissive and don't validate the
    -+		 * stated type.
    -+		 *
    -+		 * Any other validation of "<revname> " will be done
    -+		 * by revision.c's handle_revision_arg().
    -+		 */
    -+		for (type = OBJ_COMMIT; type <= OBJ_TAG; type++) {
    -+			const char *name = type_name(type);
    -+			if (strbuf_strip_suffix(revname, name) &&
    -+			    revname->len > 0 &&
    -+			    revname->buf[revname->len - 1] == ' ') {
    -+				revname->buf[--revname->len] = '\0';
    -+				break;
    -+			}
    -+		}
    ++	return p && !memcmp(p->k, k, klen) ? p : NULL;
    ++}
     +
    -+		/*
    -+		 * Pretend as if only the <revision> was on this line
    -+		 * in revision.c's read_revisions_from_stdin() by
    -+		 * juggling around the strbuf it'll pass to its
    -+		 * handle_revision_arg().
    -+		 */
    -+		strbuf_swap(line, revname);
    -+		strbuf_release(refname);
    -+		strbuf_release(revname);
    -+		line_cb->after_handle_revision_arg = 1;
    -+		return REV_INFO_STDIN_LINE_AGAIN;
    ++struct cb_node *cb_unlink(struct cb_tree *t, const uint8_t *k, size_t klen)
    ++{
    ++	struct cb_node **wherep = &t->root;
    ++	struct cb_node **whereq = NULL;
    ++	struct cb_node *q = NULL;
    ++	size_t direction = 0;
    ++	uint8_t c;
    ++	struct cb_node *p = t->root;
    ++
    ++	if (!p) return NULL;	/* empty tree, nothing to delete */
    ++
    ++	/* traverse to find best match, keeping link to parent */
    ++	while (1 & (uintptr_t)p) {
    ++		whereq = wherep;
    ++		q = cb_node_of(p);
    ++		c = q->byte < klen ? k[q->byte] : 0;
    ++		direction = (1 + (q->otherbits | c)) >> 8;
    ++		wherep = q->child + direction;
    ++		p = *wherep;
     +	}
     +
    -+	return REV_INFO_STDIN_LINE_PROCESS;
    ++	if (memcmp(p->k, k, klen))
    ++		return NULL;		/* no match, nothing unlinked */
    ++
    ++	/* found an exact match */
    ++	if (whereq)	/* update parent */
    ++		*whereq = q->child[1 - direction];
    ++	else
    ++		t->root = NULL;
    ++	return p;
    ++}
    ++
    ++static enum cb_next cb_descend(struct cb_node *p, cb_iter fn, void *arg)
    ++{
    ++	if (1 & (uintptr_t)p) {
    ++		struct cb_node *q = cb_node_of(p);
    ++		enum cb_next n = cb_descend(q->child[0], fn, arg);
    ++
    ++		return n == CB_BREAK ? n : cb_descend(q->child[1], fn, arg);
    ++	} else {
    ++		return fn(p, arg);
    ++	}
     +}
     +
    - /*
    -  * Write out bundle refs based on the tips already
    -  * parsed into revs.pending. As a side effect, may
    -@@ bundle.c: static int write_bundle_refs(int bundle_fd, struct rev_info *revs)
    ++void cb_each(struct cb_tree *t, const uint8_t *kpfx, size_t klen,
    ++			cb_iter fn, void *arg)
    ++{
    ++	struct cb_node *p = t->root;
    ++	struct cb_node *top = p;
    ++	size_t i = 0;
    ++
    ++	if (!p) return; /* empty tree */
    ++
    ++	/* Walk tree, maintaining top pointer */
    ++	while (1 & (uintptr_t)p) {
    ++		struct cb_node *q = cb_node_of(p);
    ++		uint8_t c = q->byte < klen ? kpfx[q->byte] : 0;
    ++		size_t direction = (1 + (q->otherbits | c)) >> 8;
    ++
    ++		p = q->child[direction];
    ++		if (q->byte < klen)
    ++			top = p;
    ++	}
    ++
    ++	for (i = 0; i < klen; i++) {
    ++		if (p->k[i] != kpfx[i])
    ++			return; /* "best" match failed */
    ++	}
    ++	cb_descend(top, fn, arg);
    ++}
    +
    + ## cbtree.h (new) ##
    +@@
    ++/*
    ++ * crit-bit tree implementation, does no allocations internally
    ++ * For more information on crit-bit trees: https://cr.yp.to/critbit.html
    ++ * Based on Adam Langley's adaptation of Dan Bernstein's public domain code
    ++ * git clone https://github.com/agl/critbit.git
    ++ *
    ++ * This is adapted to store arbitrary data (not just NUL-terminated C strings
    ++ * and allocates no memory internally.  The user needs to allocate
    ++ * "struct cb_node" and fill cb_node.k[] with arbitrary match data
    ++ * for memcmp.
    ++ * If "klen" is variable, then it should be embedded into "c_node.k[]"
    ++ * Recursion is bound by the maximum value of "klen" used.
    ++ */
    ++#ifndef CBTREE_H
    ++#define CBTREE_H
    ++
    ++#include "git-compat-util.h"
    ++
    ++struct cb_node;
    ++struct cb_node {
    ++	struct cb_node *child[2];
    ++	/*
    ++	 * n.b. uint32_t for `byte' is excessive for OIDs,
    ++	 * we may consider shorter variants if nothing else gets stored.
    ++	 */
    ++	uint32_t byte;
    ++	uint8_t otherbits;
    ++	uint8_t k[FLEX_ARRAY]; /* arbitrary data */
    ++};
    ++
    ++struct cb_tree {
    ++	struct cb_node *root;
    ++};
    ++
    ++enum cb_next {
    ++	CB_CONTINUE = 0,
    ++	CB_BREAK = 1
    ++};
    ++
    ++#define CBTREE_INIT { .root = NULL }
    ++
    ++static inline void cb_init(struct cb_tree *t)
    ++{
    ++	t->root = NULL;
    ++}
    ++
    ++struct cb_node *cb_lookup(struct cb_tree *, const uint8_t *k, size_t klen);
    ++struct cb_node *cb_insert(struct cb_tree *, struct cb_node *, size_t klen);
    ++struct cb_node *cb_unlink(struct cb_tree *t, const uint8_t *k, size_t klen);
    ++
    ++typedef enum cb_next (*cb_iter)(struct cb_node *, void *arg);
    ++
    ++void cb_each(struct cb_tree *, const uint8_t *kpfx, size_t klen,
    ++		cb_iter, void *arg);
    ++
    ++#endif /* CBTREE_H */
    +
    + ## object-file.c ##
    +@@ object-file.c: static int quick_has_loose(struct repository *r,
    + 
    + 	prepare_alt_odb(r);
    + 	for (odb = r->objects->odb; odb; odb = odb->next) {
    +-		if (oid_array_lookup(odb_loose_cache(odb, oid), oid) >= 0)
    ++		if (oidtree_contains(odb_loose_cache(odb, oid), oid))
    + 			return 1;
    + 	}
    + 	return 0;
    +@@ object-file.c: int for_each_loose_object(each_loose_object_fn cb, void *data,
    + static int append_loose_object(const struct object_id *oid, const char *path,
    + 			       void *data)
      {
    - 	int i;
    - 	int ref_count = 0;
    -+	struct stdin_line_cb *line_cb = revs->stdin_line_priv;
    -+	struct string_list *refname_to_pending = &line_cb->refname_to_pending;
    +-	oid_array_append(data, oid);
    ++	oidtree_insert(data, oid);
    + 	return 0;
    + }
      
    - 	for (i = 0; i < revs->pending.nr; i++) {
    -+		char *refname = refname_to_pending->nr > i ?
    -+			refname_to_pending->items[i].string : "";
    - 		struct object_array_entry *e = revs->pending.objects + i;
    - 		struct object_id oid;
    - 		char *ref;
    - 		const char *display_ref;
    - 		int flag;
    +-struct oid_array *odb_loose_cache(struct object_directory *odb,
    ++struct oidtree *odb_loose_cache(struct object_directory *odb,
    + 				  const struct object_id *oid)
    + {
    + 	int subdir_nr = oid->hash[0];
    +@@ object-file.c: struct oid_array *odb_loose_cache(struct object_directory *odb,
      
    -+		if (*refname) {
    -+			display_ref = refname;
    -+			goto write_it;
    -+		}
    - 		if (e->item->flags & UNINTERESTING)
    - 			continue;
    - 		if (dwim_ref(e->name, strlen(e->name), &oid, &ref, 0) != 1)
    -@@ bundle.c: static int write_bundle_refs(int bundle_fd, struct rev_info *revs)
    - 			goto skip_write_ref;
    - 		}
    + 	bitmap = &odb->loose_objects_subdir_seen[word_index];
    + 	if (*bitmap & mask)
    +-		return &odb->loose_objects_cache[subdir_nr];
    +-
    ++		return odb->loose_objects_cache;
    ++	if (!odb->loose_objects_cache) {
    ++		ALLOC_ARRAY(odb->loose_objects_cache, 1);
    ++		oidtree_init(odb->loose_objects_cache);
    ++	}
    + 	strbuf_addstr(&buf, odb->path);
    + 	for_each_file_in_obj_subdir(subdir_nr, &buf,
    + 				    append_loose_object,
    + 				    NULL, NULL,
    +-				    &odb->loose_objects_cache[subdir_nr]);
    ++				    odb->loose_objects_cache);
    + 	*bitmap |= mask;
    + 	strbuf_release(&buf);
    +-	return &odb->loose_objects_cache[subdir_nr];
    ++	return odb->loose_objects_cache;
    + }
      
    -+	write_it:
    - 		ref_count++;
    - 		write_or_die(bundle_fd, oid_to_hex(&e->item->oid), the_hash_algo->hexsz);
    - 		write_or_die(bundle_fd, " ", 1);
    - 		write_or_die(bundle_fd, display_ref, strlen(display_ref));
    - 		write_or_die(bundle_fd, "\n", 1);
    -  skip_write_ref:
    --		free(ref);
    -+		if (!*refname)
    -+			free(ref);
    - 	}
    + void odb_clear_loose_cache(struct object_directory *odb)
    + {
    +-	int i;
    +-
    +-	for (i = 0; i < ARRAY_SIZE(odb->loose_objects_cache); i++)
    +-		oid_array_clear(&odb->loose_objects_cache[i]);
    ++	oidtree_clear(odb->loose_objects_cache);
    ++	FREE_AND_NULL(odb->loose_objects_cache);
    + 	memset(&odb->loose_objects_subdir_seen, 0,
    + 	       sizeof(odb->loose_objects_subdir_seen));
    + }
    +
    + ## object-name.c ##
    +@@ object-name.c: static void update_candidates(struct disambiguate_state *ds, const struct object
      
    - 	/* end header */
    -@@ bundle.c: int create_bundle(struct repository *r, const char *path,
    - 	int min_version = the_hash_algo == &hash_algos[GIT_HASH_SHA1] ? 2 : 3;
    - 	struct bundle_prerequisites_info bpi;
    - 	int i;
    -+	struct strbuf seen_refname = STRBUF_INIT;
    -+	struct string_list refname_to_pending = STRING_LIST_INIT_DUP;
    -+	struct stdin_line_cb line_cb = {
    -+		.seen_refname = &seen_refname,
    -+		.refname_to_pending = refname_to_pending,
    -+	};
    + static int match_hash(unsigned, const unsigned char *, const unsigned char *);
      
    - 	bundle_to_stdout = !strcmp(path, "-");
    - 	if (bundle_to_stdout)
    -@@ bundle.c: int create_bundle(struct repository *r, const char *path,
    - 	/* init revs to list objects for pack-objects later */
    - 	save_commit_buffer = 0;
    - 	repo_init_revisions(r, &revs, NULL);
    -+	revs.stdin_line_priv = &line_cb;
    -+	revs.handle_stdin_line = write_bundle_handle_stdin_line;
    ++static enum cb_next match_prefix(const struct object_id *oid, void *arg)
    ++{
    ++	struct disambiguate_state *ds = arg;
    ++	/* no need to call match_hash, oidtree_each did prefix match */
    ++	update_candidates(ds, oid);
    ++	return ds->ambiguous ? CB_BREAK : CB_CONTINUE;
    ++}
    ++
    + static void find_short_object_filename(struct disambiguate_state *ds)
    + {
    + 	struct object_directory *odb;
      
    - 	argc = setup_revisions(argc, argv, &revs, NULL);
    +-	for (odb = ds->repo->objects->odb; odb && !ds->ambiguous; odb = odb->next) {
    +-		int pos;
    +-		struct oid_array *loose_objects;
    +-
    +-		loose_objects = odb_loose_cache(odb, &ds->bin_pfx);
    +-		pos = oid_array_lookup(loose_objects, &ds->bin_pfx);
    +-		if (pos < 0)
    +-			pos = -1 - pos;
    +-		while (!ds->ambiguous && pos < loose_objects->nr) {
    +-			const struct object_id *oid;
    +-			oid = loose_objects->oid + pos;
    +-			if (!match_hash(ds->len, ds->bin_pfx.hash, oid->hash))
    +-				break;
    +-			update_candidates(ds, oid);
    +-			pos++;
    +-		}
    +-	}
    ++	for (odb = ds->repo->objects->odb; odb && !ds->ambiguous; odb = odb->next)
    ++		oidtree_each(odb_loose_cache(odb, &ds->bin_pfx),
    ++				&ds->bin_pfx, ds->len, match_prefix, ds);
    + }
      
    + static int match_hash(unsigned len, const unsigned char *a, const unsigned char *b)
     
    - ## t/t6021-bundle-stdin.sh (new) ##
    + ## object-store.h ##
     @@
    -+#!/bin/sh
    -+
    -+test_description='Test git-bundle --stdin in detail'
    -+
    -+. ./test-lib.sh
    -+. "$TEST_DIRECTORY"/lib-bundle.sh
    -+
    -+test_expect_success 'setup' '
    -+	test_commit --no-tag initial &&
    -+	test_commit --no-tag second &&
    -+	test_commit --no-tag third &&
    -+	test_commit --no-tag fourth &&
    -+	test_commit --no-tag fifth &&
    -+	test_commit --no-tag sixth &&
    -+	test_commit --no-tag seventh &&
    -+
    -+	git tag -a -m"my tag" tag :/second &&
    -+	git branch trunk :/third &&
    -+	git branch next :/fifth &&
    -+	git branch unstable :/sixth &&
    -+
    -+	git checkout -b divergent :/initial &&
    -+	test_commit --no-tag alt-2nd &&
    -+
    -+	git checkout -
    -+'
    -+
    -+# --stdin tabular input
    -+test_expect_success 'bundle --stdin understands tabular-like output' '
    -+	test_must_fail git rev-parse refs/heads/second &&
    -+
    -+	cat >in <<-EOF &&
    -+	$(git rev-parse :/initial)	refs/heads/initial
    -+	EOF
    -+	git bundle create initial.bdl --stdin <in &&
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse :/initial)	refs/heads/initial
    -+	EOF
    -+	git ls-remote initial.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count initial.bdl 3
    -+'
    -+
    -+test_expect_success 'bundle --stdin mixed rev-list and tabular input' '
    -+	cat >in <<-EOF &&
    -+	$(git rev-parse :/initial)	refs/heads/initial
    -+	$(git symbolic-ref --short HEAD)
    -+	EOF
    -+	git bundle create mixed.bdl --stdin <in &&
    -+
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse HEAD)	$(git symbolic-ref HEAD)
    -+	$(git rev-parse :/initial)	refs/heads/initial
    -+	EOF
    -+	git ls-remote mixed.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count mixed.bdl 21
    -+'
    + #include "thread-utils.h"
    + #include "khash.h"
    + #include "dir.h"
    ++#include "oidtree.h"
    + 
    + struct object_directory {
    + 	struct object_directory *next;
    +@@ object-store.h: struct object_directory {
    + 	 * Be sure to call odb_load_loose_cache() before using.
    + 	 */
    + 	uint32_t loose_objects_subdir_seen[8]; /* 256 bits */
    +-	struct oid_array loose_objects_cache[256];
    ++	struct oidtree *loose_objects_cache;
    + 
    + 	/*
    + 	 * Path to the alternative object store. If this is a relative path,
    +@@ object-store.h: void add_to_alternates_memory(const char *dir);
    +  * Populate and return the loose object cache array corresponding to the
    +  * given object ID.
    +  */
    +-struct oid_array *odb_loose_cache(struct object_directory *odb,
    ++struct oidtree *odb_loose_cache(struct object_directory *odb,
    + 				  const struct object_id *oid);
    + 
    + /* Empty the loose object cache for the specified object directory. */
    +
    + ## oidtree.c (new) ##
    +@@
    ++/*
    ++ * A wrapper around cbtree which stores oids
    ++ * May be used to replace oid-array for prefix (abbreviation) matches
    ++ */
    ++#include "oidtree.h"
    ++#include "alloc.h"
    ++#include "hash.h"
    ++
    ++struct oidtree_node {
    ++	/* n.k[] is used to store "struct object_id" */
    ++	struct cb_node n;
    ++};
     +
    -+test_expect_success 'bundle --stdin basic rev-range tabular input, RHS is a ref name' '
    -+	cat >in <<-EOF &&
    -+	HEAD~1..$(git symbolic-ref --short HEAD)	refs/tags/latest-update
    -+	EOF
    -+	git bundle create latest-update.bdl --stdin <in &&
    ++struct oidtree_iter_data {
    ++	oidtree_iter fn;
    ++	void *arg;
    ++	size_t *last_nibble_at;
    ++	int algo;
    ++	uint8_t last_byte;
    ++};
     +
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse HEAD)	refs/tags/latest-update
    -+	EOF
    -+	git ls-remote latest-update.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count --thin latest-update.bdl 4
    -+'
    ++void oidtree_init(struct oidtree *ot)
    ++{
    ++	cb_init(&ot->tree);
    ++	mem_pool_init(&ot->mem_pool, 0);
    ++}
     +
    -+test_expect_success 'bundle --stdin basic rev-range tabular input, LHS is a ref name' '
    -+	cat >in <<-EOF &&
    -+	trunk..$(git rev-parse :/fourth)	refs/tags/post-trunk-update
    -+	EOF
    -+	git bundle create post-trunk-update.bdl --stdin <in &&
    ++void oidtree_clear(struct oidtree *ot)
    ++{
    ++	if (ot) {
    ++		mem_pool_discard(&ot->mem_pool, 0);
    ++		oidtree_init(ot);
    ++	}
    ++}
     +
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse :/fourth)	refs/tags/post-trunk-update
    -+	EOF
    -+	git ls-remote post-trunk-update.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count post-trunk-update.bdl 3
    -+'
    ++void oidtree_insert(struct oidtree *ot, const struct object_id *oid)
    ++{
    ++	struct oidtree_node *on;
     +
    -+test_expect_success 'bundle --stdin basic rev-range tabular input, LHS and RHS are not ref names' '
    -+	cat >in <<-EOF &&
    -+	HEAD~2..HEAD~1	refs/tags/penultimate-update
    -+	EOF
    -+	git bundle create penultimate-update.bdl --stdin <in &&
    ++	if (!oid->algo)
    ++		BUG("oidtree_insert requires oid->algo");
     +
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse HEAD~)	refs/tags/penultimate-update
    -+	EOF
    -+	git ls-remote penultimate-update.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count --thin penultimate-update.bdl 4
    -+'
    ++	on = mem_pool_alloc(&ot->mem_pool, sizeof(*on) + sizeof(*oid));
    ++	oidcpy_with_padding((struct object_id *)on->n.k, oid);
     +
    -+test_expect_success 'bundle --stdin complex rev-range tabular input, multiple ranges' '
    -+	cat >in <<-EOF &&
    -+	:/initial..:/second	refs/tags/second-push
    -+	:/fourth..:/fifth	refs/tags/fourth-push
    -+	EOF
    -+	git bundle create multiple-updates.bdl --stdin <in &&
    ++	/*
    ++	 * n.b. Current callers won't get us duplicates, here.  If a
    ++	 * future caller causes duplicates, there'll be a a small leak
    ++	 * that won't be freed until oidtree_clear.  Currently it's not
    ++	 * worth maintaining a free list
    ++	 */
    ++	cb_insert(&ot->tree, &on->n, sizeof(*oid));
    ++}
     +
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse :/fifth)	refs/tags/fourth-push
    -+	$(git rev-parse :/second)	refs/tags/second-push
    -+	EOF
    -+	git ls-remote multiple-updates.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count --thin multiple-updates.bdl 4
    -+'
     +
    -+test_expect_success 'bundle --stdin complex rev-range mixed tabular and ref name input' '
    -+	cat >in <<-EOF &&
    -+	trunk~..trunk
    -+	$(git rev-parse :/initial)..$(git rev-parse :/alt-2nd)	refs/tags/first-divergent-push
    -+	EOF
    -+	git bundle create mixed-multiple-updates.bdl --stdin <in &&
    ++int oidtree_contains(struct oidtree *ot, const struct object_id *oid)
    ++{
    ++	struct object_id k;
    ++	size_t klen = sizeof(k);
     +
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse :/alt-2nd)	refs/tags/first-divergent-push
    -+	$(git rev-parse trunk)	refs/heads/trunk
    -+	EOF
    -+	git ls-remote mixed-multiple-updates.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count mixed-multiple-updates.bdl 6
    -+'
    ++	oidcpy_with_padding(&k, oid);
     +
    -+# --stdin tabular input rev validation
    -+test_expect_success 'bundle --stdin tabular input requires valid revisions' '
    -+	cat >in <<-EOF &&
    -+	$(test_oid deadbeef)	refs/heads/deadbeef
    -+	EOF
    -+	cat >expect <<-EOF &&
    -+	fatal: bad object $(test_oid deadbeef)
    -+	EOF
    -+	test_must_fail git bundle create err.bdl --stdin <in 2>actual &&
    -+	test_cmp expect actual &&
    -+	test_path_is_missing err.bdl
    -+'
    ++	if (oid->algo == GIT_HASH_UNKNOWN)
    ++		klen -= sizeof(oid->algo);
     +
    -+# --stdin tabular input ref validation
    -+test_expect_success 'bundle --stdin tabular input accepts one-level ref names' '
    -+	cat >in <<-EOF &&
    -+	$(git rev-parse HEAD)	HEAD
    -+	$(git rev-parse :/initial)	initial
    -+	EOF
    -+	git bundle create one-level.bdl --stdin <in &&
    ++	/* cb_lookup relies on memcmp on the struct, so order matters: */
    ++	klen += BUILD_ASSERT_OR_ZERO(offsetof(struct object_id, hash) <
    ++				offsetof(struct object_id, algo));
     +
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse :/initial)	initial
    -+	$(git rev-parse HEAD)	HEAD
    -+	EOF
    -+	git ls-remote one-level.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count one-level.bdl 21
    -+'
    ++	return cb_lookup(&ot->tree, (const uint8_t *)&k, klen) ? 1 : 0;
    ++}
     +
    -+test_expect_success 'bundle --stdin tabular input requires valid refs' '
    -+	cat >in <<-EOF &&
    -+	$(git rev-parse :/second)	bad:ref:name
    -+	EOF
    -+	cat >expect <<-\EOF &&
    -+	fatal: '"'"'bad:ref:name'"'"' is not a valid ref name
    -+	EOF
    -+	test_must_fail git bundle create err.bdl --stdin <in 2>actual &&
    -+	test_cmp expect actual &&
    -+	test_path_is_missing err.bdl
    -+'
    ++static enum cb_next iter(struct cb_node *n, void *arg)
    ++{
    ++	struct oidtree_iter_data *x = arg;
    ++	const struct object_id *oid = (const struct object_id *)n->k;
     +
    -+# --stdin tabular input parsing
    -+test_expect_success 'bundle --stdin tabular input refuses extra fields' '
    -+	cat >in <<-EOF &&
    -+	$(git rev-parse :/initial)	refs/heads/a-branch	unknown-field
    -+	EOF
    -+	cat >expect <<-\EOF &&
    -+	fatal: '"'"'refs/heads/a-branch	'"'"' is not a valid ref name
    -+	EOF
    -+	test_must_fail git bundle create err.bdl --stdin <in 2>actual &&
    -+	test_cmp expect actual &&
    -+	test_path_is_missing err.bdl
    -+'
    ++	if (x->algo != GIT_HASH_UNKNOWN && x->algo != oid->algo)
    ++		return CB_CONTINUE;
     +
    -+test_expect_success 'bundle --stdin tabular input refuses trailing tab' '
    -+	sed "s/Z$//" >in <<-EOF &&
    -+	$(git rev-parse :/initial)	refs/heads/a-branch	Z
    -+	EOF
    -+	cat >expect <<-\EOF &&
    -+	fatal: '"'"'refs/heads/a-branch	'"'"' is not a valid ref name
    -+	EOF
    -+	test_must_fail git bundle create err.bdl --stdin <in 2>actual &&
    -+	test_cmp expect actual &&
    -+	test_path_is_missing err.bdl
    -+'
    -+
    -+test_expect_success 'bundle --stdin tabular input refuses empty field' '
    -+	sed "s/Z$//" >in <<-EOF &&
    -+	$(git rev-parse :/initial)		refs/heads/a-branch
    -+	EOF
    -+	cat >expect <<-\EOF &&
    -+	fatal: '"'"'	'"'"' is not a valid ref name
    -+	EOF
    -+	test_must_fail git bundle create err.bdl --stdin <in 2>actual &&
    -+	test_cmp expect actual &&
    -+	test_path_is_missing err.bdl
    -+'
    ++	if (x->last_nibble_at) {
    ++		if ((oid->hash[*x->last_nibble_at] ^ x->last_byte) & 0xf0)
    ++			return CB_CONTINUE;
    ++	}
     +
    -+test_expect_success 'bundle --stdin tabular input with non-existing reference' '
    -+	sed "s/Z$//" >in <<-EOF &&
    -+	^topic/deleted	refs/heads/topic-deleted
    -+	$(git rev-parse :/initial)	refs/heads/a-branch
    -+	EOF
    -+	cat >expect <<-\EOF &&
    -+	fatal: bad revision '"'"'^topic/deleted'"'"'
    -+	EOF
    -+	test_must_fail git bundle create err.bdl --stdin <in 2>actual &&
    -+	test_cmp expect actual &&
    -+	test_path_is_missing err.bdl
    -+'
    ++	return x->fn(oid, x->arg);
    ++}
     +
    -+test_expect_success 'bundle --stdin tabular input with non-existing reference and --ignore-missing (existing first)' '
    -+	sed "s/Z$//" >in <<-EOF &&
    -+	$(git rev-parse :/initial)	refs/heads/a-branch
    -+	^topic/deleted	refs/heads/topic-deleted
    -+	EOF
    ++void oidtree_each(struct oidtree *ot, const struct object_id *oid,
    ++			size_t oidhexsz, oidtree_iter fn, void *arg)
    ++{
    ++	size_t klen = oidhexsz / 2;
    ++	struct oidtree_iter_data x = { 0 };
    ++	assert(oidhexsz <= GIT_MAX_HEXSZ);
    ++
    ++	x.fn = fn;
    ++	x.arg = arg;
    ++	x.algo = oid->algo;
    ++	if (oidhexsz & 1) {
    ++		x.last_byte = oid->hash[klen];
    ++		x.last_nibble_at = &klen;
    ++	}
    ++	cb_each(&ot->tree, (const uint8_t *)oid, klen, iter, &x);
    ++}
    +
    + ## oidtree.h (new) ##
    +@@
    ++#ifndef OIDTREE_H
    ++#define OIDTREE_H
     +
    -+	git bundle create ignore-missing.bdl --ignore-missing --stdin <in &&
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse :/initial)	refs/heads/a-branch
    -+	EOF
    -+	git ls-remote ignore-missing.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count ignore-missing.bdl 3
    -+'
    ++#include "cbtree.h"
    ++#include "hash.h"
    ++#include "mem-pool.h"
     +
    -+test_expect_success 'bundle --stdin tabular input with non-existing reference and --ignore-missing (deleted first)' '
    -+	sed "s/Z$//" >in <<-EOF &&
    -+	^topic/deleted	refs/heads/topic-deleted
    -+	$(git rev-parse :/initial)	refs/heads/a-branch
    -+	EOF
    ++struct oidtree {
    ++	struct cb_tree tree;
    ++	struct mem_pool mem_pool;
    ++};
     +
    -+	FOO=1 git bundle create ignore-missing2.bdl --ignore-missing --stdin <in &&
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse :/initial)	refs/heads/a-branch
    -+	EOF
    -+	git ls-remote ignore-missing2.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count ignore-missing2.bdl 3
    -+'
    ++void oidtree_init(struct oidtree *);
    ++void oidtree_clear(struct oidtree *);
    ++void oidtree_insert(struct oidtree *, const struct object_id *);
    ++int oidtree_contains(struct oidtree *, const struct object_id *);
     +
    -+test_expect_success 'bundle --stdin tabular input with non-existing reference and --ignore-missing (mixed existing and deleted)' '
    -+	sed "s/Z$//" >in <<-EOF &&
    -+	$(git rev-parse HEAD)	$(git symbolic-ref HEAD)
    -+	^topic/deleted	refs/heads/topic-deleted
    -+	$(git rev-parse :/initial)	refs/heads/a-branch
    -+	^topic/deleted2	refs/heads/topic-deleted2
    -+	EOF
    ++typedef enum cb_next (*oidtree_iter)(const struct object_id *, void *data);
    ++void oidtree_each(struct oidtree *, const struct object_id *,
    ++			size_t oidhexsz, oidtree_iter, void *data);
     +
    -+	FOO=1 git bundle create ignore-missing3.bdl --ignore-missing --stdin <in &&
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse :/initial)	refs/heads/a-branch
    -+	$(git rev-parse HEAD)	$(git symbolic-ref HEAD)
    -+	EOF
    -+	git ls-remote ignore-missing3.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count ignore-missing2.bdl 3
    -+'
    ++#endif /* OIDTREE_H */
    +
    + ## t/helper/test-oidtree.c (new) ##
    +@@
    ++#include "test-tool.h"
    ++#include "cache.h"
    ++#include "oidtree.h"
     +
    -+# --stdin tabular input show-ref incompatibility
    -+test_expect_success 'bundle --stdin tabular input is incompatible with "git show-ref"' '
    -+	git show-ref >sr &&
    ++static enum cb_next print_oid(const struct object_id *oid, void *data)
    ++{
    ++	puts(oid_to_hex(oid));
    ++	return CB_CONTINUE;
    ++}
     +
    -+	cat >expect <<-EOF &&
    -+	fatal: bad revision '"'"'$(git rev-parse divergent) refs/heads/divergent'"'"'
    -+	EOF
    -+	test_must_fail git bundle create err.bdl --stdin <sr 2>actual &&
    -+	test_cmp expect actual &&
    -+	test_path_is_missing err.bdl
    -+'
    ++int cmd__oidtree(int argc, const char **argv)
    ++{
    ++	struct oidtree ot;
    ++	struct strbuf line = STRBUF_INIT;
    ++	int nongit_ok;
    ++	int algo = GIT_HASH_UNKNOWN;
    ++
    ++	oidtree_init(&ot);
    ++	setup_git_directory_gently(&nongit_ok);
    ++
    ++	while (strbuf_getline(&line, stdin) != EOF) {
    ++		const char *arg;
    ++		struct object_id oid;
    ++
    ++		if (skip_prefix(line.buf, "insert ", &arg)) {
    ++			if (get_oid_hex_any(arg, &oid) == GIT_HASH_UNKNOWN)
    ++				die("insert not a hexadecimal oid: %s", arg);
    ++			algo = oid.algo;
    ++			oidtree_insert(&ot, &oid);
    ++		} else if (skip_prefix(line.buf, "contains ", &arg)) {
    ++			if (get_oid_hex(arg, &oid))
    ++				die("contains not a hexadecimal oid: %s", arg);
    ++			printf("%d\n", oidtree_contains(&ot, &oid));
    ++		} else if (skip_prefix(line.buf, "each ", &arg)) {
    ++			char buf[GIT_MAX_HEXSZ + 1] = { '0' };
    ++			memset(&oid, 0, sizeof(oid));
    ++			memcpy(buf, arg, strlen(arg));
    ++			buf[hash_algos[algo].hexsz] = '\0';
    ++			get_oid_hex_any(buf, &oid);
    ++			oid.algo = algo;
    ++			oidtree_each(&ot, &oid, strlen(arg), print_oid, NULL);
    ++		} else if (!strcmp(line.buf, "clear")) {
    ++			oidtree_clear(&ot);
    ++		} else {
    ++			die("unknown command: %s", line.buf);
    ++		}
    ++	}
    ++	return 0;
    ++}
    +
    + ## t/helper/test-tool.c ##
    +@@ t/helper/test-tool.c: static struct test_cmd cmds[] = {
    + 	{ "mktemp", cmd__mktemp },
    + 	{ "oid-array", cmd__oid_array },
    + 	{ "oidmap", cmd__oidmap },
    ++	{ "oidtree", cmd__oidtree },
    + 	{ "online-cpus", cmd__online_cpus },
    + 	{ "parse-options", cmd__parse_options },
    + 	{ "parse-pathspec-file", cmd__parse_pathspec_file },
    +
    + ## t/helper/test-tool.h ##
    +@@ t/helper/test-tool.h: int cmd__match_trees(int argc, const char **argv);
    + int cmd__mergesort(int argc, const char **argv);
    + int cmd__mktemp(int argc, const char **argv);
    + int cmd__oidmap(int argc, const char **argv);
    ++int cmd__oidtree(int argc, const char **argv);
    + int cmd__online_cpus(int argc, const char **argv);
    + int cmd__parse_options(int argc, const char **argv);
    + int cmd__parse_pathspec_file(int argc, const char** argv);
    +
    + ## t/t0069-oidtree.sh (new) ##
    +@@
    ++#!/bin/sh
     +
    -+# --stdin tabular input for-each-ref compatibility
    -+test_expect_success 'bundle --stdin tabular input is compatible with "git for-each-ref"' '
    -+	git for-each-ref >fer &&
    -+	git bundle create fer-fmt.bdl --stdin <fer &&
    -+
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse divergent) refs/heads/divergent
    -+	$(git rev-parse HEAD) $(git symbolic-ref HEAD)
    -+	$(git rev-parse next) refs/heads/next
    -+	$(git rev-parse trunk) refs/heads/trunk
    -+	$(git rev-parse unstable) refs/heads/unstable
    -+	$(git rev-parse tag) refs/tags/tag
    -+	EOF
    -+	git bundle list-heads fer-fmt.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count fer-fmt.bdl 25
    -+'
    ++test_description='basic tests for the oidtree implementation'
    ++. ./test-lib.sh
     +
    -+test_expect_success 'bundle --stdin tabular input errors on corrpt "git for-each-ref" output' '
    -+	git for-each-ref >fer.raw &&
    -+	tr " " "?" <fer.raw >fer &&
    -+	cat >expect <<-EOF &&
    -+	fatal: bad revision '"'"'$(git rev-parse divergent)?'"'"'
    -+	EOF
    -+	test_must_fail git bundle create fer-fmt-bad.bdl --stdin <fer 2>actual &&
    -+	test_cmp expect actual &&
    -+	test_path_is_missing fer-fmt-bad.bdl
    ++maxhexsz=$(test_oid hexsz)
    ++echoid () {
    ++	prefix="${1:+$1 }"
    ++	shift
    ++	while test $# -gt 0
    ++	do
    ++		shortoid="$1"
    ++		shift
    ++		difference=$(($maxhexsz - ${#shortoid}))
    ++		printf "%s%s%0${difference}d\\n" "$prefix" "$shortoid" "0"
    ++	done
    ++}
     +
    ++test_expect_success 'oidtree insert and contains' '
    ++	cat >expect <<-\EOF &&
    ++		0
    ++		0
    ++		0
    ++		1
    ++		1
    ++		0
    ++	EOF
    ++	{
    ++		echoid insert 444 1 2 3 4 5 a b c d e &&
    ++		echoid contains 44 441 440 444 4440 4444
    ++		echo clear
    ++	} | test-tool oidtree >actual &&
    ++	test_cmp expect actual
     +'
     +
    -+# --stdin tabular input for-each-ref parsing
    -+test_expect_success 'bundle --stdin tabular "git for-each-ref" input ignores types' '
    -+	git for-each-ref >fer &&
    -+	cat fer &&
    -+	sed -e "s/commit/blob/" -e "s/tag/commit/" <fer >fake-fer &&
    -+	git bundle create all.bdl --stdin <fake-fer &&
    -+
    -+	cat >expect <<-EOF &&
    -+	$(git rev-parse divergent) refs/heads/divergent
    -+	$(git rev-parse HEAD) $(git symbolic-ref HEAD)
    -+	$(git rev-parse next) refs/heads/next
    -+	$(git rev-parse trunk) refs/heads/trunk
    -+	$(git rev-parse unstable) refs/heads/unstable
    -+	$(git rev-parse tag) refs/tags/tag
    -+	EOF
    -+
    -+	git bundle list-heads all.bdl >actual &&
    -+	test_cmp expect actual &&
    -+	test_bundle_object_count all.bdl 25
    ++test_expect_success 'oidtree each' '
    ++	echoid "" 123 321 321 >expect &&
    ++	{
    ++		echoid insert f 9 8 123 321 a b c d e
    ++		echo each 12300
    ++		echo each 3211
    ++		echo each 3210
    ++		echo each 32100
    ++		echo clear
    ++	} | test-tool oidtree >actual &&
    ++	test_cmp expect actual
     +'
     +
     +test_done
  -:  ----------- >  35:  8232a0ff48c pkt-line: replace "stateless separator" with "response end"
  -:  ----------- >  36:  54ba2f1862d commit: reorganise commit hint strings
  -:  ----------- >  37:  6f70f00b4f9 commit: remove irrelavent prompt on `--allow-empty-message`
  6:  c428b8086d0 !  38:  d1c5ae78ce1 revision.h: refactor "disable_stdin" and "read_from_stdin"
    @@
      ## Metadata ##
    -Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +Author: brian m. carlson <sandals@crustytoothpaste.net>
     
      ## Commit message ##
    -    revision.h: refactor "disable_stdin" and "read_from_stdin"
    +    rev-list: add option for --pretty=format without header
     
    -    Change the two "disable_stdin" and "read_from_stdin" flags to an enum,
    -    in preparation for a subsequent commit adding more flags.
    +    In general, we encourage users to use plumbing commands, like git
    +    rev-list, over porcelain commands, like git log, when scripting.
    +    However, git rev-list has one glaring problem that prevents it from
    +    being used in certain cases: when --pretty is used with a custom format,
    +    it always prints out a line containing "commit" and the object ID.  This
    +    makes it unsuitable for many scripting needs, and forces users to use
    +    git log instead.
     
    -    The interaction between these is more subtle than they might appear at
    -    first sight, as noted in a12cbe23ef7. "read_stdin" is not the inverse
    -    of "disable_stdin", rather we read stdin if we see the "--stdin"
    -    option.
    +    While we can't change this behavior for backwards compatibility, we can
    +    add an option to suppress this behavior, so let's do so, and call it
    +    "--no-commit-header".  Additionally, add the corresponding positive
    +    option to switch it back on.
     
    -    The "read" is intended to understood as "I've read it already", not
    -    "you should read it". Let's avoid this confusion by using "consume"
    -    and "consumed" instead, i.e. a word whose present and past tense isn't
    -    the same.
    +    Note that this option doesn't affect the built-in formats, only custom
    +    formats.  This is exactly the same behavior as users already have from
    +    git log and is what most users will be used to.
     
    -    See 8b3dce56508 (Teach --stdin option to "log" family, 2009-11-03)
    -    where we added the "disable_stdin" flag, and a12cbe23ef7 (rev-list:
    -    make empty --stdin not an error, 2018-08-22) for the addition of the
    -    "read_from_stdin" flag.
    +    Signed-off-by: brian m. carlson <sandals@crustytoothpaste.net>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    -
    - ## builtin/am.c ##
    -@@ builtin/am.c: static void write_commit_patch(const struct am_state *state, struct commit *comm
    - 	repo_init_revisions(the_repository, &rev_info, NULL);
    - 	rev_info.diff = 1;
    - 	rev_info.abbrev = 0;
    --	rev_info.disable_stdin = 1;
    -+	rev_info.stdin_handling = REV_INFO_STDIN_IGNORE;
    - 	rev_info.show_root_diff = 1;
    - 	rev_info.diffopt.output_format = DIFF_FORMAT_PATCH;
    - 	rev_info.no_commit_id = 1;
    -@@ builtin/am.c: static void write_index_patch(const struct am_state *state)
    - 	fp = xfopen(am_path(state, "patch"), "w");
    - 	repo_init_revisions(the_repository, &rev_info, NULL);
    - 	rev_info.diff = 1;
    --	rev_info.disable_stdin = 1;
    -+	rev_info.stdin_handling = REV_INFO_STDIN_IGNORE;
    - 	rev_info.no_commit_id = 1;
    - 	rev_info.diffopt.output_format = DIFF_FORMAT_PATCH;
    - 	rev_info.diffopt.use_color = 0;
    -
    - ## builtin/blame.c ##
    -@@ builtin/blame.c: int cmd_blame(int argc, const char **argv, const char *prefix)
    - 		argv[argc - 1] = "--";
    - 	}
    - 
    --	revs.disable_stdin = 1;
    -+	revs.stdin_handling = REV_INFO_STDIN_IGNORE;
    - 	setup_revisions(argc, argv, &revs, NULL);
    - 	if (!revs.pending.nr && is_bare_repository()) {
    - 		struct commit *head_commit;
    -
    - ## builtin/diff-tree.c ##
    -@@ builtin/diff-tree.c: int cmd_diff_tree(int argc, const char **argv, const char *prefix)
    - 		die(_("index file corrupt"));
    - 	opt->abbrev = 0;
    - 	opt->diff = 1;
    --	opt->disable_stdin = 1;
    -+	opt->stdin_handling = REV_INFO_STDIN_IGNORE;
    - 	memset(&s_r_opt, 0, sizeof(s_r_opt));
    - 	s_r_opt.tweak = diff_tree_tweak_rev;
    + ## Documentation/rev-list-options.txt ##
    +@@ Documentation/rev-list-options.txt: ifdef::git-rev-list[]
    + --header::
    + 	Print the contents of the commit in raw-format; each record is
    + 	separated with a NUL character.
    ++
    ++--no-commit-header::
    ++	Suppress the header line containing "commit" and the object ID printed before
    ++	the specified format.  This has no effect on the built-in formats; only custom
    ++	formats are affected.
    ++
    ++--commit-header::
    ++	Overrides a previous `--no-commit-header`.
    + endif::git-rev-list[]
      
    + --parents::
     
      ## builtin/rev-list.c ##
    +@@ builtin/rev-list.c: static void show_commit(struct commit *commit, void *data)
    + 	if (info->header_prefix)
    + 		fputs(info->header_prefix, stdout);
    + 
    +-	if (!revs->graph)
    +-		fputs(get_revision_mark(revs, commit), stdout);
    +-	if (revs->abbrev_commit && revs->abbrev)
    +-		fputs(find_unique_abbrev(&commit->object.oid, revs->abbrev),
    +-		      stdout);
    +-	else
    +-		fputs(oid_to_hex(&commit->object.oid), stdout);
    ++	if (revs->include_header) {
    ++		if (!revs->graph)
    ++			fputs(get_revision_mark(revs, commit), stdout);
    ++		if (revs->abbrev_commit && revs->abbrev)
    ++			fputs(find_unique_abbrev(&commit->object.oid, revs->abbrev),
    ++			      stdout);
    ++		else
    ++			fputs(oid_to_hex(&commit->object.oid), stdout);
    ++	}
    + 	if (revs->print_parents) {
    + 		struct commit_list *parents = commit->parents;
    + 		while (parents) {
    +@@ builtin/rev-list.c: static void show_commit(struct commit *commit, void *data)
    + 	show_decorations(revs, commit);
    + 	if (revs->commit_format == CMIT_FMT_ONELINE)
    + 		putchar(' ');
    +-	else
    ++	else if (revs->include_header)
    + 		putchar('\n');
    + 
    + 	if (revs->verbose_header) {
     @@ builtin/rev-list.c: int cmd_rev_list(int argc, const char **argv, const char *prefix)
    - 	if ((!revs.commits && reflog_walk_empty(revs.reflog_info) &&
    - 	     (!(revs.tag_objects || revs.tree_objects || revs.blob_objects) &&
    - 	      !revs.pending.nr) &&
    --	     !revs.rev_input_given && !revs.read_from_stdin) ||
    -+	     !revs.rev_input_given && !revs.consumed_stdin) ||
    - 	    revs.diff)
    - 		usage(rev_list_usage);
    + 	repo_init_revisions(the_repository, &revs, prefix);
    + 	revs.abbrev = DEFAULT_ABBREV;
    + 	revs.commit_format = CMIT_FMT_UNSPECIFIED;
    ++	revs.include_header = 1;
      
    -
    - ## revision.c ##
    -@@ revision.c: int setup_revisions(int argc, const char **argv, struct rev_info *revs, struct s
    - 			}
    + 	/*
    + 	 * Scan the argument list before invoking setup_revisions(), so that we
    +@@ builtin/rev-list.c: int cmd_rev_list(int argc, const char **argv, const char *prefix)
    + 			continue;
    + 		}
      
    - 			if (!strcmp(arg, "--stdin")) {
    --				if (revs->disable_stdin) {
    -+				switch (revs->stdin_handling) {
    -+				case REV_INFO_STDIN_IGNORE:
    - 					argv[left++] = arg;
    - 					continue;
    -+				case REV_INFO_STDIN_CONSUME_ON_OPTION:
    -+					if (revs->consumed_stdin)
    -+						die("--stdin given twice?");
    -+					read_revisions_from_stdin(revs, &prune_data);
    -+					revs->consumed_stdin = 1;
    -+					continue;
    - 				}
    --				if (revs->read_from_stdin++)
    --					die("--stdin given twice?");
    --				read_revisions_from_stdin(revs, &prune_data);
    --				continue;
    - 			}
    ++		if (!strcmp(arg, ("--commit-header"))) {
    ++			revs.include_header = 1;
    ++			continue;
    ++		}
    ++
    ++		if (!strcmp(arg, ("--no-commit-header"))) {
    ++			revs.include_header = 0;
    ++			continue;
    ++		}
    ++
    + 		if (!strcmp(arg, "--disk-usage")) {
    + 			show_disk_usage = 1;
    + 			info.flags |= REV_LIST_QUIET;
    +@@ builtin/rev-list.c: int cmd_rev_list(int argc, const char **argv, const char *prefix)
    + 		usage(rev_list_usage);
      
    - 			if (!strcmp(arg, "--end-of-options")) {
    + 	}
    ++	if (revs.commit_format != CMIT_FMT_USERFORMAT)
    ++		revs.include_header = 1;
    + 	if (revs.commit_format != CMIT_FMT_UNSPECIFIED) {
    + 		/* The command line has a --pretty  */
    + 		info.hdr_termination = '\n';
    +-		if (revs.commit_format == CMIT_FMT_ONELINE)
    ++		if (revs.commit_format == CMIT_FMT_ONELINE || !revs.include_header)
    + 			info.header_prefix = "";
    + 		else
    + 			info.header_prefix = "commit ";
     
      ## revision.h ##
    -@@ revision.h: struct rev_cmdline_info {
    - struct oidset;
    - struct topo_walk_info;
    - 
    -+enum rev_info_stdin {
    -+	REV_INFO_STDIN_CONSUME_ON_OPTION,
    -+	REV_INFO_STDIN_IGNORE,
    -+};
    -+
    - struct rev_info {
    - 	/* Starting list */
    - 	struct commit_list *commits;
    -@@ revision.h: struct rev_info {
    - 	int rev_input_given;
    - 
    - 	/*
    --	 * Whether we read from stdin due to the --stdin option.
    -+	 * How should we handle seeing --stdin?
    -+	 *
    -+	 * Defaults to REV_INFO_STDIN_CONSUME_ON_OPTION where we'll
    -+	 * attempt to read it if we see the --stdin option.
    -+	 *
    -+	 * Can be set to REV_INFO_STDIN_IGNORE to ignore the --stdin
    -+	 * option.
    -+	 */
    -+	enum rev_info_stdin stdin_handling;
    -+
    -+	/*
    -+	 * Did we read from stdin due to stdin_handling ==
    -+	 * REV_INFO_STDIN_CONSUME_ON_OPTION and seeing the --stdin
    -+	 * option?
    - 	 */
    --	int read_from_stdin;
    -+	unsigned int consumed_stdin:1;
    - 
    - 	/* topo-sort */
    - 	enum rev_sort_order sort_order;
     @@ revision.h: struct rev_info {
    + 			missing_newline:1,
      			date_mode_explicit:1,
      			preserve_subject:1,
    - 			encode_email_headers:1;
    --	unsigned int	disable_stdin:1;
    +-			encode_email_headers:1;
    ++			encode_email_headers:1,
    ++			include_header:1;
    + 	unsigned int	disable_stdin:1;
      	/* --show-linear-break */
      	unsigned int	track_linear:1,
    - 			track_first_time:1,
     
    - ## sequencer.c ##
    -@@ sequencer.c: static int make_patch(struct repository *r,
    - 	log_tree_opt.abbrev = 0;
    - 	log_tree_opt.diff = 1;
    - 	log_tree_opt.diffopt.output_format = DIFF_FORMAT_PATCH;
    --	log_tree_opt.disable_stdin = 1;
    -+	log_tree_opt.stdin_handling = REV_INFO_STDIN_IGNORE;
    - 	log_tree_opt.no_commit_id = 1;
    - 	log_tree_opt.diffopt.file = fopen(buf.buf, "w");
    - 	log_tree_opt.diffopt.use_color = GIT_COLOR_NEVER;
    -@@ sequencer.c: static int pick_commits(struct repository *r,
    - 			log_tree_opt.diff = 1;
    - 			log_tree_opt.diffopt.output_format =
    - 				DIFF_FORMAT_DIFFSTAT;
    --			log_tree_opt.disable_stdin = 1;
    -+			log_tree_opt.stdin_handling = REV_INFO_STDIN_IGNORE;
    + ## t/t6006-rev-list-format.sh ##
    +@@ t/t6006-rev-list-format.sh: test_expect_success 'setup' '
    + 	echo "$added_iso88591" | git commit -F - &&
    + 	head1=$(git rev-parse --verify HEAD) &&
    + 	head1_short=$(git rev-parse --verify --short $head1) &&
    ++	head1_short4=$(git rev-parse --verify --short=4 $head1) &&
    + 	tree1=$(git rev-parse --verify HEAD:) &&
    + 	tree1_short=$(git rev-parse --verify --short $tree1) &&
    + 	echo "$changed" > foo &&
    + 	echo "$changed_iso88591" | git commit -a -F - &&
    + 	head2=$(git rev-parse --verify HEAD) &&
    + 	head2_short=$(git rev-parse --verify --short $head2) &&
    ++	head2_short4=$(git rev-parse --verify --short=4 $head2) &&
    + 	tree2=$(git rev-parse --verify HEAD:) &&
    + 	tree2_short=$(git rev-parse --verify --short $tree2) &&
    + 	git config --unset i18n.commitEncoding
    + '
    + 
    +-# usage: test_format name format_string [failure] <expected_output
    ++# usage: test_format [argument...] name format_string [failure] <expected_output
    + test_format () {
    ++	local args=
    ++	while true
    ++	do
    ++		case "$1" in
    ++		--*)
    ++			args="$args $1"
    ++			shift;;
    ++		*)
    ++			break;;
    ++		esac
    ++	done
    + 	cat >expect.$1
    + 	test_expect_${3:-success} "format $1" "
    +-		git rev-list --pretty=format:'$2' main >output.$1 &&
    ++		git rev-list $args --pretty=format:'$2' main >output.$1 &&
    ++		test_cmp expect.$1 output.$1
    ++	"
    ++}
    ++
    ++# usage: test_pretty [argument...] name format_name [failure] <expected_output
    ++test_pretty () {
    ++	local args=
    ++	while true
    ++	do
    ++		case "$1" in
    ++		--*)
    ++			args="$args $1"
    ++			shift;;
    ++		*)
    ++			break;;
    ++		esac
    ++	done
    ++	cat >expect.$1
    ++	test_expect_${3:-success} "pretty $1 (without --no-commit-header)" "
    ++		git rev-list $args --pretty='$2' main >output.$1 &&
    ++		test_cmp expect.$1 output.$1
    ++	"
    ++	test_expect_${3:-success} "pretty $1 (with --no-commit-header)" "
    ++		git rev-list $args --no-commit-header --pretty='$2' main >output.$1 &&
    + 		test_cmp expect.$1 output.$1
    + 	"
    + }
    +@@ t/t6006-rev-list-format.sh: $head1
    + $head1_short
    + EOF
    + 
    ++test_format --no-commit-header hash-no-header %H%n%h <<EOF
    ++$head2
    ++$head2_short
    ++$head1
    ++$head1_short
    ++EOF
    ++
    ++test_format --abbrev-commit --abbrev=0 --no-commit-header hash-no-header-abbrev %H%n%h <<EOF
    ++$head2
    ++$head2_short4
    ++$head1
    ++$head1_short4
    ++EOF
    ++
    + test_format tree %T%n%t <<EOF
    + commit $head2
    + $tree2
    +@@ t/t6006-rev-list-format.sh: $added
    + 
    + EOF
      
    - 			if (read_oneliner(&buf, rebase_path_orig_head(), 0) &&
    - 			    !get_oid(buf.buf, &orig) &&
    ++test_format --no-commit-header raw-body-no-header %B <<EOF
    ++$changed
    ++
    ++$added
    ++
    ++EOF
    ++
    ++test_pretty oneline oneline <<EOF
    ++$head2 $changed
    ++$head1 $added
    ++EOF
    ++
    ++test_pretty short short <<EOF
    ++commit $head2
    ++Author: $GIT_AUTHOR_NAME <$GIT_AUTHOR_EMAIL>
    ++
    ++    $changed
    ++
    ++commit $head1
    ++Author: $GIT_AUTHOR_NAME <$GIT_AUTHOR_EMAIL>
    ++
    ++    $added
    ++
    ++EOF
    ++
    + test_expect_success 'basic colors' '
    + 	cat >expect <<-EOF &&
    + 	commit $head2
  -:  ----------- >  39:  103e02c7001 *.c static functions: don't forward-declare __attribute__
  8:  81c96ca9e7d !  40:  d4ac3050734 pack-objects.c: do stdin parsing via revision.c's API
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    pack-objects.c: do stdin parsing via revision.c's API
    +    sequencer.c: move static function to avoid forward decl
     
    -    Use the new "handle_stdin_line" API in revision.c to parse stdin in
    -    pack-objects.c, instead of using custom pack-objects.c-specific code
    -    to do so.
    -
    -    This means that we can remove the "if (len && line[len - 1] == '\n')"
    -    check, it's now redundant to using strbuf_getline(), and we get to
    -    skip the whole "warn_on_object_refname_ambiguity" dance. The
    -    read_revisions_from_stdin() function in revision.c we're now using
    -    does it for us.
    -
    -    The pack-objects.c code being refactored away here was first added in
    -    Linus's c323ac7d9c5 (git-pack-objects: create a packed object
    -    representation., 2005-06-25).
    -
    -    Later on rev-list started doing similar parsing in 42cabc341c4 (Teach
    -    rev-list an option to read revs from the standard input., 2006-09-05).
    -    That code was promoted to a more general API in 1fc561d169a (Move
    -    read_revisions_from_stdin from builtin-rev-list.c to revision.c,
    -    2008-07-05).
    -
    -    Since then the API in revision.c has received improvements that have
    -    been missed here. E.g. the arbitrary limit of 1000 bytes was removed
    -    in 63d564b3002 (read_revision_from_stdin(): use strbuf, 2009-11-20),
    -    and it moved to a more simpler strbuf API in 6e8d46f9d4b (revision:
    -    read --stdin with strbuf_getline(), 2015-10-28).
    -
    -    For now we've just made setup_revisions() loop over stdin for us, but
    -    the callback we define makes no use of REV_INFO_STDIN_LINE_PROCESS. We
    -    still need to call handle_revision_arg() ourselves because we'd like
    -    to call it with different flags.
    -
    -    This very light use of the API will be further refined in a subsequent
    -    commit, for now we're just doing the bare minimum to move this
    -    existing code over to the new callback pattern without any functional
    -    changes, and making it as friendly to "git show -w" and "the
    -    --color-moved-ws=allow-indentation-change" mode as possible.
    +    Move the reflog_message() function added in
    +    96e832a5fd6 (sequencer (rebase -i): refactor setting the reflog
    +    message, 2017-01-02), it gained another user in
    +    9055e401dd6 (sequencer: introduce new commands to reset the revision,
    +    2018-04-25). Let's move it around and remove the forward declaration
    +    added in the latter commit.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    - ## builtin/pack-objects.c ##
    -@@ builtin/pack-objects.c: static void mark_bitmap_preferred_tips(void)
    - 	}
    + ## sequencer.c ##
    +@@ sequencer.c: static int do_label(struct repository *r, const char *name, int len)
      }
      
    -+static enum rev_info_stdin_line get_object_list_handle_stdin_line(
    -+	struct rev_info *revs, struct strbuf *line_sb, void *stdin_line_priv)
    + static const char *reflog_message(struct replay_opts *opts,
    +-	const char *sub_action, const char *fmt, ...);
    ++	const char *sub_action, const char *fmt, ...)
     +{
    -+	int *flags = stdin_line_priv;
    -+	char *line = line_sb->buf;
    ++	va_list ap;
    ++	static struct strbuf buf = STRBUF_INIT;
    ++	char *reflog_action = getenv(GIT_REFLOG_ACTION);
     +
    -+	if (*line == '-') {
    -+		if (!strcmp(line, "--not")) {
    -+			*flags ^= UNINTERESTING;
    -+			write_bitmap_index = 0;
    -+			return REV_INFO_STDIN_LINE_CONTINUE;
    -+		}
    -+		if (starts_with(line, "--shallow ")) {
    -+			struct object_id oid;
    -+			if (get_oid_hex(line + 10, &oid))
    -+				die("not an object name '%s'", line + 10);
    -+			register_shallow(the_repository, &oid);
    -+			use_bitmap_index = 0;
    -+			return REV_INFO_STDIN_LINE_CONTINUE;
    -+		}
    -+		die(_("not a rev '%s'"), line);
    ++	va_start(ap, fmt);
    ++	strbuf_reset(&buf);
    ++	strbuf_addstr(&buf, reflog_action ? reflog_action : action_name(opts));
    ++	if (sub_action)
    ++		strbuf_addf(&buf, " (%s)", sub_action);
    ++	if (fmt) {
    ++		strbuf_addstr(&buf, ": ");
    ++		strbuf_vaddf(&buf, fmt, ap);
     +	}
    -+	if (handle_revision_arg(line, revs, *flags, REVARG_CANNOT_BE_FILENAME))
    -+			die(_("bad revision '%s'"), line);
    -+	return REV_INFO_STDIN_LINE_CONTINUE;
    -+}
    ++	va_end(ap);
     +
    - static void get_object_list(int ac, const char **av)
    - {
    - 	struct rev_info revs;
    - 	struct setup_revision_opt s_r_opt = {
    - 		.allow_exclude_promisor_objects = 1,
    - 	};
    --	char line[1000];
    - 	int flags = 0;
    --	int save_warning;
    - 
    - 	repo_init_revisions(the_repository, &revs, NULL);
    - 	save_commit_buffer = 0;
    -@@ builtin/pack-objects.c: static void get_object_list(int ac, const char **av)
    - 	/* make sure shallows are read */
    - 	is_repository_shallow(the_repository);
    ++	return buf.buf;
    ++}
      
    -+	revs.stdin_handling = REV_INFO_STDIN_ALWAYS_READ;
    -+	revs.handle_stdin_line = get_object_list_handle_stdin_line;
    -+	revs.stdin_line_priv = &flags;
    - 	setup_revisions(ac, av, &revs, &s_r_opt);
    + static int do_reset(struct repository *r,
    + 		    const char *name, int len,
    +@@ sequencer.c: int apply_autostash_oid(const char *stash_oid)
    + 	return apply_save_autostash_oid(stash_oid, 1);
    + }
      
    --	save_warning = warn_on_object_refname_ambiguity;
    --	warn_on_object_refname_ambiguity = 0;
    +-static const char *reflog_message(struct replay_opts *opts,
    +-	const char *sub_action, const char *fmt, ...)
    +-{
    +-	va_list ap;
    +-	static struct strbuf buf = STRBUF_INIT;
    +-	char *reflog_action = getenv(GIT_REFLOG_ACTION);
     -
    --	while (fgets(line, sizeof(line), stdin) != NULL) {
    --		int len = strlen(line);
    --		if (len && line[len - 1] == '\n')
    --			line[--len] = 0;
    --		if (!len)
    --			break;
    --		if (*line == '-') {
    --			if (!strcmp(line, "--not")) {
    --				flags ^= UNINTERESTING;
    --				write_bitmap_index = 0;
    --				continue;
    --			}
    --			if (starts_with(line, "--shallow ")) {
    --				struct object_id oid;
    --				if (get_oid_hex(line + 10, &oid))
    --					die("not an object name '%s'", line + 10);
    --				register_shallow(the_repository, &oid);
    --				use_bitmap_index = 0;
    --				continue;
    --			}
    --			die(_("not a rev '%s'"), line);
    --		}
    --		if (handle_revision_arg(line, &revs, flags, REVARG_CANNOT_BE_FILENAME))
    --			die(_("bad revision '%s'"), line);
    +-	va_start(ap, fmt);
    +-	strbuf_reset(&buf);
    +-	strbuf_addstr(&buf, reflog_action ? reflog_action : action_name(opts));
    +-	if (sub_action)
    +-		strbuf_addf(&buf, " (%s)", sub_action);
    +-	if (fmt) {
    +-		strbuf_addstr(&buf, ": ");
    +-		strbuf_vaddf(&buf, fmt, ap);
     -	}
    +-	va_end(ap);
     -
    --	warn_on_object_refname_ambiguity = save_warning;
    +-	return buf.buf;
    +-}
     -
    - 	if (use_bitmap_index && !get_object_list_from_bitmap(&revs))
    - 		return;
    - 
    + static int run_git_checkout(struct repository *r, struct replay_opts *opts,
    + 			    const char *commit, const char *action)
    + {
  -:  ----------- >  41:  eb448631fb5 git-diff: fix missing --merge-base docs
  -:  ----------- >  42:  48ca53cac4a *.c static functions: add missing __attribute__((format))
  -:  ----------- >  43:  75d31ceec58 *.h: add a few missing __attribute__((format))
  -:  ----------- >  44:  927dc330705 advice.h: add missing __attribute__((format)) & fix usage
  -:  ----------- >  45:  b1d87fbaf1e doc/rev-list-options: fix duplicate word typo
  -:  ----------- >  46:  f9365c0a24b t2400: clean up '"add" worktree with lock' test
  -:  ----------- >  47:  f7c35ea2a12 worktree: mark lock strings with `_()` for translation
  -:  ----------- >  48:  d1ed8d6cee5 load_ref_decorations(): fix decoration with tags
  -:  ----------- >  49:  e61059660ca ci: run `make sparse` as part of the GitHub workflow
  7:  8a071b5c222 !  50:  fc6609d198c revision.[ch]: add a "handle_stdin_line" API
    @@
      ## Metadata ##
    -Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +Author: Derrick Stolee <dstolee@microsoft.com>
     
      ## Commit message ##
    -    revision.[ch]: add a "handle_stdin_line" API
    +    sparse-index: skip indexes with unmerged entries
     
    -    Extend the rev_info stdin parsing API to support hooking into its
    -    read_revisions_from_stdin() function, in the next commit we'll change
    -    the the custom stdin parsing in pack-objects.c to use it..
    +    The sparse-index format is designed to be compatible with merge
    +    conflicts, even those outside the sparse-checkout definition. The reason
    +    is that when converting a full index to a sparse one, a cache entry with
    +    nonzero stage will not be collapsed into a sparse directory entry.
     
    -    For that use-case adding API is barely justified. We'll be able to
    -    make the handle_revision_arg() static in exchange for it, and we'll
    -    avoid the duplicate dance around setting "save_warning" and
    -    "warn_on_object_refname_ambiguity", but we could just continue to do
    -    that ourselves in builtin/pack-objects.c
    +    However, this behavior was not tested, and a different behavior within
    +    convert_to_sparse() fails in this scenario. Specifically,
    +    cache_tree_update() will fail when unmerged entries exist.
    +    convert_to_sparse_rec() uses the cache-tree data to recursively walk the
    +    tree structure, but also to compute the OIDs used in the
    +    sparse-directory entries.
     
    -    The real reason to add this is for a change not part of this
    -    series. We'll soon teach "git bundle create" to accept
    -    revision/refname pairs on stdin, and thus do away with the limitation
    -    of it being impossible to create bundles with ref tips that don't
    -    correspond to the state of the current repository. I.e. this will
    -    work:
    +    Add an index scan to convert_to_sparse() that will detect if these merge
    +    conflict entries exist and skip the conversion before trying to update
    +    the cache-tree. This is marked as NEEDSWORK because this can be removed
    +    with a suitable update to cache_tree_update() or a similar method that
    +    can construct a cache-tree with invalid nodes, but still allow creating
    +    the nodes necessary for creating sparse directory entries.
     
    -        $ printf "e83c5163316f89bfbde7\trefs/heads/first-git-dot-git-commit\n" |
    -        git bundle create initial.bundle --stdin
    +    It is possible that in the future we will not need to make such an
    +    update, since if we do not expand a sparse-index into a full one, this
    +    conversion does not need to happen. Thus, this can be deferred until the
    +    merge machinery is made to integrate with the sparse-index.
     
    -    As well as things like:
    +    Reviewed-by: Elijah Newren <newren@gmail.com>
    +    Signed-off-by: Derrick Stolee <dstolee@microsoft.com>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    -        $ git for-each-ref 'refs/remotes/origin' |
    -        sed 's!\trefs/remotes/origin/!\trefs/heads/!' |
    -        git bundle create origin.bundle --stdin
    -
    -    In order to do that we'll need to modify the lines we consume on stdin
    -    revision.c (which bundle.c uses already), and be assured that that
    -    stripping extra bundle-specific data from them is the only change in
    -    behavior.
    -
    -    That change will be much more complex if bundle.c needs to start doing
    -    its own stdin parsing again outside of revision.c, it was recently
    -    converted to use revision.c's parsing in 5bb0fd2cab5 (bundle:
    -    arguments can be read from stdin, 2021-01-11)
    -
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    -
    - ## revision.c ##
    -@@ revision.c: static void read_revisions_from_stdin(struct rev_info *revs,
    - 		int len = sb.len;
    - 		if (!len)
    - 			break;
    -+
    -+		if (revs->handle_stdin_line) {
    -+			enum rev_info_stdin_line ret = revs->handle_stdin_line(
    -+				revs, &sb, revs->stdin_line_priv);
    + ## sparse-index.c ##
    +@@ sparse-index.c: int set_sparse_index_config(struct repository *repo, int enable)
    + 	return res;
    + }
    + 
    ++static int index_has_unmerged_entries(struct index_state *istate)
    ++{
    ++	int i;
    ++	for (i = 0; i < istate->cache_nr; i++) {
    ++		if (ce_stage(istate->cache[i]))
    ++			return 1;
    ++	}
     +
    -+			switch (ret) {
    -+			case REV_INFO_STDIN_LINE_PROCESS:
    -+				break;
    -+			case REV_INFO_STDIN_LINE_CONTINUE:
    -+				continue;
    -+			}
    -+		}
    ++	return 0;
    ++}
     +
    - 		if (sb.buf[0] == '-') {
    - 			if (len == 2 && sb.buf[1] == '-') {
    - 				seen_dashdash = 1;
    -@@ revision.c: int setup_revisions(int argc, const char **argv, struct rev_info *revs, struct s
    - 
    - 			if (!strcmp(arg, "--stdin")) {
    - 				switch (revs->stdin_handling) {
    -+				case REV_INFO_STDIN_ALWAYS_READ:
    - 				case REV_INFO_STDIN_IGNORE:
    - 					argv[left++] = arg;
    - 					continue;
    -@@ revision.c: int setup_revisions(int argc, const char **argv, struct rev_info *revs, struct s
    - 		}
    + int convert_to_sparse(struct index_state *istate)
    + {
    + 	int test_env;
    +@@ sparse-index.c: int convert_to_sparse(struct index_state *istate)
    + 		return -1;
      	}
      
     +	/*
    -+	 * We're asked to ALWAYS_READ from stdin, but no --stdin
    -+	 * option (or "consumed_stdin" would be set).
    ++	 * NEEDSWORK: If we have unmerged entries, then stay full.
    ++	 * Unmerged entries prevent the cache-tree extension from working.
     +	 */
    -+	if (!revs->consumed_stdin &&
    -+	    revs->stdin_handling == REV_INFO_STDIN_ALWAYS_READ)
    -+		read_revisions_from_stdin(revs, &prune_data);
    ++	if (index_has_unmerged_entries(istate))
    ++		return 0;
     +
    - 	if (prune_data.nr) {
    - 		/*
    - 		 * If we need to introduce the magic "a lone ':' means no
    + 	if (cache_tree_update(istate, 0)) {
    + 		warning(_("unable to update cache-tree, staying full"));
    + 		return -1;
     
    - ## revision.h ##
    -@@ revision.h: struct topo_walk_info;
    - enum rev_info_stdin {
    - 	REV_INFO_STDIN_CONSUME_ON_OPTION,
    - 	REV_INFO_STDIN_IGNORE,
    -+	REV_INFO_STDIN_ALWAYS_READ,
    - };
    + ## t/t1092-sparse-checkout-compatibility.sh ##
    +@@ t/t1092-sparse-checkout-compatibility.sh: test_expect_success 'merge with outside renames' '
    + 	done
    + '
      
    -+enum rev_info_stdin_line {
    -+	REV_INFO_STDIN_LINE_PROCESS,
    -+	REV_INFO_STDIN_LINE_CONTINUE,
    -+};
    ++# Sparse-index fails to convert the index in the
    ++# final 'git cherry-pick' command.
    ++test_expect_success 'cherry-pick with conflicts' '
    ++	init_repos &&
     +
    -+typedef enum rev_info_stdin_line (*rev_info_stdin_line_func)(
    -+	struct rev_info *revs, struct strbuf *line, void *stdin_line_priv);
    ++	write_script edit-conflict <<-\EOF &&
    ++	echo $1 >conflict
    ++	EOF
     +
    - struct rev_info {
    - 	/* Starting list */
    - 	struct commit_list *commits;
    -@@ revision.h: struct rev_info {
    - 	 *
    - 	 * Can be set to REV_INFO_STDIN_IGNORE to ignore the --stdin
    - 	 * option.
    -+	 *
    -+	 * Set it to REV_INFO_STDIN_ALWAYS_READ if there's always data
    -+	 * on stdin to be read, even if no --stdin option is provided.
    - 	 */
    - 	enum rev_info_stdin stdin_handling;
    - 
    -@@ revision.h: struct rev_info {
    - 	 */
    - 	unsigned int consumed_stdin:1;
    - 
    -+	/*
    -+	 * When reading from stdin (see "stdin_handling" above) define
    -+	 * a handle_stdin_line function to consume the lines.
    -+	 *
    -+	 * - Return REV_INFO_STDIN_LINE_PROCESS to continue
    -+	 *   revision.c's normal processing of the line (after
    -+	 *   possibly munging the provided strbuf).
    -+	 *
    -+	 * - Return REV_INFO_STDIN_LINE_CONTINUE to indicate that the
    -+	 *   line is fully processed, moving onto the next line (if
    -+	 *   any)
    -+	 *
    -+	 * Use the "stdin_line_priv" to optionally pass your own data
    -+	 * around.
    -+	 */
    -+	rev_info_stdin_line_func handle_stdin_line;
    -+	void *stdin_line_priv;
    ++	test_all_match git checkout -b to-cherry-pick &&
    ++	run_on_all ../edit-conflict ABC &&
    ++	test_all_match git add conflict &&
    ++	test_all_match git commit -m "conflict to pick" &&
    ++
    ++	test_all_match git checkout -B base HEAD~1 &&
    ++	run_on_all ../edit-conflict DEF &&
    ++	test_all_match git add conflict &&
    ++	test_all_match git commit -m "conflict in base" &&
    ++
    ++	test_all_match test_must_fail git cherry-pick to-cherry-pick
    ++'
     +
    - 	/* topo-sort */
    - 	enum rev_sort_order sort_order;
    + test_expect_success 'clean' '
    + 	init_repos &&
      
  -:  ----------- >  51:  47410778fbd sparse-index: include EXTENDED flag when expanding
  -:  ----------- >  52:  3d814b5dc05 t1092: replace incorrect 'echo' with 'cat'
  -:  ----------- >  53:  e669ffb2b8f t1092: expand repository data shape
  -:  ----------- >  54:  bf26c06f126 t1092: add tests for status/add and sparse files
  -:  ----------- >  55:  17a1bb570bc unpack-trees: preserve cache_bottom
  -:  ----------- >  56:  cd807a5cdab unpack-trees: compare sparse directories correctly
  -:  ----------- >  57:  bd6a3fd7f1a unpack-trees: rename unpack_nondirectories()
  9:  0558caf3da9 !  58:  523506df51e pack-objects.c: make use of REV_INFO_STDIN_LINE_PROCESS
    @@
      ## Metadata ##
    -Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +Author: Derrick Stolee <dstolee@microsoft.com>
     
      ## Commit message ##
    -    pack-objects.c: make use of REV_INFO_STDIN_LINE_PROCESS
    +    unpack-trees: unpack sparse directory entries
     
    -    Continue the work started in the preceding commit of porting
    -    pack-objects.c over to the new handle_stdin_line callback pattern. The
    -    common case for the users of this API is to do some of their own
    -    parsing or munging, and then have handle_revision_arg() handle the
    -    rest.
    +    During unpack_callback(), index entries are compared against tree
    +    entries. These are matched according to names and types. One goal is to
    +    decide if we should recurse into subtrees or simply operate on one index
    +    entry.
     
    -    The existing users of the --stdin parsing always wanted a flag of "0"
    -    to be passed to handle_revision_arg(), but pack-objects.c wants to set
    -    custom flags. Let's support this common case by having a
    -    "revarg_flags" member in the "rev_info" struct.
    +    In the case of a sparse-directory entry, we do not want to recurse into
    +    that subtree and instead simply compare the trees. In some cases, we
    +    might want to perform a merge operation on the entry, such as during
    +    'git checkout <commit>' which wants to replace a sparse tree entry with
    +    the tree for that path at the target commit. We extend the logic within
    +    unpack_single_entry() to create a sparse-directory entry in this case,
    +    and then that is sent to call_unpack_fn().
     
    -    This allows us to return REV_INFO_STDIN_LINE_PROCESS in the new
    -    get_object_list_handle_stdin_line() instead of
    -    REV_INFO_STDIN_LINE_CONTINUE, as read_revisions_from_stdin() will now
    -    pass down the right flag for us.
    +    There are some subtleties in this process. For instance, we need to
    +    update find_cache_entry() to allow finding a sparse-directory entry that
    +    exactly matches a given path. Use the new helper method
    +    sparse_dir_matches_path() for this. We also need to ignore conflict
    +    markers in the case that the entries correspond to directories and we
    +    already have a sparse directory entry.
     
    -    I considered making the "--not" parsing be another flag handled by the
    -    revision.c API itself, but since there's only one caller who wants
    -    this, and the "write_bitmap_index = 0" case is more specific than
    -    marking things UNINTERESTING I think it's better to handle it with a
    -    more general mechanism.
    +    Reviewed-by: Elijah Newren <newren@gmail.com>
    +    Signed-off-by: Derrick Stolee <dstolee@microsoft.com>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    -    These changes means that we can make the handle_revision_arg()
    -    function static. Now that the only external user of the API has been
    -    migrated over to the callback mechanism nothing external to revision.c
    -    needs to call handle_revision_arg() anymore.
    -
    -    That handle_revision_arg() function was made public in a combination
    -    of 5d6f0935e6d (revision.c: allow injecting revision parameters after
    -    setup_revisions()., 2006-09-05) and b5d97e6b0a0 (pack-objects: run
    -    rev-list equivalent internally., 2006-09-04).
    -
    -    This change leaves the briefly-used in preceding commits
    -    "void *stdin_line_priv" without any in-tree user, as
    -    builtin/pack-objects.c could be ported over to our new "revarg_flags"
    -    common case.
    -
    -    I'm leaving that "void *stdin_line_priv" in place anyway for two
    -    reasons:
    -
    -     1. It's a common pattern to allow such a "void *" to be used for
    -        callback data, so we might as well follow that pattern here in
    -        anticipation of a future in-tree user.
    -
    -     2. I have patches for such an in-tree user already in a series
    -        that'll be submitted after this one. See the reference to "git
    -        bundle create --stdin" in the commit that added the "handle_stdin_line"
    -        API.
    -
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    -
    - ## builtin/pack-objects.c ##
    -@@ builtin/pack-objects.c: static void mark_bitmap_preferred_tips(void)
    - static enum rev_info_stdin_line get_object_list_handle_stdin_line(
    - 	struct rev_info *revs, struct strbuf *line_sb, void *stdin_line_priv)
    + ## unpack-trees.c ##
    +@@ unpack-trees.c: static struct cache_entry *create_ce_entry(const struct traverse_info *info,
    + 	const struct name_entry *n,
    + 	int stage,
    + 	struct index_state *istate,
    +-	int is_transient)
    ++	int is_transient,
    ++	int is_sparse_directory)
      {
    --	int *flags = stdin_line_priv;
    - 	char *line = line_sb->buf;
    + 	size_t len = traverse_path_len(info, tree_entry_len(n));
    ++	size_t alloc_len = is_sparse_directory ? len + 1 : len;
    + 	struct cache_entry *ce =
    + 		is_transient ?
    +-		make_empty_transient_cache_entry(len, NULL) :
    +-		make_empty_cache_entry(istate, len);
    ++		make_empty_transient_cache_entry(alloc_len, NULL) :
    ++		make_empty_cache_entry(istate, alloc_len);
    + 
    + 	ce->ce_mode = create_ce_mode(n->mode);
    + 	ce->ce_flags = create_ce_flags(stage);
    +@@ unpack-trees.c: static struct cache_entry *create_ce_entry(const struct traverse_info *info,
    + 	/* len+1 because the cache_entry allocates space for NUL */
    + 	make_traverse_path(ce->name, len + 1, info, n->path, n->pathlen);
      
    --	if (*line == '-') {
    --		if (!strcmp(line, "--not")) {
    --			*flags ^= UNINTERESTING;
    --			write_bitmap_index = 0;
    --			return REV_INFO_STDIN_LINE_CONTINUE;
    --		}
    --		if (starts_with(line, "--shallow ")) {
    --			struct object_id oid;
    --			if (get_oid_hex(line + 10, &oid))
    --				die("not an object name '%s'", line + 10);
    --			register_shallow(the_repository, &oid);
    --			use_bitmap_index = 0;
    --			return REV_INFO_STDIN_LINE_CONTINUE;
    --		}
    -+	if (*line != '-')
    -+		return REV_INFO_STDIN_LINE_PROCESS;
    ++	if (is_sparse_directory) {
    ++		ce->name[len] = '/';
    ++		ce->name[len + 1] = '\0';
    ++		ce->ce_namelen++;
    ++		ce->ce_flags |= CE_SKIP_WORKTREE;
    ++	}
     +
    -+	if (!strcmp(line, "--not")) {
    -+		revs->revarg_flags ^= UNINTERESTING;
    -+		write_bitmap_index = 0;
    -+		return REV_INFO_STDIN_LINE_CONTINUE;
    -+	} else if (starts_with(line, "--shallow ")) {
    -+		struct object_id oid;
    -+		if (get_oid_hex(line + 10, &oid))
    -+			die("not an object name '%s'", line + 10);
    -+		register_shallow(the_repository, &oid);
    -+		use_bitmap_index = 0;
    -+		return REV_INFO_STDIN_LINE_CONTINUE;
    -+	} else {
    - 		die(_("not a rev '%s'"), line);
    - 	}
    --	if (handle_revision_arg(line, revs, *flags, REVARG_CANNOT_BE_FILENAME))
    --			die(_("bad revision '%s'"), line);
    --	return REV_INFO_STDIN_LINE_CONTINUE;
    + 	return ce;
      }
      
    - static void get_object_list(int ac, const char **av)
    -@@ builtin/pack-objects.c: static void get_object_list(int ac, const char **av)
    - 	struct setup_revision_opt s_r_opt = {
    - 		.allow_exclude_promisor_objects = 1,
    - 	};
    --	int flags = 0;
    +@@ unpack-trees.c: static int unpack_single_entry(int n, unsigned long mask,
    + 	struct unpack_trees_options *o = info->data;
    + 	unsigned long conflicts = info->df_conflicts | dirmask;
      
    - 	repo_init_revisions(the_repository, &revs, NULL);
    - 	save_commit_buffer = 0;
    -@@ builtin/pack-objects.c: static void get_object_list(int ac, const char **av)
    +-	/* Do we have *only* directories? Nothing to do */
    + 	if (mask == dirmask && !src[0])
    + 		return 0;
      
    - 	revs.stdin_handling = REV_INFO_STDIN_ALWAYS_READ;
    - 	revs.handle_stdin_line = get_object_list_handle_stdin_line;
    --	revs.stdin_line_priv = &flags;
    - 	setup_revisions(ac, av, &revs, &s_r_opt);
    ++	/*
    ++	 * When we have a sparse directory entry for src[0],
    ++	 * then this isn't necessarily a directory-file conflict.
    ++	 */
    ++	if (mask == dirmask && src[0] &&
    ++	    S_ISSPARSEDIR(src[0]->ce_mode))
    ++		conflicts = 0;
    ++
    + 	/*
    + 	 * Ok, we've filled in up to any potential index entry in src[0],
    + 	 * now do the rest.
    +@@ unpack-trees.c: static int unpack_single_entry(int n, unsigned long mask,
    + 		 * not stored in the index.  otherwise construct the
    + 		 * cache entry from the index aware logic.
    + 		 */
    +-		src[i + o->merge] = create_ce_entry(info, names + i, stage, &o->result, o->merge);
    ++		src[i + o->merge] = create_ce_entry(info, names + i, stage,
    ++						    &o->result, o->merge,
    ++						    bit & dirmask);
    + 	}
      
    - 	if (use_bitmap_index && !get_object_list_from_bitmap(&revs))
    -
    - ## revision.c ##
    -@@ revision.c: static int handle_revision_arg_1(const char *arg_, struct rev_info *revs, int fl
    - 	return 0;
    + 	if (o->merge) {
    +@@ unpack-trees.c: static int find_cache_pos(struct traverse_info *info,
    + 	return -1;
      }
      
    --int handle_revision_arg(const char *arg, struct rev_info *revs, int flags, unsigned revarg_opt)
    -+static int handle_revision_arg(const char *arg, struct rev_info *revs, int flags, unsigned revarg_opt)
    ++/*
    ++ * Given a sparse directory entry 'ce', compare ce->name to
    ++ * info->name + '/' + p->path + '/' if info->name is non-empty.
    ++ * Compare ce->name to p->path + '/' otherwise. Note that
    ++ * ce->name must end in a trailing '/' because it is a sparse
    ++ * directory entry.
    ++ */
    ++static int sparse_dir_matches_path(const struct cache_entry *ce,
    ++				   struct traverse_info *info,
    ++				   const struct name_entry *p)
    ++{
    ++	assert(S_ISSPARSEDIR(ce->ce_mode));
    ++	assert(ce->name[ce->ce_namelen - 1] == '/');
    ++
    ++	if (info->namelen)
    ++		return ce->ce_namelen == info->namelen + p->pathlen + 2 &&
    ++		       ce->name[info->namelen] == '/' &&
    ++		       !strncmp(ce->name, info->name, info->namelen) &&
    ++		       !strncmp(ce->name + info->namelen + 1, p->path, p->pathlen);
    ++	return ce->ce_namelen == p->pathlen + 1 &&
    ++	       !strncmp(ce->name, p->path, p->pathlen);
    ++}
    ++
    + static struct cache_entry *find_cache_entry(struct traverse_info *info,
    + 					    const struct name_entry *p)
      {
    - 	int ret = handle_revision_arg_1(arg, revs, flags, revarg_opt);
    - 	if (!ret)
    -@@ revision.c: static void read_revisions_from_stdin(struct rev_info *revs,
    ++	struct cache_entry *ce;
    + 	int pos = find_cache_pos(info, p->path, p->pathlen);
    + 	struct unpack_trees_options *o = info->data;
    + 
    + 	if (0 <= pos)
    + 		return o->src_index->cache[pos];
    +-	else
    ++
    ++	/*
    ++	 * Check for a sparse-directory entry named "path/".
    ++	 * Due to the input p->path not having a trailing
    ++	 * slash, the negative 'pos' value overshoots the
    ++	 * expected position, hence "-2" instead of "-1".
    ++	 */
    ++	pos = -pos - 2;
    ++
    ++	if (pos < 0 || pos >= o->src_index->cache_nr)
    + 		return NULL;
    ++
    ++	/*
    ++	 * Due to lexicographic sorting and sparse directory
    ++	 * entries ending with a trailing slash, our path as a
    ++	 * sparse directory (e.g "subdir/") and	our path as a
    ++	 * file (e.g. "subdir") might be separated by other
    ++	 * paths (e.g. "subdir-").
    ++	 */
    ++	while (pos >= 0) {
    ++		ce = o->src_index->cache[pos];
    ++
    ++		if (strncmp(ce->name, p->path, p->pathlen))
    ++			return NULL;
    ++
    ++		if (S_ISSPARSEDIR(ce->ce_mode) &&
    ++		    sparse_dir_matches_path(ce, info, p))
    ++			return ce;
    ++
    ++		pos--;
    ++	}
    ++
    ++	return NULL;
    + }
    + 
    + static void debug_path(struct traverse_info *info)
    +@@ unpack-trees.c: static void debug_unpack_callback(int n,
    + 		debug_name_entry(i, names + i);
    + }
    + 
    ++/*
    ++ * Returns true if and only if the given cache_entry is a
    ++ * sparse-directory entry that matches the given name_entry
    ++ * from the tree walk at the given traverse_info.
    ++ */
    ++static int is_sparse_directory_entry(struct cache_entry *ce,
    ++				     struct name_entry *name,
    ++				     struct traverse_info *info)
    ++{
    ++	if (!ce || !name || !S_ISSPARSEDIR(ce->ce_mode))
    ++		return 0;
    ++
    ++	return sparse_dir_matches_path(ce, info, name);
    ++}
    ++
    + /*
    +  * Note that traverse_by_cache_tree() duplicates some logic in this function
    +  * without actually calling it. If you change the logic here you may need to
    +@@ unpack-trees.c: static int unpack_callback(int n, unsigned long mask, unsigned long dirmask, str
      			}
    - 			die("options not supported in --stdin mode");
      		}
    --		if (handle_revision_arg(sb.buf, revs, 0,
    -+		if (handle_revision_arg(sb.buf, revs, revs->revarg_flags,
    - 					REVARG_CANNOT_BE_FILENAME))
    - 			die("bad revision '%s'", sb.buf);
    - 	}
    -
    - ## revision.h ##
    -@@ revision.h: struct rev_info {
    - 	 *   revision.c's normal processing of the line (after
    - 	 *   possibly munging the provided strbuf).
    - 	 *
    -+	 *   Change "revarg_flags" to affect the subsequent handling
    -+	 *   in handle_revision_arg()
    -+	 *
    - 	 * - Return REV_INFO_STDIN_LINE_CONTINUE to indicate that the
    - 	 *   line is fully processed, moving onto the next line (if
    - 	 *   any)
    -@@ revision.h: struct rev_info {
    - 	 * around.
    - 	 */
    - 	rev_info_stdin_line_func handle_stdin_line;
    -+	int revarg_flags;
    - 	void *stdin_line_priv;
      
    - 	/* topo-sort */
    -@@ revision.h: void parse_revision_opt(struct rev_info *revs, struct parse_opt_ctx_t *ctx,
    - 			const char * const usagestr[]);
    - #define REVARG_CANNOT_BE_FILENAME 01
    - #define REVARG_COMMITTISH 02
    --int handle_revision_arg(const char *arg, struct rev_info *revs,
    --			int flags, unsigned revarg_opt);
    +-		if (traverse_trees_recursive(n, dirmask, mask & ~dirmask,
    +-					     names, info) < 0)
    ++		if (!is_sparse_directory_entry(src[0], names, info) &&
    ++		    traverse_trees_recursive(n, dirmask, mask & ~dirmask,
    ++						    names, info) < 0) {
    + 			return -1;
    ++		}
    ++
    + 		return mask;
    + 	}
      
    - /**
    -  * Reset the flags used by the revision walking api. You can use this to do
 13:  d40be975688 !  59:  69bdbdb0ee2 revision.h: add an "again" return value to "handle_stdin_line"
    @@
      ## Metadata ##
    -Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +Author: Derrick Stolee <dstolee@microsoft.com>
     
      ## Commit message ##
    -    revision.h: add an "again" return value to "handle_stdin_line"
    +    dir.c: accept a directory as part of cone-mode patterns
     
    -    In my recent in-flight commit to add a new API to revision.h's parsing
    -    API (pack-objects.c: do stdin parsing via revision.c's API,
    -    2021-06-03) I added the ability to specify a handle_stdin_line()
    -    callback.
    +    When we have sparse directory entries in the index, we want to compare
    +    that directory against sparse-checkout patterns. Those pattern matching
    +    algorithms are built expecting a file path, not a directory path. This
    +    is especially important in the "cone mode" patterns which will match
    +    files that exist within the "parent directories" as well as the
    +    recursive directory matches.
     
    -    That callback has the limitation that you can't see what's happened
    -    after handle_revision_arg() has been called, i.e. what pending commits
    -    it has added, or to act on that set of pending commits.
    +    If path_matches_pattern_list() is given a directory, we can add a fake
    +    filename ("-") to the directory and get the same results as before,
    +    assuming we are in cone mode. Since sparse index requires cone mode
    +    patterns, this is an acceptable assumption.
     
    -    One way to solve this would be to make handle_revision_arg()
    -    non-static again, and do our own line parsing, calling of it, and
    -    "seen_dashdash" handling.
    +    Reviewed-by: Elijah Newren <newren@gmail.com>
    +    Signed-off-by: Derrick Stolee <dstolee@microsoft.com>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    -    I think a better approach is to allow the callback to return a "call
    -    me again before the next line" value. We'll then call the callback
    -    again, and it's expected to return a "continue". The callback will be
    -    responsible for keeping its own state of whether it's being called the
    -    first or second time via its "stdin_line_priv".
    -
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    -
    - ## revision.c ##
    -@@ revision.c: static void read_revisions_from_stdin(struct rev_info *revs,
    - 	strbuf_init(&sb, 1000);
    - 	while (strbuf_getline(&sb, stdin) != EOF) {
    - 		int len = sb.len;
    -+		int do_again = 0;
    - 		if (!len)
    - 			break;
    + ## dir.c ##
    +@@ dir.c: enum pattern_match_result path_matches_pattern_list(
    + 	struct path_pattern *pattern;
    + 	struct strbuf parent_pathname = STRBUF_INIT;
    + 	int result = NOT_MATCHED;
    +-	const char *slash_pos;
    ++	size_t slash_pos;
      
    -+	line_cb:
    - 		if (revs->handle_stdin_line) {
    - 			enum rev_info_stdin_line ret = revs->handle_stdin_line(
    - 				revs, &sb, revs->stdin_line_priv);
    + 	if (!pl->use_cone_patterns) {
    + 		pattern = last_matching_pattern_from_list(pathname, pathlen, basename,
    +@@ dir.c: enum pattern_match_result path_matches_pattern_list(
    + 	strbuf_addch(&parent_pathname, '/');
    + 	strbuf_add(&parent_pathname, pathname, pathlen);
      
    -+			if (do_again && ret != REV_INFO_STDIN_LINE_CONTINUE)
    -+				BUG("a handle_stdin_line callback must return "
    -+				    "*_CONTINUE if doing *_AGAIN processing");
    ++	/*
    ++	 * Directory entries are matched if and only if a file
    ++	 * contained immediately within them is matched. For the
    ++	 * case of a directory entry, modify the path to create
    ++	 * a fake filename within this directory, allowing us to
    ++	 * use the file-base matching logic in an equivalent way.
    ++	 */
    ++	if (parent_pathname.len > 0 &&
    ++	    parent_pathname.buf[parent_pathname.len - 1] == '/') {
    ++		slash_pos = parent_pathname.len - 1;
    ++		strbuf_add(&parent_pathname, "-", 1);
    ++	} else {
    ++		const char *slash_ptr = strrchr(parent_pathname.buf, '/');
    ++		slash_pos = slash_ptr ? slash_ptr - parent_pathname.buf : 0;
    ++	}
     +
    - 			switch (ret) {
    - 			case REV_INFO_STDIN_LINE_PROCESS:
    - 				break;
    -+			case REV_INFO_STDIN_LINE_AGAIN:
    -+				do_again = 1;
    -+				break;
    - 			case REV_INFO_STDIN_LINE_CONTINUE:
    - 				continue;
    - 			}
    -@@ revision.c: static void read_revisions_from_stdin(struct rev_info *revs,
    - 		if (handle_revision_arg(sb.buf, revs, revs->revarg_flags,
    - 					REVARG_CANNOT_BE_FILENAME))
    - 			die("bad revision '%s'", sb.buf);
    -+		if (do_again)
    -+			/*
    -+			 * On *_AGAIN the callback wants to update its
    -+			 * state after our handle_revision_arg().
    -+			 */
    -+			goto line_cb;
    + 	if (hashmap_contains_path(&pl->recursive_hashmap,
    + 				  &parent_pathname)) {
    + 		result = MATCHED_RECURSIVE;
    + 		goto done;
      	}
    - 	if (seen_dashdash)
    - 		read_pathspec_from_stdin(&sb, prune);
    -
    - ## revision.h ##
    -@@ revision.h: enum rev_info_stdin {
    - enum rev_info_stdin_line {
    - 	REV_INFO_STDIN_LINE_PROCESS,
    - 	REV_INFO_STDIN_LINE_CONTINUE,
    -+	REV_INFO_STDIN_LINE_AGAIN,
    - };
      
    - typedef enum rev_info_stdin_line (*rev_info_stdin_line_func)(
    -@@ revision.h: struct rev_info {
    - 	 *   line is fully processed, moving onto the next line (if
    - 	 *   any)
    - 	 *
    -+	 * - Return REV_INFO_STDIN_LINE_AGAIN after a callback that's
    -+	 *   returned *_PROCESS to have the callback called again
    -+	 *   after this API has done its own parsing of the line,
    -+	 *   i.e. called handle_revision_arg().
    -+	 *
    -+	 *   The callback must return REV_INFO_STDIN_LINE_CONTINUE
    -+	 *   when called as a result of asking to be called again.
    -+	 *
    - 	 * Use the "stdin_line_priv" to optionally pass your own data
    --	 * around.
    -+	 * around, and when using *_AGAIN to track in when your
    -+	 * callback is being called.
    - 	 */
    - 	rev_info_stdin_line_func handle_stdin_line;
    - 	int revarg_flags;
    +-	slash_pos = strrchr(parent_pathname.buf, '/');
    +-
    +-	if (slash_pos == parent_pathname.buf) {
    ++	if (!slash_pos) {
    + 		/* include every file in root */
    + 		result = MATCHED;
    + 		goto done;
    + 	}
    + 
    +-	strbuf_setlen(&parent_pathname, slash_pos - parent_pathname.buf);
    ++	strbuf_setlen(&parent_pathname, slash_pos);
    + 
    + 	if (hashmap_contains_path(&pl->parent_hashmap, &parent_pathname)) {
    + 		result = MATCHED;
  -:  ----------- >  60:  9eb00af5627 diff-lib: handle index diffs with sparse dirs
  -:  ----------- >  61:  bf48e5acdbf status: skip sparse-checkout percentage with sparse-index
  -:  ----------- >  62:  d76723ee531 status: use sparse-index throughout
  -:  ----------- >  63:  fe0d5761531 wt-status: expand added sparse directory entries
  -:  ----------- >  64:  f8fe49e5395 fsmonitor: integrate with sparse index
 11:  a0f95ce3a1d !  65:  e5ca291076a bundle doc: elaborate on object prerequisites
    @@
      ## Metadata ##
    -Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +Author: Derrick Stolee <dstolee@microsoft.com>
     
      ## Commit message ##
    -    bundle doc: elaborate on object prerequisites
    +    t1092: document bad sparse-checkout behavior
     
    -    Split out the discussion bout "object prerequisites" into its own
    -    section, and add some more examples of the common cases.
    +    There are several situations where a repository with sparse-checkout
    +    enabled will act differently than a normal repository, and in ways that
    +    are not intentional. The test t1092-sparse-checkout-compatibility.sh
    +    documents some of these deviations, but a casual reader might think
    +    these are intentional behavior changes.
     
    -    See 2e0afafebd (Add git-bundle: move objects and references by
    -    archive, 2007-02-22) for the introduction of the documentation being
    -    changed here.
    +    Add comments on these tests that make it clear that these behaviors
    +    should be updated. Using 'NEEDSWORK' helps contributors find that these
    +    are potential areas for improvement.
     
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +    Helped-by: Elijah Newren <newren@gmail.com>
    +    Reviewed-by: Elijah Newren <newren@gmail.com>
    +    Signed-off-by: Derrick Stolee <dstolee@microsoft.com>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    - ## Documentation/git-bundle.txt ##
    -@@ Documentation/git-bundle.txt: header is (mostly) in the format emitted by linkgit:git-show-ref[1].
    + ## t/t1092-sparse-checkout-compatibility.sh ##
    +@@ t/t1092-sparse-checkout-compatibility.sh: test_expect_failure 'blame with pathspec outside sparse definition' '
    + 	test_all_match git blame deep/deeper2/deepest/a
    + '
      
    - Like the the packed archive format itself bundles can either be
    - self-contained, or be created using exclusions.
    -+See the "OBJECT PREREQUISITES" section below.
    +-# TODO: reset currently does not behave as expected when in a
    +-# sparse-checkout.
    ++# NEEDSWORK: a sparse-checkout behaves differently from a full checkout
    ++# in this scenario, but it shouldn't.
    + test_expect_failure 'checkout and reset (mixed)' '
    + 	init_repos &&
      
    - Bundles created using revision exclusions are "thin packs" created
    - using the `--thin` option to linkgit:git-pack-objects[1], and
    -@@ Documentation/git-bundle.txt: contained in the union of the given bases.  Each basis can be
    - specified explicitly (e.g. `^master~10`), or implicitly (e.g.
    - `master~10..master`, `--since=10.days.ago master`).
    +@@ t/t1092-sparse-checkout-compatibility.sh: test_expect_failure 'checkout and reset (mixed)' '
    + 	test_all_match git reset update-folder2
    + '
      
    --It is very important that the basis used be held by the destination.
    -+OBJECT PREREQUISITES
    -+--------------------
    -+
    -+When creating bundles it is possible to create a self-contained bundle
    -+that can be unbundled in a repository with no common history, as well
    -+as providing negative revisions to exclude objects needed in the
    -+earlier parts of the history.
    -+
    -+Feeding a revision such as `new` to `git bundle create` will create a
    -+bundle file that contains all the objects reachable from the revision
    -+`new`. That bundle can be unbundled in any repository to obtain a full
    -+history that leads to the revision `new`:
    -+
    -+----------------
    -+$ git bundle create full.bundle new
    -+----------------
    -+
    -+A revision range such as `old..new` will produce a bundle tip that'll
    -+that'll require the revision `old` (and any objects reachable from it)
    -+to exist for the bundle to be "unbundle"-able:
    -+
    -+----------------
    -+$ git bundle create full.bundle old..new
    -+----------------
    -+
    -+A self-contained bundle without any prerequisites can be extracted
    -+into anywhere, even into an empty repository, or be cloned from
    -+(i.e., `new`, but not `old..new`).
    -+
    - It is okay to err on the side of caution, causing the bundle file
    - to contain objects already in the destination, as these are ignored
    - when unpacking at the destination.
    +-# Ensure that sparse-index behaves identically to
    +-# sparse-checkout with a full index.
    ++# NEEDSWORK: a sparse-checkout behaves differently from a full checkout
    ++# in this scenario, but it shouldn't.
    + test_expect_success 'checkout and reset (mixed) [sparse]' '
    + 	init_repos &&
      
    --`git clone` can use any bundle created without negative refspecs
    --(e.g., `new`, but not `old..new`).
    - If you want to match `git clone --mirror`, which would include your
    - refs such as `refs/remotes/*`, use `--all`.
    - If you want to provide the same set of refs that a clone directly
    - from the source repository would get, use `--branches --tags` for
    - the `<git-rev-list-args>`.
    +@@ t/t1092-sparse-checkout-compatibility.sh: test_expect_success 'sparse-index is not expanded' '
    + 	test_region ! index ensure_full_index trace2.txt
    + '
      
    -+The 'git bundle verify' command can be used to check whether your
    -+recipient repository has the required prerequisite commits for a
    -+bundle.
    -+
    - EXAMPLES
    - --------
    ++# NEEDSWORK: a sparse-checkout behaves differently from a full checkout
    ++# in this scenario, but it shouldn't.
    + test_expect_success 'reset mixed and checkout orphan' '
    + 	init_repos &&
      
  -:  ----------- >  66:  cc00362125c ci(check-whitespace): stop requiring a read/write token
  -:  ----------- >  67:  a066a90db68 ci(check-whitespace): restrict to the intended commits
  -:  ----------- >  68:  0db4961c49b worktree: teach `add` to accept --reason <string> with --lock
  -:  ----------- >  69:  05d2c61c674 diff: correct warning message when renameLimit exceeded
  -:  ----------- >  70:  6623a528e00 doc: clarify documentation for rename/copy limits
  -:  ----------- >  71:  9dd29dbef01 diffcore-rename: treat a rename_limit of 0 as unlimited
  -:  ----------- >  72:  94b82d56866 rename: bump limit defaults yet again
  -:  ----------- >  73:  ca2d62b7879 parse-options: don't complete option aliases by default
 10:  d5360bb6f74 !  74:  5b1cd37e443 bundle doc: rewrite the "DESCRIPTION" section
    @@
      ## Metadata ##
    -Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +Author: Junio C Hamano <gitster@pobox.com>
     
      ## Commit message ##
    -    bundle doc: rewrite the "DESCRIPTION" section
    +    CodingGuidelines: recommend gender-neutral description
     
    -    Rewrite the "DESCRIPTION" section for "git bundle" to start by talking
    -    about what bundles are in general terms, rather than diving directly
    -    into one example of what they might be used for.
    +    Technical writing seeks to convey information with minimal
    +    friction. One way that a reader can experience friction is if they
    +    encounter a description of "a user" that is later simplified using a
    +    gendered pronoun. If the reader does not consider that pronoun to
    +    apply to them, then they can experience cognitive dissonance that
    +    removes focus from the information.
     
    -    This changes documentation that's been substantially the same ever
    -    since the command was added in 2e0afafebd8 (Add git-bundle: move
    -    objects and references by archive, 2007-02-22).
    +    Give some basic tips to guide us avoid unnecessary uses of gendered
    +    description.
     
    -    I've split up the DESCRIPTION into that section and a "BUNDLE FORMAT"
    -    section, it briefly discusses the format, but then links to the
    -    technical/bundle-format.txt documentation.
    +    Using a gendered pronoun is appropriate when referring to a specific
    +    person.
     
    -    The "the user must specify a basis" part of this is discussed below in
    -    "SPECIFYING REFERENCES", and will be further elaborated on in a
    -    subsequent commit. So I'm removing that part and letting the mention
    -    of "revision exclusions" suffice.
    +    There are acceptable existing uses of gendered pronouns within the
    +    Git codebase, such as:
     
    -    There was a discussion about whether to say anything at all about
    -    "thin packs" here[1]. I think it's good to mention it for the curious
    -    reader willing to read the technical docs, but let's explicitly say
    -    that there's no "thick pack", and that the difference shouldn't
    -    matter.
    +    * References to real people (e.g. Linus Torvalds, "the Git maintainer").
    +      Do not misgender real people. If there is any doubt to the gender of a
    +      person, then avoid using pronouns.
     
    -    1. http://lore.kernel.org/git/xmqqk0mbt5rj.fsf@gitster.g
    +    * References to fictional people with clear genders (e.g. Alice and
    +      Bob).
     
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +    * Sample text used in test cases (e.g t3702, t6432).
     
    - ## Documentation/git-bundle.txt ##
    -@@ Documentation/git-bundle.txt: SYNOPSIS
    - DESCRIPTION
    - -----------
    +    * The official text of the GPL license contains uses of "he or she",
    +      but using singular "they" (or modifying the text in some other
    +      way) is not within the scope of the Git project.
    +
    +    * Literal email messages in Documentation/howto/ should not be edited
    +      for grammatical concerns such as this, unless we update the entire
    +      document to fit the standard documentation format. If such an effort is
    +      taken on, then the authorship would change and no longer refer to the
    +      exact mail message.
    +
    +    * External projects consumed in contrib/ should not deviate solely for
    +      style reasons. Recommended edits should be contributed to those
    +      projects directly.
    +
    +    Other cases within the Git project were cleaned up by the previous
    +    changes.
    +
    +    Co-authored-by: Junio C Hamano <gitster@pobox.com>
    +    Signed-off-by: Derrick Stolee <dstolee@microsoft.com>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
    +
    + ## Documentation/CodingGuidelines ##
    +@@ Documentation/CodingGuidelines: Writing Documentation:
    +  documentation, please see the documentation-related advice in the
    +  Documentation/SubmittingPatches file).
      
    --Some workflows require that one or more branches of development on one
    --machine be replicated on another machine, but the two machines cannot
    --be directly connected, and therefore the interactive Git protocols (git,
    --ssh, http) cannot be used.
    --
    --The 'git bundle' command packages objects and references in an archive
    --at the originating machine, which can then be imported into another
    --repository using 'git fetch', 'git pull', or 'git clone',
    --after moving the archive by some means (e.g., by sneakernet).
    --
    --As no
    --direct connection between the repositories exists, the user must specify a
    --basis for the bundle that is held by the destination repository: the
    --bundle assumes that all objects in the basis are already in the
    --destination repository.
    -+Create, unpack, and manipulate "bundle" files. Bundles are used for
    -+the "offline" transfer of Git objects without an active "server"
    -+sitting on the other side of the network connection.
    ++ In order to ensure the documentation is inclusive, avoid assuming
    ++ that an unspecified example person is male or female, and think
    ++ twice before using "he", "him", "she", or "her".  Here are some
    ++ tips to avoid use of gendered pronouns:
     +
    -+They can be used to create both incremental and full backups of a
    -+repository, and to relay the state of the references in one repository
    -+to another.
    ++  - Prefer succinctness and matter-of-factly describing functionality
    ++    in the abstract.  E.g.
     +
    -+Git commands that fetch or otherwise "read" via protocols such as
    -+`ssh://` and `https://` can also operate on bundle files. It is
    -+possible linkgit:git-clone[1] a new repository from a bundle, to use
    -+linkgit:git-fetch[1] to fetch from one, and to list the references
    -+contained within it with linkgit:git-ls-remote[1]. There's no
    -+corresponding "write" support, i.e.a 'git push' into a bundle is not
    -+supported.
    ++     --short:: Emit output in the short-format.
     +
    -+See the "EXAMPLES" section below for examples of how to use bundles.
    ++    and avoid something like these overly verbose alternatives:
     +
    -+BUNDLE FORMAT
    -+-------------
    ++     --short:: Use this to emit output in the short-format.
    ++     --short:: You can use this to get output in the short-format.
    ++     --short:: A user who prefers shorter output could....
    ++     --short:: Should a person and/or program want shorter output, he
    ++               she/they/it can...
     +
    -+Bundles are `.pack` files (see linkgit:git-pack-objects[1]) with a
    -+header indicating what references are contained within the bundle. The
    -+header is (mostly) in the format emitted by linkgit:git-show-ref[1].
    ++    This practice often eliminates the need to involve human actors in
    ++    your description, but it is a good practice regardless of the
    ++    avoidance of gendered pronouns.
     +
    -+Like the the packed archive format itself bundles can either be
    -+self-contained, or be created using exclusions.
    ++  - When it becomes awkward to stick to this style, prefer "you" when
    ++    addressing the the hypothetical user, and possibly "we" when
    ++    discussing how the program might react to the user.  E.g.
     +
    -+Bundles created using revision exclusions are "thin packs" created
    -+using the `--thin` option to linkgit:git-pack-objects[1], and
    -+unbundled using the `--fix-thin` option to linkgit:git-index-pack[1].
    ++      You can use this option instead of --xyz, but we might remove
    ++      support for it in future versions.
     +
    -+There is no option to create a "thick pack" when using revision
    -+exclusions, users should not be concerned about the difference. By
    -+using "thin packs" bundles created using exclusions are smaller in
    -+size. That they're "thin" under the hood is merely noted here as a
    -+curiosity, and as a reference to other documentation
    ++    while keeping in mind that you can probably be less verbose, e.g.
     +
    -+See link:technical/bundle-format.html[the `bundle-format`
    -+documentation] for more details and the discussion of "thin pack" in
    -+link:technical/pack-format.html[the pack format documentation] for
    -+further details.
    - 
    - OPTIONS
    - -------
    ++      Use this instead of --xyz. This option might be removed in future
    ++      versions.
    ++
    ++  - If you still need to refer to an example person that is
    ++    third-person singular, you may resort to "singular they" to avoid
    ++    "he/she/him/her", e.g.
    ++
    ++      A contributor asks their upstream to pull from them.
    ++
    ++    Note that this sounds ungrammatical and unnatural to those who
    ++    learned that "they" is only used for third-person plural, e.g.
    ++    those who learn English as a second language in some parts of the
    ++    world.
    ++
    +  Every user-visible change should be reflected in the documentation.
    +  The same general rule as for code applies -- imitate the existing
    +  conventions.
  -:  ----------- >  75:  64f0109f17e test-lib-functions: use test-tool for [de]packetize()
  -:  ----------- >  76:  ac223c40477 t0000: clear GIT_SKIP_TESTS before running sub-tests
  -:  ----------- >  77:  c510928a25c refs/debug: quote prefix
  -:  ----------- >  78:  88617d11f9d multi-pack-index: fix potential segfault without sub-command
  -:  ----------- >  79:  ade15525987 t0000: fix test if run with TEST_OUTPUT_DIRECTORY
  -:  ----------- >  80:  4bb9eb5f911 doc/git-config: explain --file instead of referring to GIT_CONFIG
  -:  ----------- >  81:  b3b186262fd doc/git-config: clarify GIT_CONFIG environment variable
  -:  ----------- >  82:  734283855f8 doc/git-config: simplify "override" advice for FILES section
  -:  ----------- >  83:  878b3997345 doc: clarify description of 'submodule.recurse'
  -:  ----------- >  84:  ddcb189d9d0 pack-bitmap: clarify comment in filter_bitmap_exclude_type()
  -:  ----------- >  85:  d3236bececc doc: pull: fix rebase=false documentation
 12:  6d66d4480ff !  86:  eb27b338a3e bundle doc: elaborate on rev<->ref restriction
    @@
      ## Metadata ##
    -Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +Author: Junio C Hamano <gitster@pobox.com>
     
      ## Commit message ##
    -    bundle doc: elaborate on rev<->ref restriction
    +    The sixth batch
     
    -    Elaborate on the restriction that you cannot provide a revision that
    -    doesn't resolve to a reference in the "SPECIFYING REFERENCES" section
    -    with examples.
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    -
    - ## Documentation/git-bundle.txt ##
    -@@ Documentation/git-bundle.txt: unbundle <file>::
    - SPECIFYING REFERENCES
    - ---------------------
    + ## Documentation/RelNotes/2.33.0.txt ##
    +@@ Documentation/RelNotes/2.33.0.txt: UI, Workflows & Features
      
    --'git bundle' will only package references that are shown by
    --'git show-ref': this includes heads, tags, and remote heads.  References
    --such as `master~1` cannot be packaged, but are perfectly suitable for
    --defining the basis.  More than one reference may be packaged, and more
    --than one basis can be specified.  The objects packaged are those not
    --contained in the union of the given bases.  Each basis can be
    --specified explicitly (e.g. `^master~10`), or implicitly (e.g.
    --`master~10..master`, `--since=10.days.ago master`).
    -+Revisions must accompanied by reference names to be packaged in a
    -+bundle, since the header of the bundle is in a format similar to 'git
    -+show-ref'.
    -+
    -+More than one reference may be packaged, and more than one basis can
    -+be specified.  The objects packaged are those not contained in the
    -+union of the given bases.
    -+
    -+The 'git bundle create' command resolves the reference names for you
    -+using the same rules as `git rev-parse --abbrev-ref=loose`. Each
    -+basis can be specified explicitly (e.g. `^master~10`), or implicitly
    -+(e.g. `master~10..master`, `--since=10.days.ago master`).
    -+
    -+All of these simple cases are OK (assuming we have a "master" and
    -+"next" branch):
    -+
    -+----------------
    -+$ git bundle create master.bundle master
    -+$ echo master | git bundle create master.bundle --stdin
    -+$ git bundle create master-and-next.bundle master next
    -+$ (echo master; echo next) | git bundle create master-and-next.bundle --stdin
    -+----------------
    -+
    -+And so are these (and the same but omitted `--stdin` examples):
    +  * The userdiff pattern for C# learned the token "record".
    + 
    ++ * "git rev-list" learns to omit the "commit <object-name>" header
    ++   lines from the output with the `--no-commit-header` option.
     +
    -+----------------
    -+$ git bundle create recent-master.bundle master~10..master
    -+$ git bundle create recent-updates.bundle master~10..master next~5..next
    -+----------------
    + 
    + Performance, Internal Implementation, Development Support etc.
    + 
    +@@ Documentation/RelNotes/2.33.0.txt: Performance, Internal Implementation, Development Support etc.
    + 
    +  * Code cleanup around struct_type_init() functions.
    + 
    ++ * "git send-email" optimization.
     +
    -+A revision name or a range whose right-hand-side cannot be resolved to
    -+a reference is not accepted:
    ++ * GitHub Actions / CI update.
    ++   (merge 0dc787a9f2 js/ci-windows-update later to maint).
     +
    -+----------------
    -+$ git bundle create HEAD.bundle $(git rev-parse HEAD)
    -+fatal: Refusing to create empty bundle.
    -+$ git bundle create master-yesterday.bundle master~10..master~5
    -+fatal: Refusing to create empty bundle.
    -+----------------
      
    - OBJECT PREREQUISITES
    - --------------------
    + Fixes since v2.32
    + -----------------
    +@@ Documentation/RelNotes/2.33.0.txt: Fixes since v2.32
    +    (merge 617480d75b hn/refs-iterator-peel-returns-boolean later to maint).
    +    (merge 6a24cc71ed ar/submodule-helper-include-cleanup later to maint).
    +    (merge 5632e838f8 rs/khash-alloc-cleanup later to maint).
    ++   (merge b1d87fbaf1 jk/typofix later to maint).
    ++   (merge e04170697a ab/gitignore-discovery-doc later to maint).
 15:  09fb55e704f !  87:  95cf6464ddd bundle tests: use ">file" not ": >file"
    @@ Metadata
      ## Commit message ##
         bundle tests: use ">file" not ": >file"
     
    -    Change redundant uses of ":" on the LHS of a ">" to the more commonly
    -    use ">file" pattern.
    +    Change uses of ":" on the LHS of a ">" to the more commonly used
    +    ">file" pattern in t/t5607-clone-bundle.sh.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
      ## t/t5607-clone-bundle.sh ##
     @@ t/t5607-clone-bundle.sh: test_expect_success 'bundle --stdin <rev-list options>' '
 16:  2721723bfd4 !  88:  63766510a15 bundle tests: use test_cmp instead of grep
    @@ Commit message
         output explicitly like this.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
      ## t/t5607-clone-bundle.sh ##
     @@ t/t5607-clone-bundle.sh: test_expect_success '"verify" needs a worktree' '
    @@ t/t5607-clone-bundle.sh: test_expect_success 'ridiculously long subject in bound
     -	sed -n "/^-/{p;q;}" long-subject-bundle.bdl >boundary &&
     -	grep "^-$OID_REGEX " boundary
     +
    -+	cat >expect.common <<-EOF &&
    ++	if ! test_have_prereq SHA1
    ++	then
    ++		echo "@object-format=sha256"
    ++	fi >expect &&
    ++	cat >>expect <<-EOF &&
     +	-$(git log --pretty=format:"%H %s" -1 HEAD^)
     +	$(git rev-parse HEAD) HEAD
     +	EOF
    ++
     +	if test_have_prereq SHA1
     +	then
    -+		cp expect.common expect
    -+	else
    -+		echo @object-format=sha256 >expect
    -+		cat expect.common >>expect
    -+	fi &&
    -+	if test_have_prereq SHA1
    -+	then
    -+		head -n 3 long-subject-bundle.bdl >bundle-header
    ++		head -n 3 long-subject-bundle.bdl
     +	else
    -+		head -n 4 long-subject-bundle.bdl >bundle-header
    -+	fi &&
    -+	grep -v "^#" bundle-header >actual &&
    ++		head -n 4 long-subject-bundle.bdl
    ++	fi | grep -v "^#" >actual &&
    ++
     +	test_cmp expect actual
      '
      
  -:  ----------- >  89:  dc1daacdcc2 pack-bitmap: check pack validity when opening bitmap
  2:  540bba26d66 !  90:  b2896d27391 SANITIZE tests: fix memory leaks in t13*config*, add to whitelist
    @@
      ## Metadata ##
    -Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +Author: Jonathan Tan <jonathantanmy@google.com>
     
      ## Commit message ##
    -    SANITIZE tests: fix memory leaks in t13*config*, add to whitelist
    +    unpack-trees: refactor prefetching code
     
    -    Fix a couple of trivial memory leaks introduced in 3efd0bedc6 (config:
    -    add conditional include, 2017-03-01) and my own 867ad08a26 (hooks:
    -    allow customizing where the hook directory is, 2016-05-04).
    +    Refactor the prefetching code in unpack-trees.c into its own function,
    +    because it will be used elsewhere in a subsequent commit.
     
    -    In the latter case the "fix" is UNLEAK() on the global variable. This
    -    allows us to run all t13*config* tests under SANITIZE=leak.
    +    Signed-off-by: Jonathan Tan <jonathantanmy@google.com>
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    -    With this change we can now run almost the whole set of config.c
    -    tests (t13*config) under SANITIZE=leak, so let's do so, with a few
    -    exceptions:
    -
    -     * The test added in ce81b1da23 (config: add new way to pass config
    -       via `--config-env`, 2021-01-12), it fails in GitHub CI, but passes
    -       for me locally. Let's just skip it for now.
    -
    -     * Ditto the split_cmdline and "aliases of builtins" tests, the former
    -       required splitting up an existing test, there an issue with the test
    -       that would have also been revealed by skipping it.
    -
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    -
    - ## config.c ##
    -@@ config.c: static int handle_path_include(const char *path, struct config_include_data *inc
    - 		return config_error_nonbool("include.path");
    + ## cache.h ##
    +@@ cache.h: struct cache_entry *dup_cache_entry(const struct cache_entry *ce, struct index_s
    +  */
    + void validate_cache_entries(const struct index_state *istate);
      
    - 	expanded = expand_user_path(path, 0);
    --	if (!expanded)
    --		return error(_("could not expand include path '%s'"), path);
    -+	if (!expanded) {
    -+		ret = error(_("could not expand include path '%s'"), path);
    -+		goto cleanup;
    -+	}
    - 	path = expanded;
    ++/*
    ++ * Bulk prefetch all missing cache entries that are not GITLINKs and that match
    ++ * the given predicate. This function should only be called if
    ++ * has_promisor_remote() returns true.
    ++ */
    ++typedef int (*must_prefetch_predicate)(const struct cache_entry *);
    ++void prefetch_cache_entries(const struct index_state *istate,
    ++			    must_prefetch_predicate must_prefetch);
    ++
    + #ifdef USE_THE_INDEX_COMPATIBILITY_MACROS
    + extern struct index_state the_index;
      
    - 	/*
    -@@ config.c: static int handle_path_include(const char *path, struct config_include_data *inc
    - 	if (!is_absolute_path(path)) {
    - 		char *slash;
    +
    + ## read-cache.c ##
    +@@
    + #include "progress.h"
    + #include "sparse-index.h"
    + #include "csum-file.h"
    ++#include "promisor-remote.h"
      
    --		if (!cf || !cf->path)
    --			return error(_("relative config includes must come from files"));
    -+		if (!cf || !cf->path) {
    -+			ret = error(_("relative config includes must come from files"));
    -+			goto cleanup;
    -+		}
    + /* Mask for the name length in ce_flags in the on-disk index */
      
    - 		slash = find_last_dir_sep(cf->path);
    - 		if (slash)
    -@@ config.c: static int handle_path_include(const char *path, struct config_include_data *inc
    - 		ret = git_config_from_file(git_config_include, path, inc);
    - 		inc->depth--;
    +@@ read-cache.c: static void write_ieot_extension(struct strbuf *sb, struct index_entry_offset_ta
    + 		strbuf_add(sb, &buffer, sizeof(uint32_t));
      	}
    -+cleanup:
    - 	strbuf_release(&buf);
    - 	free(expanded);
    - 	return ret;
    -@@ config.c: static int git_default_core_config(const char *var, const char *value, void *cb)
    - 	if (!strcmp(var, "core.attributesfile"))
    - 		return git_config_pathname(&git_attributes_file, var, value);
    - 
    --	if (!strcmp(var, "core.hookspath"))
    -+	if (!strcmp(var, "core.hookspath")) {
    -+		UNLEAK(git_hooks_path);
    - 		return git_config_pathname(&git_hooks_path, var, value);
    + }
    ++
    ++void prefetch_cache_entries(const struct index_state *istate,
    ++			    must_prefetch_predicate must_prefetch)
    ++{
    ++	int i;
    ++	struct oid_array to_fetch = OID_ARRAY_INIT;
    ++
    ++	for (i = 0; i < istate->cache_nr; i++) {
    ++		struct cache_entry *ce = istate->cache[i];
    ++
    ++		if (S_ISGITLINK(ce->ce_mode) || !must_prefetch(ce))
    ++			continue;
    ++		if (!oid_object_info_extended(the_repository, &ce->oid,
    ++					      NULL,
    ++					      OBJECT_INFO_FOR_PREFETCH))
    ++			continue;
    ++		oid_array_append(&to_fetch, &ce->oid);
     +	}
    - 
    - 	if (!strcmp(var, "core.bare")) {
    - 		is_bare_repository_cfg = git_config_bool(var, value);
    ++	promisor_remote_get_direct(the_repository,
    ++				   to_fetch.oid, to_fetch.nr);
    ++	oid_array_clear(&to_fetch);
    ++}
     
    - ## t/t1300-config.sh ##
    -@@ t/t1300-config.sh: test_expect_success SYMLINKS 'symlink to nonexistent configuration' '
    - 	test_must_fail git config --file=linktolinktonada --list
    - '
    + ## unpack-trees.c ##
    +@@ unpack-trees.c: static void report_collided_checkout(struct index_state *index)
    + 	string_list_clear(&list, 0);
    + }
      
    --test_expect_success 'check split_cmdline return' "
    --	git config alias.split-cmdline-fix 'echo \"' &&
    --	test_must_fail git split-cmdline-fix &&
    -+test_expect_success 'setup check split_cmdline return' "
    - 	echo foo > foo &&
    - 	git add foo &&
    --	git commit -m 'initial commit' &&
    -+	git commit -m 'initial commit'
    -+"
    ++static int must_checkout(const struct cache_entry *ce)
    ++{
    ++	return ce->ce_flags & CE_UPDATE;
    ++}
     +
    -+test_expect_success !SANITIZE_LEAK 'check split_cmdline return' "
    -+	git config alias.split-cmdline-fix 'echo \"' &&
    -+	test_must_fail git split-cmdline-fix &&
    -+
    - 	git config branch.main.mergeoptions 'echo \"' &&
    - 	test_must_fail git merge main
    - "
    -@@ t/t1300-config.sh: test_expect_success 'key sanity-checking' '
    - 	git config foo."ba =z".bar false
    - '
    + static int check_updates(struct unpack_trees_options *o,
    + 			 struct index_state *index)
    + {
    +@@ unpack-trees.c: static int check_updates(struct unpack_trees_options *o,
    + 	if (should_update_submodules())
    + 		load_gitmodules_file(index, &state);
      
    --test_expect_success 'git -c works with aliases of builtins' '
    -+test_expect_success !SANITIZE_LEAK 'git -c works with aliases of builtins' '
    - 	git config alias.checkconfig "-c foo.check=bar config foo.check" &&
    - 	echo bar >expect &&
    - 	git checkconfig >actual &&
    -@@ t/t1300-config.sh: test_expect_success 'git --config-env with missing value' '
    - 	grep "invalid config format: config" error
    - '
    +-	if (has_promisor_remote()) {
    ++	if (has_promisor_remote())
    + 		/*
    + 		 * Prefetch the objects that are to be checked out in the loop
    + 		 * below.
    + 		 */
    +-		struct oid_array to_fetch = OID_ARRAY_INIT;
    +-		for (i = 0; i < index->cache_nr; i++) {
    +-			struct cache_entry *ce = index->cache[i];
    +-
    +-			if (!(ce->ce_flags & CE_UPDATE) ||
    +-			    S_ISGITLINK(ce->ce_mode))
    +-				continue;
    +-			if (!oid_object_info_extended(the_repository, &ce->oid,
    +-						      NULL,
    +-						      OBJECT_INFO_FOR_PREFETCH))
    +-				continue;
    +-			oid_array_append(&to_fetch, &ce->oid);
    +-		}
    +-		promisor_remote_get_direct(the_repository,
    +-					   to_fetch.oid, to_fetch.nr);
    +-		oid_array_clear(&to_fetch);
    +-	}
    ++		prefetch_cache_entries(index, must_checkout);
      
    --test_expect_success 'git --config-env fails with invalid parameters' '
    -+test_expect_success !SANITIZE_LEAK 'git --config-env fails with invalid parameters' '
    - 	test_must_fail git --config-env=foo.flag config --bool foo.flag 2>error &&
    - 	test_i18ngrep "invalid config format: foo.flag" error &&
    - 	test_must_fail git --config-env=foo.flag= config --bool foo.flag 2>error &&
    -
    - ## t/test-lib.sh ##
    -@@ t/test-lib.sh: maybe_skip_all_sanitize_leak () {
    - 	add_sanitize_leak_true 't000*'
    - 	add_sanitize_leak_true 't001*'
    - 	add_sanitize_leak_true 't006*'
    -+	add_sanitize_leak_true 't13*config*'
    + 	get_parallel_checkout_configs(&pc_workers, &pc_threshold);
    + 
    +@@ unpack-trees.c: static int check_updates(struct unpack_trees_options *o,
    + 	for (i = 0; i < index->cache_nr; i++) {
    + 		struct cache_entry *ce = index->cache[i];
    + 
    +-		if (ce->ce_flags & CE_UPDATE) {
    ++		if (must_checkout(ce)) {
    + 			size_t last_pc_queue_size = pc_queue_size();
      
    - 	# Blacklist patterns (overrides whitelist)
    - 	add_sanitize_leak_false 't000[469]*'
    + 			if (ce->ce_flags & CE_WT_REMOVE)
  -:  ----------- >  91:  d3da223f221 cache-tree: prefetch in partial clone read-tree
  -:  ----------- >  92:  8231c841ff7 ci: run "apt-get update" before "apt-get install"
  -:  ----------- >  93:  27f45ccf336 ci/install-dependencies: handle "sparse" job package installs
  1:  ffe96a7f415 !  94:  940fe202adc tests: add a test mode for SANITIZE=leak, run it in CI
    @@
      ## Metadata ##
    -Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +Author: Junio C Hamano <gitster@pobox.com>
     
      ## Commit message ##
    -    tests: add a test mode for SANITIZE=leak, run it in CI
    +    The seventh batch
     
    -    While git can be compiled with SANITIZE=leak there has been no
    -    corresponding GIT_TEST_* mode for it, i.e. memory leaks have been
    -    fixed as one-offs without structured regression testing.
    +    Signed-off-by: Junio C Hamano <gitster@pobox.com>
     
    -    This change add such a mode, we now have new
    -    linux-{clang,gcc}-sanitize-leak CI targets, these targets run the same
    -    tests as linux-{clang,gcc}, except that almost all of them are
    -    skipped.
    -
    -    There is a whitelist of some tests that are OK in test-lib.sh, and
    -    individual tests can be opted-in by setting
    -    GIT_TEST_SANITIZE_LEAK=true before sourcing test-lib.sh. Within those
    -    individual test can be skipped with the "!SANITIZE_LEAK"
    -    prerequisite. See the updated t/README for more details.
    -
    -    I'm using the GIT_TEST_SANITIZE_LEAK=true and !SANITIZE_LEAK pattern
    -    in a couple of tests whose memory leaks I'll fix in subsequent
    -    commits.
    -
    -    I'm not being aggressive about opting in tests, it's not all tests
    -    that currently pass under SANITIZE=leak, just a small number of
    -    known-good tests. We can add more later as we fix leaks and grow more
    -    confident in this test mode.
    -
    -    See the recent discussion at [1] about the lack of this sort of test
    -    mode, and 0e5bba53af (add UNLEAK annotation for reducing leak false
    -    positives, 2017-09-08) for the initial addition of SANITIZE=leak.
    -
    -    See also 09595ab381 (Merge branch 'jk/leak-checkers', 2017-09-19),
    -    7782066f67 (Merge branch 'jk/apache-lsan', 2019-05-19) and the recent
    -    936e58851a (Merge branch 'ah/plugleaks', 2021-05-07) for some of the
    -    past history of "one-off" SANITIZE=leak (and more) fixes.
    -
    -    When calling maybe_skip_all_sanitize_leak matching against
    -    "$TEST_NAME" instead of "$this_test" as other "match_pattern_list()"
    -    users do is intentional. I'd like to match things like "t13*config*"
    -    in subsequent commits. This part of the API isn't public, so we can
    -    freely change it in the future.
    -
    -    1. https://lore.kernel.org/git/87czsv2idy.fsf@evledraar.gmail.com/
    -
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    -
    - ## .github/workflows/main.yml ##
    -@@ .github/workflows/main.yml: jobs:
    -           - jobname: linux-gcc-default
    -             cc: gcc
    -             pool: ubuntu-latest
    -+          - jobname: linux-clang-sanitize-leak
    -+            cc: clang
    -+            pool: ubuntu-latest
    -+          - jobname: linux-gcc-sanitize-leak
    -+            cc: gcc
    -+            pool: ubuntu-latest
    -     env:
    -       CC: ${{matrix.vector.cc}}
    -       jobname: ${{matrix.vector.jobname}}
    -
    - ## Makefile ##
    -@@ Makefile: PTHREAD_CFLAGS =
    - SPARSE_FLAGS ?=
    - SP_EXTRA_FLAGS = -Wno-universal-initializer
    + ## Documentation/RelNotes/2.33.0.txt ##
    +@@ Documentation/RelNotes/2.33.0.txt: UI, Workflows & Features
    +  * "git rev-list" learns to omit the "commit <object-name>" header
    +    lines from the output with the `--no-commit-header` option.
      
    -+# For informing GIT-BUILD-OPTIONS of the SANITIZE=leak target
    -+SANITIZE_LEAK =
    ++ * "git worktree add --lock" learned to record why the worktree is
    ++   locked with a custom message.
     +
    - # For the 'coccicheck' target; setting SPATCH_BATCH_SIZE higher will
    - # usually result in less CPU usage at the cost of higher peak memory.
    - # Setting it to 0 will feed all files in a single spatch invocation.
    -@@ Makefile: BASIC_CFLAGS += -DSHA1DC_FORCE_ALIGNED_ACCESS
    - endif
    - ifneq ($(filter leak,$(SANITIZERS)),)
    - BASIC_CFLAGS += -DSUPPRESS_ANNOTATED_LEAKS
    -+SANITIZE_LEAK = YesCompiledWithIt
    - endif
    - ifneq ($(filter address,$(SANITIZERS)),)
    - NO_REGEX = NeededForASAN
    -@@ Makefile: GIT-BUILD-OPTIONS: FORCE
    - 	@echo NO_UNIX_SOCKETS=\''$(subst ','\'',$(subst ','\'',$(NO_UNIX_SOCKETS)))'\' >>$@+
    - 	@echo PAGER_ENV=\''$(subst ','\'',$(subst ','\'',$(PAGER_ENV)))'\' >>$@+
    - 	@echo DC_SHA1=\''$(subst ','\'',$(subst ','\'',$(DC_SHA1)))'\' >>$@+
    -+	@echo SANITIZE_LEAK=\''$(subst ','\'',$(subst ','\'',$(SANITIZE_LEAK)))'\' >>$@+
    - 	@echo X=\'$(X)\' >>$@+
    - ifdef TEST_OUTPUT_DIRECTORY
    - 	@echo TEST_OUTPUT_DIRECTORY=\''$(subst ','\'',$(subst ','\'',$(TEST_OUTPUT_DIRECTORY)))'\' >>$@+
    -
    - ## ci/install-dependencies.sh ##
    -@@ ci/install-dependencies.sh: UBUNTU_COMMON_PKGS="make libssl-dev libcurl4-openssl-dev libexpat-dev
    -  libemail-valid-perl libio-socket-ssl-perl libnet-smtp-ssl-perl"
    - 
    - case "$jobname" in
    --linux-clang|linux-gcc)
    -+linux-clang|linux-gcc|linux-clang-sanitize-leak|linux-gcc-sanitize-leak)
    - 	sudo apt-add-repository -y "ppa:ubuntu-toolchain-r/test"
    - 	sudo apt-get -q update
    - 	sudo apt-get -q -y install language-pack-is libsvn-perl apache2 \
    - 		$UBUNTU_COMMON_PKGS
    - 	case "$jobname" in
    --	linux-gcc)
    -+	linux-gcc|linux-gcc-sanitize-leak)
    - 		sudo apt-get -q -y install gcc-8
    - 		;;
    - 	esac
    -
    - ## ci/lib.sh ##
    -@@ ci/lib.sh: export GIT_TEST_CLONE_2GB=true
    - export SKIP_DASHED_BUILT_INS=YesPlease
    - 
    - case "$jobname" in
    --linux-clang|linux-gcc)
    --	if [ "$jobname" = linux-gcc ]
    --	then
    -+linux-clang|linux-gcc|linux-clang-sanitize-leak|linux-gcc-sanitize-leak)
    -+	case "$jobname" in
    -+	linux-gcc|linux-gcc-sanitize-leak)
    - 		export CC=gcc-8
    - 		MAKEFLAGS="$MAKEFLAGS PYTHON_PATH=/usr/bin/python3"
    --	else
    -+		;;
    -+	*)
    - 		MAKEFLAGS="$MAKEFLAGS PYTHON_PATH=/usr/bin/python2"
    --	fi
    -+		;;
    -+	esac
      
    - 	export GIT_TEST_HTTPD=true
    + Performance, Internal Implementation, Development Support etc.
      
    -@@ ci/lib.sh: linux-musl)
    - 	;;
    - esac
    +@@ Documentation/RelNotes/2.33.0.txt: Performance, Internal Implementation, Development Support etc.
    +  * GitHub Actions / CI update.
    +    (merge 0dc787a9f2 js/ci-windows-update later to maint).
      
    -+case "$jobname" in
    -+linux-clang-sanitize-leak|linux-gcc-sanitize-leak)
    -+	export SANITIZE=leak
    -+	;;
    -+esac
    ++ * Object accesses in repositories with many alternate object store
    ++   have been optimized.
     +
    - MAKEFLAGS="$MAKEFLAGS CC=${CC:-cc}"
    -
    - ## ci/run-build-and-tests.sh ##
    -@@ ci/run-build-and-tests.sh: esac
    - 
    - make
    - case "$jobname" in
    --linux-gcc)
    -+linux-gcc|linux-gcc-sanitize-leak)
    - 	export GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME=main
    - 	make test
    - 	export GIT_TEST_SPLIT_INDEX=yes
    -@@ ci/run-build-and-tests.sh: linux-gcc)
    - 	export GIT_TEST_CHECKOUT_WORKERS=2
    - 	make test
    - 	;;
    --linux-clang)
    -+linux-clang|linux-clang-sanitize-leak)
    - 	export GIT_TEST_DEFAULT_HASH=sha1
    - 	make test
    - 	export GIT_TEST_DEFAULT_HASH=sha256
    -
    - ## t/README ##
    -@@ t/README: GIT_TEST_CHECKOUT_WORKERS=<n> overrides the 'checkout.workers' setting
    - to <n> and 'checkout.thresholdForParallelism' to 0, forcing the
    - execution of the parallel-checkout code.
    - 
    -+GIT_TEST_SANITIZE_LEAK=<boolean> will force the tests to run when git
    -+is compiled with SANITIZE=leak (we pick it up via
    -+../GIT-BUILD-OPTIONS).
    ++ * "git log" has been optimized not to waste cycles to load ref
    ++   decoration data that may not be needed.
     +
    -+By default all tests are skipped when compiled with SANITIZE=leak, and
    -+individual test scripts opt themselves in to leak testing by setting
    -+GIT_TEST_SANITIZE_LEAK=true before sourcing test-lib.sh. Within those
    -+tests use the SANITIZE_LEAK prerequisite to skip individiual tests
    -+(i.e. test_expect_success !SANITIZE_LEAK [...]).
    ++ * Many "printf"-like helper functions we have have been annotated
    ++   with __attribute__() to catch placeholder/parameter mismatches.
     +
    -+So the GIT_TEST_SANITIZE_LEAK setting is different in behavior from
    -+both other GIT_TEST_*=[true|false] settings, but more useful given how
    -+SANITIZE=leak works & the state of the test suite. Manually setting
    -+GIT_TEST_SANITIZE_LEAK=true is only useful during development when
    -+finding and fixing memory leaks.
    ++ * Tests that cover protocol bits have been updated and helpers
    ++   used there have been consolidated.
     +
    - Naming Tests
    - ------------
    - 
    -
    - ## t/t5701-git-serve.sh ##
    -@@ t/t5701-git-serve.sh: test_expect_success 'unexpected lines are not allowed in fetch request' '
    - 
    - # Test the basics of object-info
    - #
    --test_expect_success 'basics of object-info' '
    -+test_expect_success !SANITIZE_LEAK 'basics of object-info' '
    - 	test-tool pkt-line pack >in <<-EOF &&
    - 	command=object-info
    - 	object-format=$(test_oid algo)
    -
    - ## t/test-lib.sh ##
    -@@ t/test-lib.sh: then
    - 	exit 1
    - fi
    - 
    -+# SANITIZE=leak test mode
    -+sanitize_leak_true=
    -+add_sanitize_leak_true () {
    -+	sanitize_leak_true="$sanitize_leak_true$1 "
    -+}
    ++ * The CI gained a new job to run "make sparse" check.
     +
    -+sanitize_leak_false=
    -+add_sanitize_leak_false () {
    -+	sanitize_leak_false="$sanitize_leak_false$1 "
    -+}
    ++ * "git status" codepath learned to work with sparsely populated index
    ++   without hydrating it fully.
     +
    -+sanitize_leak_opt_in_msg="opt-in with GIT_TEST_SANITIZE_LEAK=true"
    -+maybe_skip_all_sanitize_leak () {
    -+	# Whitelist patterns
    -+	add_sanitize_leak_true 't000*'
    -+	add_sanitize_leak_true 't001*'
    -+	add_sanitize_leak_true 't006*'
    ++ * A guideline for gender neutral documentation has been added.
     +
    -+	# Blacklist patterns (overrides whitelist)
    -+	add_sanitize_leak_false 't000[469]*'
    -+	add_sanitize_leak_false 't001[2459]*'
    -+	add_sanitize_leak_false 't006[0248]*'
    ++ * Documentation on "git diff -l<n>" and diff.renameLimit have been
    ++   updated, and the defaults for these limits have been raised.
     +
    -+	if match_pattern_list "$1" "$sanitize_leak_false"
    -+	then
    -+		skip_all="test $this_test on SANITIZE=leak blacklist, $sanitize_leak_opt_in_msg"
    -+		test_done
    -+	elif match_pattern_list "$1" "$sanitize_leak_true"
    -+	then
    -+		return 0
    -+	fi
    -+	return 1
    -+}
    ++ * The completion support used to offer alternate spelling of options
    ++   that exist only for compatibility, which has been corrected.
     +
    - # Are we running this test at all?
    - remove_trash=
    - this_test=${0##*/}
    -@@ t/test-lib.sh: then
    - 	test_done
    - fi
    - 
    -+# Aggressively skip non-whitelisted tests when compiled with
    -+# SANITIZE=leak
    -+if test -n "$SANITIZE_LEAK"
    -+then
    -+	if test -z "$GIT_TEST_SANITIZE_LEAK" &&
    -+		maybe_skip_all_sanitize_leak "$TEST_NAME"
    -+	then
    -+		say_color info >&3 "test $this_test on SANITIZE=leak whitelist"
    -+		GIT_TEST_SANITIZE_LEAK=true
    -+	fi
    ++ * "TEST_OUTPUT_DIRECTORY=there make test" failed to work, which has
    ++   been corrected.
     +
    -+	# We need to see it in "git env--helper" (via
    -+	# test_bool_env)
    -+	export GIT_TEST_SANITIZE_LEAK
    + 
    + Fixes since v2.32
    + -----------------
    +@@ Documentation/RelNotes/2.33.0.txt: Fixes since v2.32
    +    and adds to guidelines to do so.
    +    (merge 46a237f42f ds/gender-neutral-doc later to maint).
    + 
    ++ * "git commit --allow-empty-message" won't abort the operation upon
    ++   an empty message, but the hint shown in the editor said otherwise.
    ++   (merge 6f70f00b4f hj/commit-allow-empty-message later to maint).
     +
    -+	if ! test_bool_env GIT_TEST_SANITIZE_LEAK false
    -+	then
    -+		skip_all="skip all tests in $this_test under SANITIZE=leak, $sanitize_leak_opt_in_msg"
    -+		test_done
    -+	fi
    -+elif test_bool_env GIT_TEST_SANITIZE_LEAK false
    -+then
    -+	error "GIT_TEST_SANITIZE_LEAK=true has no effect except when compiled with SANITIZE=leak"
    -+fi
    ++ * The code that gives an error message in "git multi-pack-index" when
    ++   no subcommand is given tried to print a NULL pointer as a strong,
    ++   which has been corrected.
    ++   (merge 88617d11f9 tb/reverse-midx later to maint).
     +
    - # Last-minute variable setup
    - HOME="$TRASH_DIRECTORY"
    - GNUPGHOME="$HOME/gnupg-home-not-used"
    -@@ t/test-lib.sh: test -z "$NO_PYTHON" && test_set_prereq PYTHON
    - test -n "$USE_LIBPCRE2" && test_set_prereq PCRE
    - test -n "$USE_LIBPCRE2" && test_set_prereq LIBPCRE2
    - test -z "$NO_GETTEXT" && test_set_prereq GETTEXT
    -+test -n "$SANITIZE_LEAK" && test_set_prereq SANITIZE_LEAK
    - 
    - if test -z "$GIT_TEST_CHECK_CACHE_TREE"
    - then
    +  * Other code cleanup, docfix, build fix, etc.
    +    (merge bfe35a6165 ah/doc-describe later to maint).
    +    (merge f302c1e4aa jc/clarify-revision-range later to maint).
    +@@ Documentation/RelNotes/2.33.0.txt: Fixes since v2.32
    +    (merge 5632e838f8 rs/khash-alloc-cleanup later to maint).
    +    (merge b1d87fbaf1 jk/typofix later to maint).
    +    (merge e04170697a ab/gitignore-discovery-doc later to maint).
    ++   (merge 8232a0ff48 dl/packet-read-response-end-fix later to maint).
    ++   (merge eb448631fb dl/diff-merge-base later to maint).
    ++   (merge c510928a25 hn/refs-debug-empty-prefix later to maint).
  -:  ----------- >  95:  66262451ec9 Git 2.33-rc0
 17:  192fb64ef82 =  96:  21d91dff9d8 serve: mark has_capability() as static
 18:  d716bd3c537 =  97:  8b76204cc7f transport: rename "fetch" in transport_vtable to "fetch_refs"
 19:  d31690614af =  98:  8d171ba9631 transport: use designated initializers
 20:  13f1a8d8325 =  99:  c7b110cd16c serve: use designated initializers
 22:  be719dc3dc1 ! 100:  f1c267a406d serve: add support for a "startup" git_config() callback
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    serve: add support for a "startup" git_config() callback
    +    serve: move transfer.advertiseSID check into session_id_advertise()
     
    -    Since the introduction of serve.c we've added git_config() callbacks
    -    and other config reading for capabilities in the following commits:
    +    In 6b5b6e422ee (serve: advertise session ID in v2 capabilities,
    +    2020-11-11) the check for transfer.advertiseSID was added to the
    +    beginning of the main serve() loop. Thus on startup of the server we'd
    +    populate it.
     
    -    - e20b4192a37 (upload-pack: support hidden refs with protocol v2, 2018-12-18)
    -    - 08450ef7918 (upload-pack: clear filter_options for each v2 fetch command, 2020-05-08)
    -    - 6b5b6e422ee (serve: advertise session ID in v2 capabilities, 2020-11-11)
    -    - 59e1205d167 (ls-refs: report unborn targets of symrefs, 2021-02-05)
    -
    -    Of these 08450ef7918 fixed code that needed to read config on a
    -    per-request basis, whereas most of the config reading just wants to
    -    check if we've enabled one semi-static config variable or other. We'd
    -    like to re-read that value eventually, but from request-to-request
    -    it's OK if we retain the old one, and it isn't impacted by other
    -    request data.
    -
    -    So let's support this common pattern as a "startup_config" callback,
    -    making use of our recently added "call_{advertise,command}()"
    -    functions. This allows us to simplify e.g. the "ensure_config_read()"
    -    function added in 59e1205d167 (ls-refs: report unborn targets of
    -    symrefs, 2021-02-05).
    -
    -    We could read all the config for all the protocol capabilities, but
    -    let's do it one callback at a time in anticipation that some won't be
    -    called at all, and that some might be more expensive than others in
    -    the future.
    -
    -    I'm not migrating over the code in the upload_pack_v2 function in
    -    upload-pack.c yet, that case is more complex since it deals with both
    -    v1 and v2. It will be dealt with in a code a subsequent commit.
    -
    -    As we'll see in subsequent commits, by moving the
    -    transfer.advertisesid config reading out of serve() we can simplify
    -    the codepath around advertising-only requests. See 6b5b6e422ee (serve:
    -    advertise session ID in v2 capabilities, 2020-11-11)) for the commit
    -    that added transfer.advertisesid.
    +    Let's instead use an explicit lazy initialization pattern in
    +    session_id_advertise() itself, we'll still look the config up only
    +    once per-process, but by moving it out of serve() itself the further
    +    changing of that routine becomes easier.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
    - ## ls-refs.c ##
    + ## serve.c ##
     @@
    - #include "pkt-line.h"
    - #include "config.h"
    - 
    --static int config_read;
    --static int advertise_unborn;
    --static int allow_unborn;
    -+/* "unborn" is on by default if there's no lsrefs.unborn config */
    -+static int advertise_unborn = 1;
    -+static int allow_unborn = 1;
    - 
    --static void ensure_config_read(void)
    -+int ls_refs_startup_config(const char *var, const char *value, void *data)
    - {
    --	const char *str = NULL;
    --
    --	if (config_read)
    --		return;
    --
    --	if (repo_config_get_string_tmp(the_repository, "lsrefs.unborn", &str)) {
    --		/*
    --		 * If there is no such config, advertise and allow it by
    --		 * default.
    --		 */
    --		advertise_unborn = 1;
    --		allow_unborn = 1;
    --	} else {
    --		if (!strcmp(str, "advertise")) {
    --			advertise_unborn = 1;
    -+	if (!strcmp(var, "lsrefs.unborn")) {
    -+		if (!strcmp(value, "advertise")) {
    -+			/* Allowed and advertised by default */
    -+		} else if (!strcmp(value, "allow")) {
    -+			advertise_unborn = 0;
    - 			allow_unborn = 1;
    --		} else if (!strcmp(str, "allow")) {
    --			allow_unborn = 1;
    --		} else if (!strcmp(str, "ignore")) {
    --			/* do nothing */
    -+		} else if (!strcmp(value, "ignore")) {
    -+			advertise_unborn = 0;
    -+			allow_unborn = 0;
    - 		} else {
    --			die(_("invalid value '%s' for lsrefs.unborn"), str);
    -+			die(_("invalid value '%s' for lsrefs.unborn"), value);
    - 		}
    - 	}
    --	config_read = 1;
    -+	return 0;
    - }
    - 
    - /*
    -@@ ls-refs.c: int ls_refs(struct repository *r, struct strvec *keys,
    + #include "serve.h"
    + #include "upload-pack.h"
      
    - 	memset(&data, 0, sizeof(data));
    - 	strvec_init(&data.prefixes);
    +-static int advertise_sid;
     -
    --	ensure_config_read();
    - 	git_config(ls_refs_config, NULL);
    - 
    - 	while (packet_reader_read(request) == PACKET_READ_NORMAL) {
    -@@ ls-refs.c: int ls_refs(struct repository *r, struct strvec *keys,
    - int ls_refs_advertise(struct repository *r, struct strbuf *value)
    + static int always_advertise(struct repository *r,
    + 			    struct strbuf *value)
      {
    - 	if (value) {
    --		ensure_config_read();
    - 		if (advertise_unborn)
    - 			strbuf_addstr(value, "unborn");
    - 	}
    -
    - ## ls-refs.h ##
    -@@ ls-refs.h: struct strvec;
    - struct packet_reader;
    - int ls_refs(struct repository *r, struct strvec *keys,
    - 	    struct packet_reader *request);
    -+int ls_refs_startup_config(const char *var, const char *value, void *data);
    - int ls_refs_advertise(struct repository *r, struct strbuf *value);
    - 
    - #endif /* LS_REFS_H */
    -
    - ## serve.c ##
     @@ serve.c: static int object_format_advertise(struct repository *r,
      	return 1;
      }
      
    -+static int session_id_startup_config(const char *var, const char *value, void *data)
    -+{
    -+	if (!strcmp(var, "transfer.advertisesid"))
    -+		advertise_sid = git_config_bool(var, value);
    -+	return 0;
    -+}
    -+
    ++static int advertise_sid = -1;
      static int session_id_advertise(struct repository *r, struct strbuf *value)
      {
    ++	if (advertise_sid == -1 &&
    ++	    git_config_get_bool("transfer.advertisesid", &advertise_sid))
    ++		advertise_sid = 0;
      	if (!advertise_sid)
    -@@ serve.c: struct protocol_capability {
    - 	 */
    - 	const char *name;
    - 
    -+	/*
    -+	 * A git_config() callback that'll be called only once for the
    -+	 * lifetime of the process, possibly over many different
    -+	 * requests. Used for reading config that's expected to be
    -+	 * static.
    -+	 *
    -+	 * The "command" or "advertise" callbacks themselves are
    -+	 * expected to read config that needs to be more current than
    -+	 * that, or which is dependent on request data.
    -+	 */
    -+	int (*startup_config)(const char *var, const char *value, void *data);
    -+
    -+	/*
    -+	 * A boolean to check if we've called our "startup_config"
    -+	 * callback.
    -+	 */
    -+	int have_startup_config;
    -+
    - 	/*
    - 	 * Function queried to see if a capability should be advertised.
    - 	 * Optionally a value can be specified by adding it to 'value'.
    -@@ serve.c: static struct protocol_capability capabilities[] = {
    - 	},
    - 	{
    - 		.name = "ls-refs",
    -+		.startup_config = ls_refs_startup_config,
    - 		.advertise = ls_refs_advertise,
    - 		.command = ls_refs,
    - 	},
    -@@ serve.c: static struct protocol_capability capabilities[] = {
    - 	},
    - 	{
    - 		.name = "session-id",
    -+		.startup_config = session_id_startup_config,
    - 		.advertise = session_id_advertise,
    - 	},
    - 	{
    -@@ serve.c: static struct protocol_capability capabilities[] = {
    - 	},
    - };
    - 
    -+static void read_startup_config(struct protocol_capability *command)
    -+{
    -+	if (!command->startup_config)
    -+		return;
    -+	if (command->have_startup_config++)
    -+		return;
    -+	git_config(command->startup_config, NULL);
    -+}
    -+
    - static int call_advertise(struct protocol_capability *command,
    - 			  struct repository *r, struct strbuf *value)
    - {
    -+	read_startup_config(command);
    -+
    - 	return command->advertise(r, value);
    - }
    - 
    -@@ serve.c: static int call_command(struct protocol_capability *command,
    - 			struct repository *r, struct strvec *keys,
    - 			struct packet_reader *request)
    - {
    -+
    -+	read_startup_config(command);
    -+
    - 	return command->command(r, keys, request);
    - }
    - 
    + 		return 0;
    + 	if (value)
     @@ serve.c: static int process_request(void)
      /* Main serve loop for protocol version 2 */
      void serve(struct serve_options *options)
 23:  b7928ddbe9b = 101:  14ef399b177 serve.c: move version line to advertise_capabilities()
 28:  e4eb31b5b8e ! 102:  578eb3f9c3d serve.[ch]: don't pass "struct strvec *keys" to commands
    @@ Commit message
         2018-03-15) was passing in the raw capabilities "keys", but nothing
         downstream of it ever used them.
     
    -    Let's remove that code because it's not needed, and because if and
    -    when we need to pass data about the advertisement (I have some WIP
    -    patches for that), it makes much more sense to have the serve.c parse
    -    the capabilities, and then pass specific information we need down than
    -    expecting its API users to re-do their own parsing of the raw data.
    +    Let's remove that code because it's not needed. If we do end up
    +    needing to pass information about the advertisement in the future
    +    it'll make more sense to have serve.c parse the capabilities keys and
    +    pass the result of its parsing, rather than expecting expecting its
    +    API users to parse the same keys again.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
    @@ ls-refs.h
     -int ls_refs(struct repository *r, struct strvec *keys,
     -	    struct packet_reader *request);
     +int ls_refs(struct repository *r, struct packet_reader *request);
    - int ls_refs_startup_config(const char *var, const char *value, void *data);
      int ls_refs_advertise(struct repository *r, struct strbuf *value);
      
    + #endif /* LS_REFS_H */
     
      ## protocol-caps.c ##
     @@ protocol-caps.c: static void send_info(struct repository *r, struct packet_writer *writer,
    - 	strbuf_release(&send_buffer);
    + 	}
      }
      
     -int cap_object_info(struct repository *r, struct strvec *keys,
    @@ protocol-caps.h
      #endif /* PROTOCOL_CAPS_H */
     
      ## serve.c ##
    -@@ serve.c: static int session_id_advertise(struct repository *r, struct strbuf *value)
    - }
    - 
    - typedef int (*advertise_fn_t)(struct repository *r, struct strbuf *value);
    --typedef int (*command_fn_t)(struct repository *r, struct strvec *keys,
    -+typedef int (*command_fn_t)(struct repository *r,
    - 			    struct packet_reader *request);
    - 
    - struct protocol_capability {
     @@ serve.c: struct protocol_capability {
      
      	/*
    @@ serve.c: struct protocol_capability {
      	 * use to read the command specific part of the request.  Every command
      	 * MUST read until a flush packet is seen before sending a response.
      	 *
    -@@ serve.c: static int call_command(struct protocol_capability *command,
    + 	 * This field should be NULL for capabilities which are not commands.
    + 	 */
    +-	int (*command)(struct repository *r,
    +-		       struct strvec *keys,
    +-		       struct packet_reader *request);
    ++	int (*command)(struct repository *r, struct packet_reader *request);
    + };
      
    - 	read_startup_config(command);
    + static struct protocol_capability capabilities[] = {
    +@@ serve.c: static int process_request(void)
    + 	if (has_capability(&keys, "session-id", &client_sid))
    + 		trace2_data_string("transfer", NULL, "client-sid", client_sid);
      
    --	return command->command(r, keys, request);
    -+	return command->command(r, request);
    - }
    +-	command->command(the_repository, &keys, &reader);
    ++	command->command(the_repository, &reader);
      
    - void protocol_v2_advertise_capabilities(void)
    + 	strvec_clear(&keys);
    + 	return 0;
     
      ## upload-pack.c ##
     @@ upload-pack.c: enum fetch_state {
    @@ upload-pack.c: enum fetch_state {
      	struct upload_pack_data data;
     
      ## upload-pack.h ##
    -@@ upload-pack.h: void upload_pack(const int advertise_refs, const int stateless_rpc,
    - 		 const int timeout);
    +@@ upload-pack.h: struct upload_pack_options {
    + void upload_pack(struct upload_pack_options *options);
      
      struct repository;
     -struct strvec;
 24:  fb80f152713 ! 103:  e8c184912b3 serve.[ch]: remove "serve_options", split up --advertise-refs code
    @@ http-backend.c: static void get_info_refs(struct strbuf *hdr, char *arg)
      
     
      ## serve.c ##
    -@@ serve.c: static int call_command(struct protocol_capability *command,
    - 	return command->command(r, keys, request);
    - }
    +@@ serve.c: static struct protocol_capability capabilities[] = {
    + 	},
    + };
      
     -static void advertise_capabilities(void)
     +void protocol_v2_advertise_capabilities(void)
    @@ upload-pack.h
     +		 const int timeout);
      
      struct repository;
    - struct strvec;
    + struct packet_reader;
 25:  beafe9811c1 ! 104:  f519b2b5b23 {upload,receive}-pack tests: add --advertise-refs tests
    @@ Commit message
     
      ## t/t5555-http-smart-common.sh (new) ##
     @@
    ++#!/bin/sh
    ++
     +test_description='test functionality common to smart fetch & push'
     +
     +. ./test-lib.sh
 26:  c6870b5f18a = 105:  b28a9c76b30 upload-pack: document and rename --advertise-refs
-- 
2.33.0.rc0.587.gbfc8ffe61b6

