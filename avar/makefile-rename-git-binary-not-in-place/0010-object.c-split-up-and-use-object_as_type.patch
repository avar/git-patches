From 5526ca82c9c7195198aea03f7324e094d3a59efa Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=C3=86var=20Arnfj=C3=B6r=C3=B0=20Bjarmason?=
 <avarab@gmail.com>
Date: Thu, 4 Mar 2021 09:24:23 +0100
Subject: [PATCH 10/16] object.c: split up and use object_as_type()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Change code that rolled its own "expected obj to be type XYZ but it's
ABC" error handling to use new *_error() or *_die() versions of the
object_as_type() function.

This makes the errors in question more readable, since we'll say what
we got, not just what we expected (sometimes we didn't even say that
much).

Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
---
 builtin/index-pack.c |  9 +++------
 object.c             | 15 ++++++++++++---
 object.h             |  4 +++-
 tag.c                |  6 +++---
 tree.c               |  1 +
 5 files changed, 22 insertions(+), 13 deletions(-)

diff --git a/builtin/index-pack.c b/builtin/index-pack.c
index bad57488079..21484ed9a3b 100644
--- a/builtin/index-pack.c
+++ b/builtin/index-pack.c
@@ -217,8 +217,8 @@ static int mark_link(struct object *obj, int type, void *data, struct fsck_optio
 	if (!obj)
 		return -1;
 
-	if (type != OBJ_ANY && obj->type != type)
-		die(_("object type mismatch at %s"), oid_to_hex(&obj->oid));
+	if (type != OBJ_ANY)
+		object_is_type_or_die(obj, type);
 
 	obj->flags |= FLAG_LINK;
 	return 0;
@@ -240,10 +240,7 @@ static unsigned check_object(struct object *obj)
 		if (type <= 0)
 			die(_("did not receive expected object %s"),
 			      oid_to_hex(&obj->oid));
-		if (type != obj->type)
-			die(_("object %s: expected type %s, found %s"),
-			    oid_to_hex(&obj->oid),
-			    type_name(obj->type), type_name(type));
+		object_is_type_or_die(obj, type);
 		obj->flags |= FLAG_CHECKED;
 		return 1;
 	}
diff --git a/object.c b/object.c
index f827a7610a5..cb3c7ee7542 100644
--- a/object.c
+++ b/object.c
@@ -175,6 +175,16 @@ static int oid_is_type_or(const struct object_id *oid,
 		    type_name(type), type_name(want));
 }
 
+void object_is_type_or_die(struct object *obj, enum object_type want)
+{
+	oid_is_type_or(&obj->oid, obj->type, want, 0);
+}
+
+int object_is_type_or_error(struct object *obj, enum object_type want)
+{
+	return oid_is_type_or(&obj->oid, obj->type, want, 1);
+}
+
 void oid_is_type_or_die(const struct object_id *oid,
 			enum object_type want,
 			enum object_type *type)
@@ -202,9 +212,8 @@ void *object_as_type(struct object *obj, enum object_type type, int quiet)
 	}
 	else {
 		if (!quiet)
-			error(_("object %s is a %s, not a %s"),
-			      oid_to_hex(&obj->oid),
-			      type_name(obj->type), type_name(type));
+			object_is_type_or_error(obj, type);
+
 		return NULL;
 	}
 }
diff --git a/object.h b/object.h
index 6a92b118b37..009e8c4f671 100644
--- a/object.h
+++ b/object.h
@@ -122,7 +122,9 @@ struct object *lookup_object(struct repository *r, const struct object_id *oid);
 
 void *create_object(struct repository *r, const struct object_id *oid, void *obj);
 
-void *object_as_type(struct object *obj, enum object_type type, int quiet);
+void object_is_type_or_die(struct object *obj, enum object_type want);;
+int object_is_type_or_error(struct object *obj, enum object_type want);
+void *object_as_type(struct object *obj, enum object_type want, int quiet);
 
 void oid_is_type_or_die(const struct object_id *oid, enum object_type want,
 			enum object_type *type);;
diff --git a/tag.c b/tag.c
index 20ae1f4c180..8b6d0639e12 100644
--- a/tag.c
+++ b/tag.c
@@ -227,10 +227,10 @@ int parse_tag(struct tag *item)
 	if (!data)
 		return error("Could not read %s",
 			     oid_to_hex(&item->object.oid));
-	if (type != OBJ_TAG) {
+	ret = object_is_type_or_error(&item->object, OBJ_TAG);
+	if (ret) {
 		free(data);
-		return error("Object %s not a tag",
-			     oid_to_hex(&item->object.oid));
+		return ret;
 	}
 	ret = parse_tag_buffer(the_repository, item, data, size);
 	free(data);
diff --git a/tree.c b/tree.c
index a732f012286..f2873c75ae5 100644
--- a/tree.c
+++ b/tree.c
@@ -236,6 +236,7 @@ int parse_tree_gently(struct tree *item, int quiet_on_missing)
 		return quiet_on_missing ? -1 :
 			error("Could not read %s",
 			     oid_to_hex(&item->object.oid));
+
 	ret = oid_is_type_or_error(&item->object.oid, OBJ_TREE, &type);
 	if (ret) {
 		free(buffer);
-- 
2.31.0.rc0.126.g04f22c5b82

