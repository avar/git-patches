From 17c77ceba019f13adbd400d0d35c0f6478d655c8 Mon Sep 17 00:00:00 2001
Message-Id: <cover-v5-00.17-00000000000-20220802T154811Z-avarab@gmail.com>
In-Reply-To: <cover-v4-00.17-00000000000-20220728T162442Z-avarab@gmail.com>
References: <cover-v4-00.17-00000000000-20220728T162442Z-avarab@gmail.com>
From: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
Date: Tue, 2 Aug 2022 17:48:11 +0200
Subject: [PATCH v5 00/17] *** SUBJECT HERE ***
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

*** BLURB HERE ***

Ævar Arnfjörð Bjarmason (17):
  submodule--helper: fix a leak in "clone_submodule"
  submodule--helper: fix trivial get_default_remote_submodule() leak
  submodule--helper: fix most "struct pathspec" memory leaks
  submodule--helper: "struct pathspec" memory leak in module_update()
  submodule--helper: don't leak {run,capture}_command() cp.dir argument
  submodule--helper: add and use *_release() functions
  submodule--helper: fix "errmsg_str" memory leak
  submodule--helper: fix "sm_path" and other "module_cb_list" leaks
  submodule--helper: fix a leak with repo_clear()
  submodule--helper: fix a memory leak in get_default_remote_submodule()
  submodule--helper: fix "reference" leak
  submodule--helper: fix obscure leak in module_add()
  submodule--helper: fix a leak in module_add()
  submodule--helper: fix a memory leak in print_status()
  submodule--helper: free some "displaypath" in "struct update_data"
  submodule--helper: free rest of "displaypath" in "struct update_data"
  submodule--helper: fix a configure_added_submodule() leak

 builtin/submodule--helper.c        | 239 +++++++++++++++++++++--------
 t/t1500-rev-parse.sh               |   1 +
 t/t2403-worktree-move.sh           |   1 +
 t/t6008-rev-list-submodule.sh      |   1 +
 t/t6134-pathspec-in-submodule.sh   |   1 +
 t/t7412-submodule-absorbgitdirs.sh |   1 +
 t/t7413-submodule-is-active.sh     |   1 +
 t/t7414-submodule-mistakes.sh      |   2 +
 t/t7506-status-submodule.sh        |   1 +
 t/t7507-commit-verbose.sh          |   2 +
 10 files changed, 185 insertions(+), 65 deletions(-)

Range-diff against v4:
 1:  84b05bda016 <  -:  ----------- submodule tests: test usage behavior
 2:  9671169e348 <  -:  ----------- submodule tests: test for "add <repository> <abs-path>"
 3:  7aa9c14251b <  -:  ----------- submodule--helper: remove unused "name" helper
 4:  27df2efe718 <  -:  ----------- submodule--helper: remove unused "list" helper
 5:  9fe8deb165a <  -:  ----------- test-tool submodule-config: remove unused "--url" handling
 6:  8e4d2b09d56 <  -:  ----------- submodule--helper: move "is-active" to a test-tool
 7:  a2f3d812815 <  -:  ----------- submodule--helper: move "check-name" to a test-tool
 8:  8188657cdfa <  -:  ----------- submodule--helper: move "resolve-relative-url-test" to a test-tool
 9:  79a47f9b94d <  -:  ----------- submodule--helper style: don't separate declared variables with \n\n
21:  aac987a414a =  1:  118e965d401 submodule--helper: fix a leak in "clone_submodule"
22:  390c5174e17 !  2:  d885e1dd59a submodule--helper: fix trivial get_default_remote_submodule() leak
    @@ Commit message
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data,
    +@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
      		const char *branch = remote_submodule_branch(update_data->sm_path);
      		char *remote_ref = xstrfmt("refs/remotes/%s/%s", remote_name, branch);
      
23:  529e10233d5 =  3:  1f90348d61f submodule--helper: fix most "struct pathspec" memory leaks
24:  683d327752f =  4:  f768ff2e34d submodule--helper: "struct pathspec" memory leak in module_update()
25:  4e8e9197539 !  5:  509133c37fa submodule--helper: don't leak {run,capture}_command() cp.dir argument
    @@ builtin/submodule--helper.c: static int fetch_in_submodule(const char *module_pa
      
      	strvec_push(&cp.args, "fetch");
      	if (quiet)
    -@@ builtin/submodule--helper.c: static int run_update_command(struct update_data *ud, int subforce,
    +@@ builtin/submodule--helper.c: static int run_update_command(struct update_data *ud, int subforce)
      	}
      	strvec_push(&cp.args, oid);
      
    @@ builtin/submodule--helper.c: static int run_update_command(struct update_data *u
     +	cp.dir = ud->sm_path;
      	prepare_submodule_repo_env(&cp.env);
      	if (run_command(&cp)) {
    - 		switch (ud->update_strategy.type) {
    + 		int ret;
26:  575d3e8d2e2 !  6:  25377f1d06c submodule--helper: add and use *_release() functions
    @@ builtin/submodule--helper.c: static int update_submodules(struct update_data *up
      cleanup:
     +	submodule_update_clone_release(&suc);
      	string_list_clear(&update_data->references, 0);
    - 	return res;
    + 	return ret;
      }
     @@ builtin/submodule--helper.c: static int module_update(int argc, const char **argv, const char *prefix)
      
27:  d4c81e04254 =  7:  1a85057cd0c submodule--helper: fix "errmsg_str" memory leak
28:  ef9e29d5bfe =  8:  3c4f734e958 submodule--helper: fix "sm_path" and other "module_cb_list" leaks
14:  b364f3200d8 !  9:  3aebff9f8e3 submodule--helper: pass a "const struct module_clone_data" to clone_submodule()
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: pass a "const struct module_clone_data" to clone_submodule()
    +    submodule--helper: fix a leak with repo_clear()
     
    -    Add "const" to the "struct module_clone_data" that we pass to
    -    clone_submodule(), which makes the ownership clear, and stops us from
    -    clobbering the "clone_data->path".
    -
    -    We still need to add to the "reference" member, which is a "struct
    -    string_list". Let's do this by having clone_submodule() create its
    -    own, and copy the contents over, allowing us to pass it as a
    -    separate parameter.
    -
    -    This new "struct string_list" still leaks memory, just as the "struct
    -    module_clone_data" did before. let's not fix that for now, to fix that
    -    we'll need to add some "goto cleanup" to the relevant code. That will
    -    be done in a follow-up commits, at that point it'll be easier to fix
    -    the memory leak.
    -
    -    The scope of the new "reference" variable in add_submodule() could be
    -    narrowed to the "else" block, but as we'll eventually free it with a
    -    "goto cleanup" let's declare it at the start of the function.
    +    Call repo_clear() in ensure_core_worktree() to free the "struct
    +    repository". Fixes a leak that's been here since
    +    74d4731da1f (submodule--helper: replace connect-gitdir-workingtree by
    +    ensure-core-worktree, 2018-08-13).
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: struct module_clone_data {
    - 	const char *url;
    - 	const char *depth;
    - 	struct list_objects_filter_options *filter_options;
    --	struct string_list reference;
    - 	unsigned int quiet: 1;
    - 	unsigned int progress: 1;
    - 	unsigned int dissociate: 1;
    -@@ builtin/submodule--helper.c: struct module_clone_data {
    - 	int single_branch;
    - };
    - #define MODULE_CLONE_DATA_INIT { \
    --	.reference = STRING_LIST_INIT_NODUP, \
    - 	.single_branch = -1, \
    - }
    - 
    -@@ builtin/submodule--helper.c: static char *clone_submodule_sm_gitdir(const char *name)
    - 	return sm_gitdir;
    - }
    - 
    --static int clone_submodule(struct module_clone_data *clone_data)
    -+static int clone_submodule(const struct module_clone_data *clone_data,
    -+			   struct string_list *reference)
    - {
    - 	char *p;
    - 	char *sm_gitdir = clone_submodule_sm_gitdir(clone_data->name);
    - 	char *sm_alternate = NULL, *error_strategy = NULL;
    - 	struct child_process cp = CHILD_PROCESS_INIT;
    -+	const char *clone_data_path;
    - 
    - 	if (!is_absolute_path(clone_data->path))
    --		clone_data->path = xstrfmt("%s/%s", get_git_work_tree(),
    --					   clone_data->path);
    -+		clone_data_path = xstrfmt("%s/%s", get_git_work_tree(),
    -+					  clone_data->path);
    - 	else
    --		clone_data->path = xstrdup(clone_data->path);
    -+		clone_data_path = xstrdup(clone_data->path);
    - 
    - 	if (validate_submodule_git_dir(sm_gitdir, clone_data->name) < 0)
    - 		die(_("refusing to create/use '%s' in another submodule's "
    -@@ builtin/submodule--helper.c: static int clone_submodule(struct module_clone_data *clone_data)
    - 		if (safe_create_leading_directories_const(sm_gitdir) < 0)
    - 			die(_("could not create directory '%s'"), sm_gitdir);
    - 
    --		prepare_possible_alternates(clone_data->name, &clone_data->reference);
    -+		prepare_possible_alternates(clone_data->name, reference);
    - 
    - 		strvec_push(&cp.args, "clone");
    - 		strvec_push(&cp.args, "--no-checkout");
    -@@ builtin/submodule--helper.c: static int clone_submodule(struct module_clone_data *clone_data)
    - 			strvec_push(&cp.args, "--progress");
    - 		if (clone_data->depth && *(clone_data->depth))
    - 			strvec_pushl(&cp.args, "--depth", clone_data->depth, NULL);
    --		if (clone_data->reference.nr) {
    -+		if (reference->nr) {
    - 			struct string_list_item *item;
    - 
    --			for_each_string_list_item(item, &clone_data->reference)
    -+			for_each_string_list_item(item, reference)
    - 				strvec_pushl(&cp.args, "--reference",
    - 					     item->string, NULL);
    - 		}
    -@@ builtin/submodule--helper.c: static int clone_submodule(struct module_clone_data *clone_data)
    - 
    - 		strvec_push(&cp.args, "--");
    - 		strvec_push(&cp.args, clone_data->url);
    --		strvec_push(&cp.args, clone_data->path);
    -+		strvec_push(&cp.args, clone_data_path);
    - 
    - 		cp.git_cmd = 1;
    - 		prepare_submodule_repo_env(&cp.env);
    -@@ builtin/submodule--helper.c: static int clone_submodule(struct module_clone_data *clone_data)
    - 
    - 		if(run_command(&cp))
    - 			die(_("clone of '%s' into submodule path '%s' failed"),
    --			    clone_data->url, clone_data->path);
    -+			    clone_data->url, clone_data_path);
    - 	} else {
    - 		struct strbuf sb = STRBUF_INIT;
    - 
    --		if (clone_data->require_init && !access(clone_data->path, X_OK) &&
    --		    !is_empty_dir(clone_data->path))
    --			die(_("directory not empty: '%s'"), clone_data->path);
    --		if (safe_create_leading_directories_const(clone_data->path) < 0)
    --			die(_("could not create directory '%s'"), clone_data->path);
    -+		if (clone_data->require_init && !access(clone_data_path, X_OK) &&
    -+		    !is_empty_dir(clone_data_path))
    -+			die(_("directory not empty: '%s'"), clone_data_path);
    -+		if (safe_create_leading_directories_const(clone_data_path) < 0)
    -+			die(_("could not create directory '%s'"), clone_data_path);
    - 		strbuf_addf(&sb, "%s/index", sm_gitdir);
    - 		unlink_or_warn(sb.buf);
    +@@ builtin/submodule--helper.c: static int ensure_core_worktree(const char *path)
      		strbuf_release(&sb);
      	}
      
    --	connect_work_tree_and_git_dir(clone_data->path, sm_gitdir, 0);
    -+	connect_work_tree_and_git_dir(clone_data_path, sm_gitdir, 0);
    - 
    --	p = git_pathdup_submodule(clone_data->path, "config");
    -+	p = git_pathdup_submodule(clone_data_path, "config");
    - 	if (!p)
    --		die(_("could not get submodule directory for '%s'"), clone_data->path);
    -+		die(_("could not get submodule directory for '%s'"), clone_data_path);
    - 
    - 	/* setup alternateLocation and alternateErrorStrategy in the cloned submodule if needed */
    - 	git_config_get_string("submodule.alternateLocation", &sm_alternate);
    -@@ builtin/submodule--helper.c: static int module_clone(int argc, const char **argv, const char *prefix)
    - 	int dissociate = 0, quiet = 0, progress = 0, require_init = 0;
    - 	struct module_clone_data clone_data = MODULE_CLONE_DATA_INIT;
    - 	struct list_objects_filter_options filter_options = { 0 };
    -+	struct string_list reference = STRING_LIST_INIT_NODUP;
    - 	struct option module_clone_options[] = {
    - 		OPT_STRING(0, "prefix", &clone_data.prefix,
    - 			   N_("path"),
    -@@ builtin/submodule--helper.c: static int module_clone(int argc, const char **argv, const char *prefix)
    - 		OPT_STRING(0, "url", &clone_data.url,
    - 			   N_("string"),
    - 			   N_("url where to clone the submodule from")),
    --		OPT_STRING_LIST(0, "reference", &clone_data.reference,
    -+		OPT_STRING_LIST(0, "reference", &reference,
    - 			   N_("repo"),
    - 			   N_("reference repository")),
    - 		OPT_BOOL(0, "dissociate", &dissociate,
    -@@ builtin/submodule--helper.c: static int module_clone(int argc, const char **argv, const char *prefix)
    - 		usage_with_options(git_submodule_helper_usage,
    - 				   module_clone_options);
    - 
    --	clone_submodule(&clone_data);
    -+	clone_submodule(&clone_data, &reference);
    - 	list_objects_filter_release(&filter_options);
    ++	repo_clear(&subrepo);
      	return 0;
      }
    -@@ builtin/submodule--helper.c: static int add_submodule(const struct add_data *add_data)
    - {
    - 	char *submod_gitdir_path;
    - 	struct module_clone_data clone_data = MODULE_CLONE_DATA_INIT;
    -+	struct string_list reference = STRING_LIST_INIT_NODUP;
    - 
    - 	/* perhaps the path already exists and is already a git repo, else clone it */
    - 	if (is_directory(add_data->sm_path)) {
    -@@ builtin/submodule--helper.c: static int add_submodule(const struct add_data *add_data)
    - 		free(submod_gitdir_path);
    - 	} else {
    - 		struct child_process cp = CHILD_PROCESS_INIT;
    -+
    - 		submod_gitdir_path = xstrfmt(".git/modules/%s", add_data->sm_name);
    - 
    - 		if (is_directory(submod_gitdir_path)) {
    -@@ builtin/submodule--helper.c: static int add_submodule(const struct add_data *add_data)
    - 		clone_data.quiet = add_data->quiet;
    - 		clone_data.progress = add_data->progress;
    - 		if (add_data->reference_path)
    --			string_list_append(&clone_data.reference,
    -+			string_list_append(&reference,
    - 					   xstrdup(add_data->reference_path));
    - 		clone_data.dissociate = add_data->dissociate;
    - 		if (add_data->depth >= 0)
    - 			clone_data.depth = xstrfmt("%d", add_data->depth);
    - 
    --		if (clone_submodule(&clone_data))
    -+		if (clone_submodule(&clone_data, &reference))
    - 			return -1;
      
    - 		prepare_submodule_repo_env(&cp.env);
30:  dae2a6f8e07 = 10:  38345ec76bc submodule--helper: fix a memory leak in get_default_remote_submodule()
31:  e7352bb8cfa = 11:  4b1e5ced969 submodule--helper: fix "reference" leak
32:  1adb7b66656 = 12:  e74c396073b submodule--helper: fix obscure leak in module_add()
33:  b27b665d287 = 13:  71a56c59864 submodule--helper: fix a leak in module_add()
34:  53ba1705eb6 = 14:  2429db2f1c7 submodule--helper: fix a memory leak in print_status()
35:  230e5f8ad14 = 15:  613d077c4ec submodule--helper: free some "displaypath" in "struct update_data"
10:  5e13080f894 ! 16:  8f150a81507 submodule--helper style: add \n\n after variable declarations
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper style: add \n\n after variable declarations
    +    submodule--helper: free rest of "displaypath" in "struct update_data"
     
    -    Since the preceding commit fixed style issues with \n\n among the
    -    declared variables let's fix the minor stylistic issues with those
    -    variables not being consistently followed by a \n\n.
    +    Fix a leak in code added in c51f8f94e5b (submodule--helper: run update
    +    procedures from C, 2021-08-24), we clobber the "displaypath" member of
    +    the passed-in "struct update_data" both so that die() messages in this
    +    update_submodule() function itself can use it, and for the
    +    run_update_procedure() called within this function.
    +
    +    To make managing that clobbering easier let's wrap the
    +    update_submodule() in a new update_submodule_outer() function, which
    +    will do the clobbering and free(to_free) dance for us.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int module_list_compute(int argc, const char **argv,
    - {
    - 	int i, result = 0;
    - 	char *ps_matched = NULL;
    -+
    - 	parse_pathspec(pathspec, 0,
    - 		       PATHSPEC_PREFER_FULL,
    - 		       prefix, argv);
    -@@ builtin/submodule--helper.c: static void for_each_listed_submodule(const struct module_list *list,
    - 				      each_submodule_fn fn, void *cb_data)
    - {
    - 	int i;
    -+
    - 	for (i = 0; i < list->nr; i++)
    - 		fn(list->entries[i], cb_data);
    - }
    -@@ builtin/submodule--helper.c: static void runcommand_in_submodule_cb(const struct cache_entry *list_item,
    - 	struct foreach_cb *info = cb_data;
    - 	const char *path = list_item->name;
    - 	const struct object_id *ce_oid = &list_item->oid;
    --
    - 	const struct submodule *sub;
    - 	struct child_process cp = CHILD_PROCESS_INIT;
    - 	char *displaypath;
    -@@ builtin/submodule--helper.c: static void init_submodule(const char *path, const char *prefix,
    - 		if (starts_with_dot_dot_slash(url) ||
    - 		    starts_with_dot_slash(url)) {
    - 			char *oldurl = url;
    -+
    - 			url = resolve_relative_url(oldurl, NULL, 0);
    - 			free(oldurl);
    - 		}
    -@@ builtin/submodule--helper.c: static void init_submodule(const char *path, const char *prefix,
    - static void init_submodule_cb(const struct cache_entry *list_item, void *cb_data)
    +@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
      {
    - 	struct init_cb *info = cb_data;
    -+
    - 	init_submodule(list_item->name, info->prefix, info->flags);
    - }
    + 	int ret;
      
    -@@ builtin/submodule--helper.c: static int handle_submodule_head_ref(const char *refname,
    - 				     void *cb_data)
    - {
    - 	struct object_id *output = cb_data;
    -+
    - 	if (oid)
    - 		oidcpy(output, oid);
    - 
    -@@ builtin/submodule--helper.c: static void status_submodule_cb(const struct cache_entry *list_item,
    - 				void *cb_data)
    - {
    - 	struct status_cb *info = cb_data;
    -+
    - 	status_submodule(list_item->name, &list_item->oid, list_item->ce_flags,
    - 			 info->prefix, info->flags);
    - }
    -@@ builtin/submodule--helper.c: static void generate_submodule_summary(struct summary_cb *info,
    - 	if (!info->cached && oideq(&p->oid_dst, null_oid())) {
    - 		if (S_ISGITLINK(p->mod_dst)) {
    - 			struct ref_store *refs = get_submodule_ref_store(p->sm_path);
    -+
    - 			if (refs)
    - 				refs_head_ref(refs, handle_submodule_head_ref, &p->oid_dst);
    - 		} else if (S_ISLNK(p->mod_dst) || S_ISREG(p->mod_dst)) {
    -@@ builtin/submodule--helper.c: static void sync_submodule(const char *path, const char *prefix,
    - 		if (starts_with_dot_dot_slash(sub->url) ||
    - 		    starts_with_dot_slash(sub->url)) {
    - 			char *up_path = get_up_path(path);
    -+
    - 			sub_origin_url = resolve_relative_url(sub->url, up_path, 1);
    - 			super_config_url = resolve_relative_url(sub->url, NULL, 1);
    - 			free(up_path);
    -@@ builtin/submodule--helper.c: static void sync_submodule(const char *path, const char *prefix,
    - static void sync_submodule_cb(const struct cache_entry *list_item, void *cb_data)
    - {
    - 	struct sync_cb *info = cb_data;
    -+
    - 	sync_submodule(list_item->name, info->prefix, info->flags);
    +-	ret = ensure_core_worktree(update_data->sm_path);
    +-	if (ret)
    +-		return ret;
    +-
    +-	update_data->displaypath = get_submodule_displaypath(
    +-		update_data->sm_path, update_data->prefix);
    +-
    + 	ret = determine_submodule_update_strategy(the_repository,
    + 						  update_data->just_cloned,
    + 						  update_data->sm_path,
    +@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
    + 	return 0;
      }
      
    -@@ builtin/submodule--helper.c: static void deinit_submodule(const char *path, const char *prefix,
    - 
    - 		if (!(flags & OPT_FORCE)) {
    - 			struct child_process cp_rm = CHILD_PROCESS_INIT;
    ++static int update_submodule_outer(struct update_data *update_data)
    ++{
    ++	char *to_free, *restore = update_data->displaypath;
    ++	int ret;
     +
    - 			cp_rm.git_cmd = 1;
    - 			strvec_pushl(&cp_rm.args, "rm", "-qn",
    - 				     path, NULL);
    -@@ builtin/submodule--helper.c: static void deinit_submodule(const char *path, const char *prefix,
    - 	/* remove the .git/config entries (unless the user already did it) */
    - 	if (!capture_command(&cp_config, &sb_config, 0) && sb_config.len) {
    - 		char *sub_key = xstrfmt("submodule.%s", sub->name);
    ++	ensure_core_worktree(update_data->sm_path);
     +
    - 		/*
    - 		 * remove the whole section so we have a clean state when
    - 		 * the user later decides to init this submodule again
    -@@ builtin/submodule--helper.c: static int clone_submodule(struct module_clone_data *clone_data)
    - 			strvec_pushl(&cp.args, "--depth", clone_data->depth, NULL);
    - 		if (clone_data->reference.nr) {
    - 			struct string_list_item *item;
    ++	update_data->displaypath = to_free = get_submodule_displaypath(
    ++		update_data->sm_path, update_data->prefix);
     +
    - 			for_each_string_list_item(item, &clone_data->reference)
    - 				strvec_pushl(&cp.args, "--reference",
    - 					     item->string, NULL);
    -@@ builtin/submodule--helper.c: static int prepare_to_clone_next_submodule(const struct cache_entry *ce,
    - 	strvec_pushl(&child->args, "--url", url, NULL);
    - 	if (suc->update_data->references.nr) {
    - 		struct string_list_item *item;
    ++	ret = update_submodule(update_data);
     +
    - 		for_each_string_list_item(item, &suc->update_data->references)
    - 			strvec_pushl(&child->args, "--reference", item->string, NULL);
    - 	}
    -@@ builtin/submodule--helper.c: static int update_clone_get_next_task(struct child_process *child,
    - 		ce = suc->update_data->list.entries[suc->current];
    - 		if (prepare_to_clone_next_submodule(ce, child, suc, err)) {
    - 			int *p = xmalloc(sizeof(*p));
    ++	free(to_free);
    ++	update_data->displaypath = restore;
     +
    - 			*p = suc->current;
    - 			*idx_task_cb = p;
    - 			suc->current++;
    -@@ builtin/submodule--helper.c: static int update_clone_get_next_task(struct child_process *child,
    - 	index = suc->current - suc->update_data->list.nr;
    - 	if (index < suc->failed_clones_nr) {
    - 		int *p;
    ++	return ret;
    ++}
     +
    - 		ce = suc->failed_clones[index];
    - 		if (!prepare_to_clone_next_submodule(ce, child, suc, err)) {
    - 			suc->current ++;
    -@@ builtin/submodule--helper.c: static int update_clone_start_failure(struct strbuf *err,
    - 				      void *idx_task_cb)
    + static int update_submodules(struct update_data *update_data)
      {
    - 	struct submodule_update_clone *suc = suc_cb;
    -+
    - 	suc->quickstop = 1;
    - 	return 1;
    - }
    -@@ builtin/submodule--helper.c: static int update_clone_task_finished(int result,
    - {
    - 	const struct cache_entry *ce;
    - 	struct submodule_update_clone *suc = suc_cb;
    --
    - 	int *idxP = idx_task_cb;
    - 	int idx = *idxP;
    -+
    - 	free(idxP);
    + 	int i, ret = 0;
    +@@ builtin/submodule--helper.c: static int update_submodules(struct update_data *update_data)
    + 		update_data->just_cloned = ucd.just_cloned;
    + 		update_data->sm_path = ucd.sub->path;
      
    - 	if (!result)
    -@@ builtin/submodule--helper.c: static int git_update_clone_config(const char *var, const char *value,
    - 				   void *cb)
    - {
    - 	int *max_jobs = cb;
    -+
    - 	if (!strcmp(var, "submodule.fetchjobs"))
    - 		*max_jobs = parse_submodule_fetchjobs(var, value);
    - 	return 0;
    -@@ builtin/submodule--helper.c: static int fetch_in_submodule(const char *module_path, int depth, int quiet, str
    - 	if (oid) {
    - 		char *hex = oid_to_hex(oid);
    - 		char *remote = get_default_remote();
    -+
    - 		strvec_pushl(&cp.args, remote, hex, NULL);
    - 		free(remote);
    - 	}
    -@@ builtin/submodule--helper.c: static void update_data_to_args(struct update_data *update_data, struct strvec *
    - 
    - 	if (update_data->references.nr) {
    - 		struct string_list_item *item;
    -+
    - 		for_each_string_list_item(item, &update_data->references)
    - 			strvec_pushl(args, "--reference", item->string, NULL);
    - 	}
    -@@ builtin/submodule--helper.c: static void append_fetch_remotes(struct strbuf *msg, const char *git_dir_path)
    - 	if (!capture_command(&cp_remote, &sb_remote_out, 0)) {
    - 		char *next_line;
    - 		char *line = sb_remote_out.buf;
    -+
    - 		while ((next_line = strchr(line, '\n')) != NULL) {
    - 			size_t len = next_line - line;
    -+
    - 			if (strip_suffix_mem(line, &len, " (fetch)"))
    - 				strbuf_addf(msg, "  %.*s\n", (int)len, line);
    - 			line = next_line + 1;
    -@@ builtin/submodule--helper.c: static int module_add(int argc, const char **argv, const char *prefix)
    - 		int exit_code = -1;
    - 		struct strbuf sb = STRBUF_INIT;
    - 		struct child_process cp = CHILD_PROCESS_INIT;
    -+
    - 		cp.git_cmd = 1;
    - 		cp.no_stdout = 1;
    - 		strvec_pushl(&cp.args, "add", "--dry-run", "--ignore-missing",
    +-		code = update_submodule(update_data);
    ++		code = update_submodule_outer(update_data);
    + 		if (code)
    + 			ret = code;
    + 		if (code == 128)
11:  dc5ac924496 <  -:  ----------- submodule--helper: replace memset() with { 0 }-initialization
12:  08cc9ce2e24 <  -:  ----------- submodule--helper: convert a strbuf_detach() to xstrfmt()
13:  afe34d8b73b <  -:  ----------- submodule--helper: stop conflating "sb" in clone_submodule()
15:  e319f4edc54 <  -:  ----------- submodule--helper: add "const" to copy of "update_data"
16:  68202100d9a <  -:  ----------- submodule--helper: refactor "errmsg_str" to be a "struct strbuf"
17:  e8aacb55a18 <  -:  ----------- submodule--helper: rename "int res" to "int ret"
18:  41fb22d8549 <  -:  ----------- submodule--helper: add skeleton "goto cleanup" to update_submodule()
19:  5a26c9428be <  -:  ----------- submodule--helper: don't exit() on failure, return
20:  579560cb9a8 <  -:  ----------- submodule--helper: fix bad config API usage
29:  0798a00c9ef <  -:  ----------- submodule--helper: fix a leak with repo_clear()
36:  c0fba2f1c56 <  -:  ----------- submodule--helper: free rest of "displaypath" in "struct update_data"
37:  95f8b68bd41 ! 17:  17c77ceba01 submodule--helper: fix a configure_added_submodule() leak
    @@ builtin/submodule--helper.c: static void configure_added_submodule(struct add_da
      		 * current configured pathspec, set the submodule's active flag
     
      ## t/t7413-submodule-is-active.sh ##
    -@@ t/t7413-submodule-is-active.sh: This test verifies that `test-tool submodule is-active` correctly identifies
    - submodules which are "active" and interesting to the user.
    +@@ t/t7413-submodule-is-active.sh: This is a unit test of the submodule.c is_submodule_active() function,
    + which is also indirectly tested elsewhere.
      '
      
     +TEST_PASSES_SANITIZE_LEAK=true
-- 
2.37.1.1233.ge8b09efaedc

