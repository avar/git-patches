From d307c5e070609e2738b60f99f72fcdb20e5a1d28 Mon Sep 17 00:00:00 2001
Message-Id: <cover-v3-00.17-00000000000-20220821T123207Z-avarab@gmail.com>
In-Reply-To: <cover-00.20-00000000000-20220728T161116Z-avarab@gmail.com>
References: <cover-00.20-00000000000-20220728T161116Z-avarab@gmail.com>
From: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
Date: Sun, 21 Aug 2022 14:32:07 +0200
Subject: [PATCH v3 00/17] *** SUBJECT HERE ***
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

*** BLURB HERE ***

Ævar Arnfjörð Bjarmason (17):
  submodule--helper: fix a leak in "clone_submodule"
  submodule--helper: fix trivial get_default_remote_submodule() leak
  submodule--helper: fix most "struct pathspec" memory leaks
  submodule--helper: "struct pathspec" memory leak in module_update()
  submodule--helper: don't leak {run,capture}_command() cp.dir argument
  submodule--helper: add and use *_release() functions
  submodule--helper: fix "errmsg_str" memory leak
  submodule--helper: fix "sm_path" and other "module_cb_list" leaks
  submodule--helper: fix a leak with repo_clear()
  submodule--helper: fix a memory leak in get_default_remote_submodule()
  submodule--helper: fix "reference" leak
  submodule--helper: fix obscure leak in module_add()
  submodule--helper: fix a leak in module_add()
  submodule--helper: fix a memory leak in print_status()
  submodule--helper: free some "displaypath" in "struct update_data"
  submodule--helper: free rest of "displaypath" in "struct update_data"
  submodule--helper: fix a configure_added_submodule() leak

 builtin/submodule--helper.c        | 239 +++++++++++++++++++++--------
 t/t1500-rev-parse.sh               |   1 +
 t/t2403-worktree-move.sh           |   1 +
 t/t6008-rev-list-submodule.sh      |   1 +
 t/t6134-pathspec-in-submodule.sh   |   1 +
 t/t7412-submodule-absorbgitdirs.sh |   1 +
 t/t7413-submodule-is-active.sh     |   1 +
 t/t7414-submodule-mistakes.sh      |   2 +
 t/t7506-status-submodule.sh        |   1 +
 t/t7507-commit-verbose.sh          |   2 +
 10 files changed, 185 insertions(+), 65 deletions(-)

Range-diff against v2:
 1:  daa5d3f9962 <  -:  ----------- submodule tests: test usage behavior
 2:  9d920326df3 <  -:  ----------- submodule tests: test for "add <repository> <abs-path>"
24:  d33260487bd !  1:  4ba4e25c0a2 submodule--helper: don't exit() on failure, return
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: don't exit() on failure, return
    +    submodule--helper: fix a leak in "clone_submodule"
     
    -    Change code downstream of module_update() to short-circuit and return
    -    to the top-level on failure, rather than calling exit().
    +    Fix a memory leak of the "clone_data_path" variable that we copy or
    +    derive from the "struct module_clone_data" in clone_submodule(). This
    +    code was refactored in preceding commits, but the leak has been with
    +    us since f8eaa0ba98b (submodule--helper, module_clone: always operate
    +    on absolute paths, 2016-03-31).
     
    -    To do so we need to diligently check whether we "must_die_on_failure",
    -    which is a pattern started in c51f8f94e5b (submodule--helper: run
    -    update procedures from C, 2021-08-24), but which hadn't been completed
    -    to the point where we could avoid calling exit() here.
    +    For the "else" case we don't need to xstrdup() the "clone_data->path",
    +    and we don't need to free our own "clone_data_path". We can therefore
    +    assign the "clone_data->path" to our own "clone_data_path" right away,
    +    and only override it (and remember to free it!) if we need to
    +    xstrfmt() a replacement.
     
    -    This introduces no functional changes, but makes it easier to both
    -    call these routines as a library in the future, and to eventually
    -    avoid leaking memory.
    +    In the case of the module_clone() caller it's from "argv", and doesn't
    +    need to be free'd, and in the case of the add_submodule() caller we
    +    get a pointer to "sm_path", which doesn't need to be directly free'd
    +    either.
     
    -    This and similar control flow in submodule--helper.c could be made
    -    simpler by properly "libifying" it, i.e. to have it consistently
    -    return -1 on failures, and to early return on any non-success.
    -
    -    But let's leave that larger project for now, and (mostly) emulate what
    -    were doing with the "exit(128)" before this change.
    +    Fixing this leak makes several tests pass, so let's mark them as
    +    passing with TEST_PASSES_SANITIZE_LEAK=true.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int fetch_in_submodule(const char *module_path, int depth, int quiet, str
    - 	return run_command(&cp);
    - }
    - 
    --static int run_update_command(struct update_data *ud, int subforce)
    -+static int run_update_command(struct update_data *ud, int subforce,
    -+			      int *must_die_on_failure)
    - {
    +@@ builtin/submodule--helper.c: static int clone_submodule(const struct module_clone_data *clone_data,
    + 	char *sm_gitdir = clone_submodule_sm_gitdir(clone_data->name);
    + 	char *sm_alternate = NULL, *error_strategy = NULL;
      	struct child_process cp = CHILD_PROCESS_INIT;
    - 	char *oid = oid_to_hex(&ud->oid);
    -@@ builtin/submodule--helper.c: static int run_update_command(struct update_data *ud, int subforce)
    - 		}
    - 
    - 		if (ret == 128)
    --			exit(ret);
    -+			*must_die_on_failure = 1;
    - 		return ret;
    - 	}
    - 
    -@@ builtin/submodule--helper.c: static int run_update_command(struct update_data *ud, int subforce)
    +-	const char *clone_data_path;
    ++	const char *clone_data_path = clone_data->path;
    ++	char *to_free = NULL;
    + 
    + 	if (!is_absolute_path(clone_data->path))
    +-		clone_data_path = xstrfmt("%s/%s", get_git_work_tree(),
    +-					  clone_data->path);
    +-	else
    +-		clone_data_path = xstrdup(clone_data->path);
    ++		clone_data_path = to_free = xstrfmt("%s/%s", get_git_work_tree(),
    ++						    clone_data->path);
    + 
    + 	if (validate_submodule_git_dir(sm_gitdir, clone_data->name) < 0)
    + 		die(_("refusing to create/use '%s' in another submodule's "
    +@@ builtin/submodule--helper.c: static int clone_submodule(const struct module_clone_data *clone_data,
    + 
    + 	free(sm_gitdir);
    + 	free(p);
    ++	free(to_free);
      	return 0;
      }
      
    --static int run_update_procedure(struct update_data *ud)
    -+static int run_update_procedure(struct update_data *ud,
    -+				int *must_die_on_failure)
    - {
    - 	int subforce = is_null_oid(&ud->suboid) || ud->force;
    - 
    -@@ builtin/submodule--helper.c: static int run_update_procedure(struct update_data *ud)
    - 			    ud->displaypath, oid_to_hex(&ud->oid));
    - 	}
    +
    + ## t/t1500-rev-parse.sh ##
    +@@ t/t1500-rev-parse.sh: test_description='test git rev-parse'
    + GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME=main
    + export GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME
      
    --	return run_update_command(ud, subforce);
    -+	return run_update_command(ud, subforce, must_die_on_failure);
    - }
    ++TEST_PASSES_SANITIZE_LEAK=true
    + . ./test-lib.sh
      
    - static const char *remote_submodule_branch(const char *path)
    -@@ builtin/submodule--helper.c: static void update_data_to_args(struct update_data *update_data, struct strvec *
    - 				    "--no-single-branch");
    - }
    + test_one () {
    +
    + ## t/t6008-rev-list-submodule.sh ##
    +@@ t/t6008-rev-list-submodule.sh: test_description='git rev-list involving submodules that this repo has'
    + GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME=main
    + export GIT_TEST_DEFAULT_INITIAL_BRANCH_NAME
      
    --static int update_submodule(struct update_data *update_data)
    -+static int update_submodule(struct update_data *update_data,
    -+			    int *must_die_on_failure)
    - {
    - 	ensure_core_worktree(update_data->sm_path);
    ++TEST_PASSES_SANITIZE_LEAK=true
    + . ./test-lib.sh
      
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
    - 		free(remote_ref);
    - 	}
    + test_expect_success 'setup' '
    +
    + ## t/t7414-submodule-mistakes.sh ##
    +@@
    + #!/bin/sh
      
    --	if (!oideq(&update_data->oid, &update_data->suboid) || update_data->force)
    --		if (run_update_procedure(update_data))
    -+	if (!oideq(&update_data->oid, &update_data->suboid) || update_data->force) {
    -+		int ret;
    + test_description='handling of common mistakes people may make with submodules'
     +
    -+		ret = run_update_procedure(update_data, must_die_on_failure);
    -+		if (*must_die_on_failure)
    -+			return ret;
    -+		if (ret)
    - 			return 1;
    -+	}
    ++TEST_PASSES_SANITIZE_LEAK=true
    + . ./test-lib.sh
      
    - 	if (update_data->recursive) {
    - 		struct child_process cp = CHILD_PROCESS_INIT;
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
    - 		die_message(_("Failed to recurse into submodule path '%s'"),
    - 			    update_data->displaypath);
    - 		if (ret == 128)
    --			exit(ret);
    -+			*must_die_on_failure = 1;
    - 		return ret;
    - 	}
    + test_expect_success 'create embedded repository' '
    +
    + ## t/t7506-status-submodule.sh ##
    +@@
      
    -@@ builtin/submodule--helper.c: static int update_submodules(struct update_data *update_data)
    + test_description='git status for submodule'
      
    - 	for (i = 0; i < suc.update_clone_nr; i++) {
    - 		struct update_clone_data ucd = suc.update_clone[i];
    -+		int must_die_on_failure = 0;
    -+		int code;
    ++TEST_PASSES_SANITIZE_LEAK=true
    + . ./test-lib.sh
      
    - 		oidcpy(&update_data->oid, &ucd.oid);
    - 		update_data->just_cloned = ucd.just_cloned;
    - 		update_data->sm_path = ucd.sub->path;
    + test_create_repo_with_commit () {
    +
    + ## t/t7507-commit-verbose.sh ##
    +@@
    + #!/bin/sh
      
    --		if (update_submodule(update_data))
    -+		code = update_submodule(update_data, &must_die_on_failure);
    -+		if (code)
    -+			ret = code;
    -+		if (must_die_on_failure)
    -+			goto cleanup;
    -+		else if (code)
    - 			ret = 1;
    - 	}
    + test_description='verbose commit template'
    ++
    ++TEST_PASSES_SANITIZE_LEAK=true
    + . ./test-lib.sh
      
    + write_script "check-for-diff" <<\EOF &&
27:  93cd1ccde54 !  2:  bb6d02b14eb submodule--helper: libify "must_die_on_failure" code paths (for die)
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: libify "must_die_on_failure" code paths (for die)
    +    submodule--helper: fix trivial get_default_remote_submodule() leak
     
    -    Continue the libification of codepaths that previously relied on
    -    "must_die_on_failure". In these cases we've always been early aborting
    -    by calling die(), but as we know that these codpaths will properly
    -    handle return codes of 128 to mean an early abort let's have them use
    -    die_message() instead.
    -
    -    This still isn't a complete migration away from die() for these
    -    codepaths, in particular this code in update_submodule() will still call die() in some cases:
    -
    -            char *remote_name = get_default_remote_submodule(update_data->sm_path);
    -            const char *branch = remote_submodule_branch(update_data->sm_path);
    -
    -    But as that code is used by other callers than the "update" code let's
    -    leave converting it for now.
    +    Fix a leak in code added in 1012a5cbc3f (submodule--helper
    +    run-update-procedure: learn --remote, 2022-03-04), we need to free()
    +    the xstrdup()'d string. This gets e.g. t/t7419-submodule-set-branch.sh
    +    closer to passing under SANITIZE=leak.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int run_update_procedure(struct update_data *ud)
    - 		 */
    - 		if (!is_tip_reachable(ud->sm_path, &ud->oid) &&
    - 		    fetch_in_submodule(ud->sm_path, ud->depth, ud->quiet, &ud->oid))
    --			die(_("Fetched in submodule path '%s', but it did not "
    --			      "contain %s. Direct fetching of that commit failed."),
    --			    ud->displaypath, oid_to_hex(&ud->oid));
    -+			return die_message(_("Fetched in submodule path '%s', but it did not "
    -+					     "contain %s. Direct fetching of that commit failed."),
    -+					   ud->displaypath, oid_to_hex(&ud->oid));
    - 	}
    - 
    - 	return run_update_command(ud, subforce);
    -@@ builtin/submodule--helper.c: static const char *remote_submodule_branch(const char *path)
    - 	return branch;
    - }
    - 
    --static void ensure_core_worktree(const char *path)
    -+static int ensure_core_worktree(const char *path)
    - {
    - 	const char *cw;
    - 	struct repository subrepo;
    - 
    - 	if (repo_submodule_init(&subrepo, the_repository, path, null_oid()))
    --		die(_("could not get a repository handle for submodule '%s'"), path);
    -+		return die_message(_("could not get a repository handle for submodule '%s'"),
    -+				   path);
    - 
    - 	if (!repo_config_get_string_tmp(&subrepo, "core.worktree", &cw)) {
    - 		char *cfg_file, *abs_path;
    -@@ builtin/submodule--helper.c: static void ensure_core_worktree(const char *path)
    - 		free(abs_path);
    - 		strbuf_release(&sb);
    - 	}
    -+
    -+	return 0;
    - }
    - 
    - static const char *submodule_update_type_to_label(enum submodule_update_type type)
     @@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
    - {
    - 	int ret;
    + 			return code;
    + 		remote_ref = xstrfmt("refs/remotes/%s/%s", remote_name, branch);
      
    --	ensure_core_worktree(update_data->sm_path);
    -+	ret = ensure_core_worktree(update_data->sm_path);
    -+	if (ret)
    -+		return ret;
    - 
    - 	update_data->displaypath = get_submodule_displaypath(
    - 		update_data->sm_path, update_data->prefix);
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
    - 						  update_data->sm_path,
    - 						  update_data->update_default,
    - 						  &update_data->update_strategy);
    --	if (ret) {
    --		*must_die_on_failure = 1;
    -+	if (ret)
    - 		return ret;
    --	}
    - 
    - 	if (update_data->just_cloned)
    - 		oidcpy(&update_data->suboid, null_oid());
    - 	else if (resolve_gitlink_ref(update_data->sm_path, "HEAD", &update_data->suboid))
    --		die(_("Unable to find current revision in submodule path '%s'"),
    --			update_data->displaypath);
    -+		return die_message(_("Unable to find current revision in submodule path '%s'"),
    -+				   update_data->displaypath);
    - 
    - 	if (update_data->remote) {
    - 		char *remote_name = get_default_remote_submodule(update_data->sm_path);
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
    ++		free(remote_name);
    ++
      		if (!update_data->nofetch) {
      			if (fetch_in_submodule(update_data->sm_path, update_data->depth,
      					      0, NULL))
    --				die(_("Unable to fetch in submodule path '%s'"),
    --				    update_data->sm_path);
    -+				return die_message(_("Unable to fetch in submodule path '%s'"),
    -+						   update_data->sm_path);
    - 		}
    - 
    - 		if (resolve_gitlink_ref(update_data->sm_path, remote_ref, &update_data->oid))
    --			die(_("Unable to find %s revision in submodule path '%s'"),
    --			    remote_ref, update_data->sm_path);
    -+			return die_message(_("Unable to find %s revision in submodule path '%s'"),
    -+					   remote_ref, update_data->sm_path);
    - 
    - 		free(remote_ref);
    - 	}
 9:  b0238f699ce !  3:  873a44f2ba9 submodule--helper style: don't separate declared variables with \n\n
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper style: don't separate declared variables with \n\n
    +    submodule--helper: fix most "struct pathspec" memory leaks
     
    -    The usual style in the codebase is to separate declared variables with
    -    a single newline, not two, let's adjust this code to conform to
    -    that. This makes the eventual addition of various "int ret" variables
    -    more consistent.
    +    Call clear_pathspec() at the end of various functions that work with
    +    and allocate a "struct pathspec".
     
    -    In doing this the comment added in 2964d6e5e1e (submodule: port
    -    subcommand 'set-branch' from shell to C, 2020-06-02) might become
    -    ambiguous to some, although it should be clear what it's referring to,
    -    let's move it above the 'OPT_NOOP_NOARG('q', "quiet")' to make that
    -    clearer.
    +    In some cases the zero-initialization here isn't strictly needed, but
    +    as we're moving to a "goto cleanup" pattern let's make sure that it's
    +    safe to call clear_pathspec(), we don't want the data to be
    +    uninitialized.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int module_foreach(int argc, const char **argv, const char *prefix)
    +@@ builtin/submodule--helper.c: static void runcommand_in_submodule_cb(const struct cache_entry *list_item,
    + static int module_foreach(int argc, const char **argv, const char *prefix)
    + {
      	struct foreach_cb info = FOREACH_CB_INIT;
    - 	struct pathspec pathspec;
    +-	struct pathspec pathspec;
    ++	struct pathspec pathspec = { 0 };
      	struct module_list list = MODULE_LIST_INIT;
    --
      	struct option module_foreach_options[] = {
      		OPT__QUIET(&info.quiet, N_("suppress output of entering each submodule command")),
    - 		OPT_BOOL(0, "recursive", &info.recursive,
    - 			 N_("recurse into nested submodules")),
    - 		OPT_END()
    - 	};
    --
    - 	const char *const git_submodule_helper_usage[] = {
    +@@ builtin/submodule--helper.c: static int module_foreach(int argc, const char **argv, const char *prefix)
      		N_("git submodule foreach [--quiet] [--recursive] [--] <command>"),
      		NULL
    -@@ builtin/submodule--helper.c: static int module_init(int argc, const char **argv, const char *prefix)
    - 	struct pathspec pathspec;
    + 	};
    ++	int ret = 1;
    + 
    + 	argc = parse_options(argc, argv, prefix, module_foreach_options,
    + 			     git_submodule_helper_usage, 0);
    + 
    + 	if (module_list_compute(0, NULL, prefix, &pathspec, &list) < 0)
    +-		return 1;
    ++		goto cleanup;
    + 
    + 	info.argc = argc;
    + 	info.argv = argv;
    +@@ builtin/submodule--helper.c: static int module_foreach(int argc, const char **argv, const char *prefix)
    + 
    + 	for_each_listed_submodule(&list, runcommand_in_submodule_cb, &info);
    + 
    +-	return 0;
    ++	ret = 0;
    ++cleanup:
    ++	clear_pathspec(&pathspec);
    ++	return ret;
    + }
    + 
    + static int starts_with_dot_slash(const char *const path)
    +@@ builtin/submodule--helper.c: static void init_submodule_cb(const struct cache_entry *list_item, void *cb_data
    + static int module_init(int argc, const char **argv, const char *prefix)
    + {
    + 	struct init_cb info = INIT_CB_INIT;
    +-	struct pathspec pathspec;
    ++	struct pathspec pathspec = { 0 };
      	struct module_list list = MODULE_LIST_INIT;
      	int quiet = 0;
    --
      	struct option module_init_options[] = {
    - 		OPT__QUIET(&quiet, N_("suppress output for initializing a submodule")),
    - 		OPT_END()
    - 	};
    --
    - 	const char *const git_submodule_helper_usage[] = {
    +@@ builtin/submodule--helper.c: static int module_init(int argc, const char **argv, const char *prefix)
      		N_("git submodule init [<options>] [<path>]"),
      		NULL
    -@@ builtin/submodule--helper.c: static int module_status(int argc, const char **argv, const char *prefix)
    - 	struct pathspec pathspec;
    + 	};
    ++	int ret = 1;
    + 
    + 	argc = parse_options(argc, argv, prefix, module_init_options,
    + 			     git_submodule_helper_usage, 0);
    + 
    + 	if (module_list_compute(argc, argv, prefix, &pathspec, &list) < 0)
    +-		return 1;
    ++		goto cleanup;
    + 
    + 	/*
    + 	 * If there are no path args and submodule.active is set then,
    +@@ builtin/submodule--helper.c: static int module_init(int argc, const char **argv, const char *prefix)
    + 
    + 	for_each_listed_submodule(&list, init_submodule_cb, &info);
    + 
    +-	return 0;
    ++	ret = 0;
    ++cleanup:
    ++	clear_pathspec(&pathspec);
    ++	return ret;
    + }
    + 
    + struct status_cb {
    +@@ builtin/submodule--helper.c: static void status_submodule_cb(const struct cache_entry *list_item,
    + static int module_status(int argc, const char **argv, const char *prefix)
    + {
    + 	struct status_cb info = STATUS_CB_INIT;
    +-	struct pathspec pathspec;
    ++	struct pathspec pathspec = { 0 };
      	struct module_list list = MODULE_LIST_INIT;
      	int quiet = 0;
    --
      	struct option module_status_options[] = {
    - 		OPT__QUIET(&quiet, N_("suppress submodule status output")),
    - 		OPT_BIT(0, "cached", &info.flags, N_("use commit stored in the index instead of the one stored in the submodule HEAD"), OPT_CACHED),
    - 		OPT_BIT(0, "recursive", &info.flags, N_("recurse into nested submodules"), OPT_RECURSIVE),
    - 		OPT_END()
    - 	};
    --
    - 	const char *const git_submodule_helper_usage[] = {
    +@@ builtin/submodule--helper.c: static int module_status(int argc, const char **argv, const char *prefix)
      		N_("git submodule status [--quiet] [--cached] [--recursive] [<path>...]"),
      		NULL
    -@@ builtin/submodule--helper.c: static int module_summary(int argc, const char **argv, const char *prefix)
    - 	enum diff_cmd diff_cmd = DIFF_INDEX;
    - 	struct object_id head_oid;
    - 	int ret;
    --
    - 	struct option module_summary_options[] = {
    - 		OPT_BOOL(0, "cached", &cached,
    - 			 N_("use the commit stored in the index instead of the submodule HEAD")),
    -@@ builtin/submodule--helper.c: static int module_summary(int argc, const char **argv, const char *prefix)
    - 			     N_("limit the summary size")),
    - 		OPT_END()
      	};
    --
    - 	const char *const git_submodule_helper_usage[] = {
    - 		N_("git submodule summary [<options>] [<commit>] [--] [<path>]"),
    - 		NULL
    -@@ builtin/submodule--helper.c: static int module_sync(int argc, const char **argv, const char *prefix)
    ++	int ret = 1;
    + 
    + 	argc = parse_options(argc, argv, prefix, module_status_options,
    + 			     git_submodule_helper_usage, 0);
    + 
    + 	if (module_list_compute(argc, argv, prefix, &pathspec, &list) < 0)
    +-		return 1;
    ++		goto cleanup;
    + 
    + 	info.prefix = prefix;
    + 	if (quiet)
    +@@ builtin/submodule--helper.c: static int module_status(int argc, const char **argv, const char *prefix)
    + 
    + 	for_each_listed_submodule(&list, status_submodule_cb, &info);
    + 
    +-	return 0;
    ++	ret = 0;
    ++cleanup:
    ++	clear_pathspec(&pathspec);
    ++	return ret;
    + }
    + 
    + struct module_cb {
    +@@ builtin/submodule--helper.c: static void sync_submodule_cb(const struct cache_entry *list_item, void *cb_data
    + static int module_sync(int argc, const char **argv, const char *prefix)
    + {
    + 	struct sync_cb info = SYNC_CB_INIT;
    +-	struct pathspec pathspec;
    ++	struct pathspec pathspec = { 0 };
      	struct module_list list = MODULE_LIST_INIT;
      	int quiet = 0;
      	int recursive = 0;
    --
    - 	struct option module_sync_options[] = {
    - 		OPT__QUIET(&quiet, N_("suppress output of synchronizing submodule url")),
    - 		OPT_BOOL(0, "recursive", &recursive,
    - 			N_("recurse into nested submodules")),
    - 		OPT_END()
    - 	};
    --
    - 	const char *const git_submodule_helper_usage[] = {
    +@@ builtin/submodule--helper.c: static int module_sync(int argc, const char **argv, const char *prefix)
      		N_("git submodule sync [--quiet] [--recursive] [<path>]"),
      		NULL
    -@@ builtin/submodule--helper.c: static int module_deinit(int argc, const char **argv, const char *prefix)
    + 	};
    ++	int ret = 1;
    + 
    + 	argc = parse_options(argc, argv, prefix, module_sync_options,
    + 			     git_submodule_helper_usage, 0);
    + 
    + 	if (module_list_compute(argc, argv, prefix, &pathspec, &list) < 0)
    +-		return 1;
    ++		goto cleanup;
    + 
    + 	info.prefix = prefix;
    + 	if (quiet)
    +@@ builtin/submodule--helper.c: static int module_sync(int argc, const char **argv, const char *prefix)
    + 
    + 	for_each_listed_submodule(&list, sync_submodule_cb, &info);
    + 
    +-	return 0;
    ++	ret = 0;
    ++cleanup:
    ++	clear_pathspec(&pathspec);
    ++	return ret;
    + }
    + 
    + struct deinit_cb {
    +@@ builtin/submodule--helper.c: static void deinit_submodule_cb(const struct cache_entry *list_item,
    + static int module_deinit(int argc, const char **argv, const char *prefix)
    + {
    + 	struct deinit_cb info = DEINIT_CB_INIT;
    +-	struct pathspec pathspec;
    ++	struct pathspec pathspec = { 0 };
    + 	struct module_list list = MODULE_LIST_INIT;
      	int quiet = 0;
      	int force = 0;
    - 	int all = 0;
    --
    - 	struct option module_deinit_options[] = {
    - 		OPT__QUIET(&quiet, N_("suppress submodule status output")),
    - 		OPT__FORCE(&force, N_("remove submodule working trees even if they contain local changes"), 0),
    - 		OPT_BOOL(0, "all", &all, N_("unregister all submodules")),
    - 		OPT_END()
    - 	};
    --
    - 	const char *const git_submodule_helper_usage[] = {
    +@@ builtin/submodule--helper.c: static int module_deinit(int argc, const char **argv, const char *prefix)
      		N_("git submodule deinit [--quiet] [-f | --force] [--all | [--] [<path>...]]"),
      		NULL
    -@@ builtin/submodule--helper.c: static int module_clone(int argc, const char **argv, const char *prefix)
    - 	int dissociate = 0, quiet = 0, progress = 0, require_init = 0;
    - 	struct module_clone_data clone_data = MODULE_CLONE_DATA_INIT;
    - 	struct list_objects_filter_options filter_options;
    --
    - 	struct option module_clone_options[] = {
    - 		OPT_STRING(0, "prefix", &clone_data.prefix,
    - 			   N_("path"),
    -@@ builtin/submodule--helper.c: static int module_clone(int argc, const char **argv, const char *prefix)
    - 		OPT_PARSE_LIST_OBJECTS_FILTER(&filter_options),
    - 		OPT_END()
      	};
    --
    - 	const char *const git_submodule_helper_usage[] = {
    - 		N_("git submodule--helper clone [--prefix=<path>] [--quiet] "
    - 		   "[--reference <repository>] [--name <name>] [--depth <depth>] "
    -@@ builtin/submodule--helper.c: static int module_update(int argc, const char **argv, const char *prefix)
    ++	int ret = 1;
    + 
    + 	argc = parse_options(argc, argv, prefix, module_deinit_options,
    + 			     git_submodule_helper_usage, 0);
    +@@ builtin/submodule--helper.c: static int module_deinit(int argc, const char **argv, const char *prefix)
    + 		die(_("Use '--all' if you really want to deinitialize all submodules"));
    + 
    + 	if (module_list_compute(argc, argv, prefix, &pathspec, &list) < 0)
    +-		return 1;
    ++		goto cleanup;
    + 
    + 	info.prefix = prefix;
    + 	if (quiet)
    +@@ builtin/submodule--helper.c: static int module_deinit(int argc, const char **argv, const char *prefix)
    + 
    + 	for_each_listed_submodule(&list, deinit_submodule_cb, &info);
    + 
    +-	return 0;
    ++	ret = 0;
    ++cleanup:
    ++	clear_pathspec(&pathspec);
    ++	return ret;
    + }
    + 
    + struct module_clone_data {
    +@@ builtin/submodule--helper.c: static int update_submodules(struct update_data *update_data)
    + 
    + static int module_update(int argc, const char **argv, const char *prefix)
    + {
    +-	struct pathspec pathspec;
    ++	struct pathspec pathspec = { 0 };
      	struct update_data opt = UPDATE_DATA_INIT;
    - 	struct list_objects_filter_options filter_options;
    + 	struct list_objects_filter_options filter_options = { 0 };
      	int ret;
    --
    - 	struct option module_update_options[] = {
    - 		OPT__FORCE(&opt.force, N_("force checkout updates"), 0),
    - 		OPT_BOOL(0, "init", &opt.init,
     @@ builtin/submodule--helper.c: static int module_update(int argc, const char **argv, const char *prefix)
    - 		OPT_PARSE_LIST_OBJECTS_FILTER(&filter_options),
    - 		OPT_END()
    - 	};
    --
    - 	const char *const git_submodule_helper_usage[] = {
    - 		N_("git submodule [--quiet] update"
    - 		" [--init [--filter=<filter-spec>]] [--remote]"
    -@@ builtin/submodule--helper.c: static int absorb_git_dirs(int argc, const char **argv, const char *prefix)
    - 	struct pathspec pathspec;
    + 		opt.update_strategy.type = opt.update_default;
    + 
    + 	if (module_list_compute(argc, argv, prefix, &pathspec, &opt.list) < 0) {
    +-		list_objects_filter_release(&filter_options);
    +-		return 1;
    ++		ret = 1;
    ++		goto cleanup;
    + 	}
    + 
    + 	if (pathspec.nr)
    +@@ builtin/submodule--helper.c: static int module_update(int argc, const char **argv, const char *prefix)
    + 		struct init_cb info = INIT_CB_INIT;
    + 
    + 		if (module_list_compute(argc, argv, opt.prefix,
    +-					&pathspec, &list) < 0)
    +-			return 1;
    ++					&pathspec, &list) < 0) {
    ++			ret = 1;
    ++			goto cleanup;
    ++		}
    + 
    + 		/*
    + 		 * If there are no path args and submodule.active is set then,
    +@@ builtin/submodule--helper.c: static int module_update(int argc, const char **argv, const char *prefix)
    + 	}
    + 
    + 	ret = update_submodules(&opt);
    ++cleanup:
    + 	list_objects_filter_release(&filter_options);
    ++	clear_pathspec(&pathspec);
    + 	return ret;
    + }
    + 
    +@@ builtin/submodule--helper.c: static int push_check(int argc, const char **argv, const char *prefix)
    + static int absorb_git_dirs(int argc, const char **argv, const char *prefix)
    + {
    + 	int i;
    +-	struct pathspec pathspec;
    ++	struct pathspec pathspec = { 0 };
      	struct module_list list = MODULE_LIST_INIT;
      	unsigned flags = ABSORB_GITDIR_RECURSE_SUBMODULES;
    --
      	struct option embed_gitdir_options[] = {
    - 		OPT_STRING(0, "prefix", &prefix,
    - 			   N_("path"),
     @@ builtin/submodule--helper.c: static int absorb_git_dirs(int argc, const char **argv, const char *prefix)
    - 			ABSORB_GITDIR_RECURSE_SUBMODULES),
    - 		OPT_END()
    - 	};
    --
    - 	const char *const git_submodule_helper_usage[] = {
      		N_("git submodule absorbgitdirs [<options>] [<path>...]"),
      		NULL
    -@@ builtin/submodule--helper.c: static int module_config(int argc, const char **argv, const char *prefix)
    - 		CHECK_WRITEABLE = 1,
    - 		DO_UNSET = 2
    - 	} command = 0;
    --
    - 	struct option module_config_options[] = {
    - 		OPT_CMDMODE(0, "check-writeable", &command,
    - 			    N_("check if it is safe to write to the .gitmodules file"),
    -@@ builtin/submodule--helper.c: static int module_set_url(int argc, const char **argv, const char *prefix)
    - 	const char *newurl;
    - 	const char *path;
    - 	char *config_name;
    --
    - 	struct option options[] = {
    - 		OPT__QUIET(&quiet, N_("suppress output for setting url of a submodule")),
    - 		OPT_END()
    -@@ builtin/submodule--helper.c: static int module_set_branch(int argc, const char **argv, const char *prefix)
    - 	const char *opt_branch = NULL;
    - 	const char *path;
    - 	char *config_name;
    --
    --	/*
    --	 * We accept the `quiet` option for uniformity across subcommands,
    --	 * though there is nothing to make less verbose in this subcommand.
    --	 */
    - 	struct option options[] = {
    -+		/*
    -+		 * We accept the `quiet` option for uniformity across subcommands,
    -+		 * though there is nothing to make less verbose in this subcommand.
    -+		 */
    - 		OPT_NOOP_NOARG('q', "quiet"),
    -+
    - 		OPT_BOOL('d', "default", &opt_default,
    - 			N_("set the default tracking branch to master")),
    - 		OPT_STRING('b', "branch", &opt_branch, N_("branch"),
    -@@ builtin/submodule--helper.c: static int module_create_branch(int argc, const char **argv, const char *prefix)
    - {
    - 	enum branch_track track;
    - 	int quiet = 0, force = 0, reflog = 0, dry_run = 0;
    --
    - 	struct option options[] = {
    - 		OPT__QUIET(&quiet, N_("print only error messages")),
    - 		OPT__FORCE(&force, N_("force creation"), 0),
    -@@ builtin/submodule--helper.c: static int module_add(int argc, const char **argv, const char *prefix)
    - 	int force = 0, quiet = 0, progress = 0, dissociate = 0;
    - 	struct add_data add_data = ADD_DATA_INIT;
    - 	char *to_free = NULL;
    --
    - 	struct option options[] = {
    - 		OPT_STRING('b', "branch", &add_data.branch, N_("branch"),
    - 			   N_("branch of repository to add as submodule")),
    -@@ builtin/submodule--helper.c: static int module_add(int argc, const char **argv, const char *prefix)
    - 		OPT_INTEGER(0, "depth", &add_data.depth, N_("depth for shallow clones")),
    - 		OPT_END()
      	};
    --
    - 	const char *const usage[] = {
    - 		N_("git submodule add [<options>] [--] <repository> [<path>]"),
    - 		NULL
    ++	int ret = 1;
    + 
    + 	argc = parse_options(argc, argv, prefix, embed_gitdir_options,
    + 			     git_submodule_helper_usage, 0);
    + 
    + 	if (module_list_compute(argc, argv, prefix, &pathspec, &list) < 0)
    +-		return 1;
    ++		goto cleanup;
    + 
    + 	for (i = 0; i < list.nr; i++)
    + 		absorb_git_dir_into_superproject(list.entries[i]->name, flags);
    + 
    +-	return 0;
    ++	ret = 0;
    ++cleanup:
    ++	clear_pathspec(&pathspec);
    ++	return ret;
    + }
    + 
    + static int module_config(int argc, const char **argv, const char *prefix)
11:  72dcf19e1c4 !  4:  9cedfc41a44 submodule--helper: replace memset() with { 0 }-initialization
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: replace memset() with { 0 }-initialization
    +    submodule--helper: "struct pathspec" memory leak in module_update()
     
    -    Use the less verbose { 0 }-initialization syntax rather than memset()
    -    in builtin/submodule--helper.c, this doesn't make a difference in
    -    terms of behavior, but as we're about to modify adjacent code makes
    -    this more consistent, and lets us avoid worrying about when the
    -    memset() happens v.s. a "goto cleanup".
    +    The module_update() function calls module_list_compute() twice, which
    +    in turn will reset the "struct pathspec" passed to it. Let's instead
    +    track two of them, and clear them both.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int module_clone(int argc, const char **argv, const char *prefix)
    +@@ builtin/submodule--helper.c: static int update_submodules(struct update_data *update_data)
    + static int module_update(int argc, const char **argv, const char *prefix)
      {
    - 	int dissociate = 0, quiet = 0, progress = 0, require_init = 0;
    - 	struct module_clone_data clone_data = MODULE_CLONE_DATA_INIT;
    --	struct list_objects_filter_options filter_options;
    -+	struct list_objects_filter_options filter_options = { 0 };
    - 	struct option module_clone_options[] = {
    - 		OPT_STRING(0, "prefix", &clone_data.prefix,
    - 			   N_("path"),
    -@@ builtin/submodule--helper.c: static int module_clone(int argc, const char **argv, const char *prefix)
    - 		NULL
    - 	};
    - 
    --	memset(&filter_options, 0, sizeof(filter_options));
    - 	argc = parse_options(argc, argv, prefix, module_clone_options,
    - 			     git_submodule_helper_usage, 0);
    - 
    -@@ builtin/submodule--helper.c: static int module_update(int argc, const char **argv, const char *prefix)
    - {
    - 	struct pathspec pathspec;
    + 	struct pathspec pathspec = { 0 };
    ++	struct pathspec pathspec2 = { 0 };
      	struct update_data opt = UPDATE_DATA_INIT;
    --	struct list_objects_filter_options filter_options;
    -+	struct list_objects_filter_options filter_options = { 0 };
    + 	struct list_objects_filter_options filter_options = { 0 };
      	int ret;
    - 	struct option module_update_options[] = {
    - 		OPT__FORCE(&opt.force, N_("force checkout updates"), 0),
     @@ builtin/submodule--helper.c: static int module_update(int argc, const char **argv, const char *prefix)
    - 	update_clone_config_from_gitmodules(&opt.max_jobs);
    - 	git_config(git_update_clone_config, &opt.max_jobs);
    + 		struct init_cb info = INIT_CB_INIT;
      
    --	memset(&filter_options, 0, sizeof(filter_options));
    - 	argc = parse_options(argc, argv, prefix, module_update_options,
    - 			     git_submodule_helper_usage, 0);
    + 		if (module_list_compute(argc, argv, opt.prefix,
    +-					&pathspec, &list) < 0) {
    ++					&pathspec2, &list) < 0) {
    + 			ret = 1;
    + 			goto cleanup;
    + 		}
    +@@ builtin/submodule--helper.c: static int module_update(int argc, const char **argv, const char *prefix)
    + cleanup:
    + 	list_objects_filter_release(&filter_options);
    + 	clear_pathspec(&pathspec);
    ++	clear_pathspec(&pathspec2);
    + 	return ret;
    + }
      
18:  78f74df6d5e !  5:  926c721848d submodule--helper: rename "int res" to "int ret"
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: rename "int res" to "int ret"
    +    submodule--helper: don't leak {run,capture}_command() cp.dir argument
     
    -    Rename the "res" variable added in b3c5f5cb048 (submodule: move core
    -    cmd_update() logic to C, 2022-03-15) to "ret", which is the convention
    -    in the rest of this file.
    +    Fix a memory leak in c51f8f94e5b (submodule--helper: run update
    +    procedures from C, 2021-08-24) and 3c3558f0953 (submodule--helper: run
    +    update using child process struct, 2022-03-15) by not allocating
    +    memory in the first place.
     
    -    Eventual follow-up commits will change the code in update_submodule()
    -    to a "goto cleanup" pattern, let's have the post image look consistent
    -    with the rest. For update_submodules() let's also use a "ret" for
    -    consistency, that use was also added in b3c5f5cb048. We'll be
    -    modifying that codepath in subsequent commits.
    +    The "dir" member of "struct child_process" will not be modified by
    +    that API, and it's declared to be "const char *". So let's not
    +    needlessly duplicate these strings.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
    - 	if (update_data->recursive) {
    - 		struct child_process cp = CHILD_PROCESS_INIT;
    - 		struct update_data next = *update_data;
    --		int res;
    -+		int ret;
    +@@ builtin/submodule--helper.c: static int is_tip_reachable(const char *path, struct object_id *oid)
    + 	char *hex = oid_to_hex(oid);
      
    - 		next.prefix = NULL;
    - 		oidcpy(&next.oid, null_oid());
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
    - 		update_data_to_args(&next, &cp.args);
    + 	cp.git_cmd = 1;
    +-	cp.dir = xstrdup(path);
    ++	cp.dir = path;
    + 	cp.no_stderr = 1;
    + 	strvec_pushl(&cp.args, "rev-list", "-n", "1", hex, "--not", "--all", NULL);
      
    - 		/* die() if child process die()'d */
    --		res = run_command(&cp);
    --		if (!res)
    -+		ret = run_command(&cp);
    -+		if (!ret)
    - 			return 0;
    - 		die_message(_("Failed to recurse into submodule path '%s'"),
    - 			    update_data->displaypath);
    --		if (res == 128)
    --			exit(res);
    -+		if (ret == 128)
    -+			exit(ret);
    - 		return 1;
    - 	}
    - 
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
    - 
    - static int update_submodules(struct update_data *update_data)
    - {
    --	int i, res = 0;
    -+	int i, ret = 0;
    - 	struct submodule_update_clone suc = SUBMODULE_UPDATE_CLONE_INIT;
    +@@ builtin/submodule--helper.c: static int fetch_in_submodule(const char *module_path, int depth, int quiet, str
      
    - 	suc.update_data = update_data;
    -@@ builtin/submodule--helper.c: static int update_submodules(struct update_data *update_data)
    - 	 * - the listener can avoid doing any work if fetching failed.
    - 	 */
    - 	if (suc.quickstop) {
    --		res = 1;
    -+		ret = 1;
    - 		goto cleanup;
    - 	}
    - 
    -@@ builtin/submodule--helper.c: static int update_submodules(struct update_data *update_data)
    - 		update_data->sm_path = ucd.sub->path;
    + 	prepare_submodule_repo_env(&cp.env);
    + 	cp.git_cmd = 1;
    +-	cp.dir = xstrdup(module_path);
    ++	cp.dir = module_path;
      
    - 		if (update_submodule(update_data))
    --			res = 1;
    -+			ret = 1;
    + 	strvec_push(&cp.args, "fetch");
    + 	if (quiet)
    +@@ builtin/submodule--helper.c: static int run_update_command(struct update_data *ud, int subforce)
      	}
    + 	strvec_push(&cp.args, oid);
      
    - cleanup:
    - 	string_list_clear(&update_data->references, 0);
    --	return res;
    -+	return ret;
    - }
    - 
    - static int module_update(int argc, const char **argv, const char *prefix)
    +-	cp.dir = xstrdup(ud->sm_path);
    ++	cp.dir = ud->sm_path;
    + 	prepare_submodule_repo_env(&cp.env);
    + 	if ((ret = run_command(&cp))) {
    + 		switch (ud->update_strategy.type) {
26:  b48705c6cc0 !  6:  e63063c136f submodule--helper: libify "must_die_on_failure" code paths
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: libify "must_die_on_failure" code paths
    +    submodule--helper: add and use *_release() functions
     
    -    In preceding commits the codepaths around update_submodules() were
    -    changed from using exit() or die() to ferrying up a
    -    "must_die_on_failure" in the cases where we'd exit(), and in most
    -    cases where we'd die().
    -
    -    We needed to do this this to ensure that we'd early exit or otherwise
    -    abort the update_submodules() processing before it was completed.
    -
    -    Now that those preceding changes have shown that we've converted those
    -    paths, we can remove the remaining "ret == 128" special-cases, leaving
    -    the only such special-case in update_submodules(). I.e. we now know
    -    after having gone through the various codepaths that we were only
    -    returning 128 if we meant to early abort.
    +    Add release functions for "struct module_list", "struct
    +    submodule_update_clone" and "struct update_data".
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int fetch_in_submodule(const char *module_path, int depth, int quiet, str
    - 	return run_command(&cp);
    - }
    +@@ builtin/submodule--helper.c: struct module_list {
    + };
    + #define MODULE_LIST_INIT { 0 }
    + 
    ++static void module_list_release(struct module_list *ml)
    ++{
    ++	free(ml->entries);
    ++}
    ++
    + static int module_list_compute(int argc, const char **argv,
    + 			       const char *prefix,
    + 			       struct pathspec *pathspec,
    +@@ builtin/submodule--helper.c: static void module_list_active(struct module_list *list)
    + 		active_modules.entries[active_modules.nr++] = ce;
    + 	}
      
    --static int run_update_command(struct update_data *ud, int subforce,
    --			      int *must_die_on_failure)
    -+static int run_update_command(struct update_data *ud, int subforce)
    - {
    - 	struct child_process cp = CHILD_PROCESS_INIT;
    - 	char *oid = oid_to_hex(&ud->oid);
    -@@ builtin/submodule--helper.c: static int run_update_command(struct update_data *ud, int subforce,
    - 			    ud->update_strategy.type);
    - 		}
    +-	free(list->entries);
    ++	module_list_release(list);
    + 	*list = active_modules;
    + }
      
    --		if (ret == 128)
    --			*must_die_on_failure = 1;
    - 		return ret;
    - 	}
    +@@ builtin/submodule--helper.c: static int module_foreach(int argc, const char **argv, const char *prefix)
      
    -@@ builtin/submodule--helper.c: static int run_update_command(struct update_data *ud, int subforce,
    - 	return 0;
    + 	ret = 0;
    + cleanup:
    ++	module_list_release(&list);
    + 	clear_pathspec(&pathspec);
    + 	return ret;
      }
    +@@ builtin/submodule--helper.c: static int module_init(int argc, const char **argv, const char *prefix)
      
    --static int run_update_procedure(struct update_data *ud,
    --				int *must_die_on_failure)
    -+static int run_update_procedure(struct update_data *ud)
    - {
    - 	int subforce = is_null_oid(&ud->suboid) || ud->force;
    + 	ret = 0;
    + cleanup:
    ++	module_list_release(&list);
    + 	clear_pathspec(&pathspec);
    + 	return ret;
    + }
    +@@ builtin/submodule--helper.c: static int module_status(int argc, const char **argv, const char *prefix)
      
    -@@ builtin/submodule--helper.c: static int run_update_procedure(struct update_data *ud,
    - 			    ud->displaypath, oid_to_hex(&ud->oid));
    - 	}
    + 	ret = 0;
    + cleanup:
    ++	module_list_release(&list);
    + 	clear_pathspec(&pathspec);
    + 	return ret;
    + }
    +@@ builtin/submodule--helper.c: static int module_sync(int argc, const char **argv, const char *prefix)
      
    --	return run_update_command(ud, subforce, must_die_on_failure);
    -+	return run_update_command(ud, subforce);
    + 	ret = 0;
    + cleanup:
    ++	module_list_release(&list);
    + 	clear_pathspec(&pathspec);
    + 	return ret;
      }
    +@@ builtin/submodule--helper.c: static int module_deinit(int argc, const char **argv, const char *prefix)
      
    - static const char *remote_submodule_branch(const char *path)
    -@@ builtin/submodule--helper.c: static void update_data_to_args(struct update_data *update_data, struct strvec *
    - 				    "--no-single-branch");
    + 	ret = 0;
    + cleanup:
    ++	module_list_release(&list);
    + 	clear_pathspec(&pathspec);
    + 	return ret;
    + }
    +@@ builtin/submodule--helper.c: struct submodule_update_clone {
    + };
    + #define SUBMODULE_UPDATE_CLONE_INIT { 0 }
    + 
    ++static void submodule_update_clone_release(struct submodule_update_clone *suc)
    ++{
    ++	free(suc->update_clone);
    ++	free(suc->failed_clones);
    ++}
    ++
    + struct update_data {
    + 	const char *prefix;
    + 	const char *displaypath;
    +@@ builtin/submodule--helper.c: struct update_data {
    + 	.max_jobs = 1, \
      }
      
    --static int update_submodule(struct update_data *update_data,
    --			    int *must_die_on_failure)
    -+static int update_submodule(struct update_data *update_data)
    ++static void update_data_release(struct update_data *ud)
    ++{
    ++	module_list_release(&ud->list);
    ++}
    ++
    + static void next_submodule_warn_missing(struct submodule_update_clone *suc,
    + 		struct strbuf *out, const char *displaypath)
      {
    - 	int ret;
    - 
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data,
    +@@ builtin/submodule--helper.c: static int update_submodules(struct update_data *update_data)
      	}
      
    - 	if (!oideq(&update_data->oid, &update_data->suboid) || update_data->force) {
    --		ret = run_update_procedure(update_data, must_die_on_failure);
    --		if (*must_die_on_failure)
    --			return ret;
    -+		ret = run_update_procedure(update_data);
    - 		if (ret)
    --			return 1;
    -+			return ret;
    - 	}
    + cleanup:
    ++	submodule_update_clone_release(&suc);
    + 	string_list_clear(&update_data->references, 0);
    + 	return ret;
    + }
    +@@ builtin/submodule--helper.c: static int module_update(int argc, const char **argv, const char *prefix)
      
    - 	if (update_data->recursive) {
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data,
    - 
    - 		/* die() if child process die()'d */
    - 		ret = run_command(&cp);
    --		if (!ret)
    --			return 0;
    --		die_message(_("Failed to recurse into submodule path '%s'"),
    --			    update_data->displaypath);
    --		if (ret == 128)
    --			*must_die_on_failure = 1;
    -+		if (ret)
    -+			die_message(_("Failed to recurse into submodule path '%s'"),
    -+				    update_data->displaypath);
    - 		return ret;
    + 		if (module_list_compute(argc, argv, opt.prefix,
    + 					&pathspec2, &list) < 0) {
    ++			module_list_release(&list);
    + 			ret = 1;
    + 			goto cleanup;
    + 		}
    +@@ builtin/submodule--helper.c: static int module_update(int argc, const char **argv, const char *prefix)
    + 			info.flags |= OPT_QUIET;
    + 
    + 		for_each_listed_submodule(&list, init_submodule_cb, &info);
    ++		module_list_release(&list);
      	}
      
    -@@ builtin/submodule--helper.c: static int update_submodules(struct update_data *update_data)
    + 	ret = update_submodules(&opt);
    + cleanup:
    ++	update_data_release(&opt);
    + 	list_objects_filter_release(&filter_options);
    + 	clear_pathspec(&pathspec);
    + 	clear_pathspec(&pathspec2);
    +@@ builtin/submodule--helper.c: static int absorb_git_dirs(int argc, const char **argv, const char *prefix)
    + 	ret = 0;
    + cleanup:
    + 	clear_pathspec(&pathspec);
    ++	module_list_release(&list);
    + 	return ret;
    + }
      
    - 	for (i = 0; i < suc.update_clone_nr; i++) {
    - 		struct update_clone_data ucd = suc.update_clone[i];
    --		int must_die_on_failure = 0;
    - 		int code;
    - 
    - 		oidcpy(&update_data->oid, &ucd.oid);
    - 		update_data->just_cloned = ucd.just_cloned;
    - 		update_data->sm_path = ucd.sub->path;
    - 
    --		code = update_submodule(update_data, &must_die_on_failure);
    -+		code = update_submodule(update_data);
    - 		if (code)
    - 			ret = code;
    --		if (must_die_on_failure)
    -+		if (code == 128)
    - 			goto cleanup;
    - 		else if (code)
    - 			ret = 1;
    +
    + ## t/t6134-pathspec-in-submodule.sh ##
    +@@
    + 
    + test_description='test case exclude pathspec'
    + 
    ++TEST_PASSES_SANITIZE_LEAK=true
    + . ./test-lib.sh
    + 
    + test_expect_success 'setup a submodule' '
 3:  d981db49fa1 !  7:  85741d1776a submodule--helper: remove unused "name" helper
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: remove unused "name" helper
    +    submodule--helper: fix "errmsg_str" memory leak
     
    -    The "name" helper has not been used since e83e3333b57 (submodule: port
    -    submodule subcommand 'summary' from shell to C, 2020-08-13).
    +    Fix a memory leak introduced in e83e3333b57 (submodule: port submodule
    +    subcommand 'summary' from shell to C, 2020-08-13), we sometimes append
    +    to the "errmsg", and need to free the "struct strbuf".
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int module_status(int argc, const char **argv, const char *prefix)
    - 	return 0;
    +@@ builtin/submodule--helper.c: static void generate_submodule_summary(struct summary_cb *info,
    + 	free(displaypath);
    + 	free(src_abbrev);
    + 	free(dst_abbrev);
    ++	strbuf_release(&errmsg);
      }
      
    --static int module_name(int argc, const char **argv, const char *prefix)
    --{
    --	const struct submodule *sub;
    --
    --	if (argc != 2)
    --		usage(_("git submodule--helper name <path>"));
    --
    --	sub = submodule_from_path(the_repository, null_oid(), argv[1]);
    --
    --	if (!sub)
    --		die(_("no submodule mapping found in .gitmodules for path '%s'"),
    --		    argv[1]);
    --
    --	printf("%s\n", sub->name);
    --
    --	return 0;
    --}
    --
    - struct module_cb {
    - 	unsigned int mod_src;
    - 	unsigned int mod_dst;
    -@@ builtin/submodule--helper.c: struct cmd_struct {
    - 
    - static struct cmd_struct commands[] = {
    - 	{"list", module_list, 0},
    --	{"name", module_name, 0},
    - 	{"clone", module_clone, SUPPORT_SUPER_PREFIX},
    - 	{"add", module_add, 0},
    - 	{"update", module_update, SUPPORT_SUPER_PREFIX},
    + static void prepare_submodule_summary(struct summary_cb *info,
 4:  6f78f9c9274 <  -:  ----------- submodule--helper: remove unused "list" helper
 5:  43902201701 <  -:  ----------- test-tool submodule-config: remove unused "--url" handling
 6:  e2a8bb0a28e <  -:  ----------- submodule--helper: move "is-active" to a test-tool
 7:  b209532eb17 !  8:  8b037953852 submodule--helper: move "check-name" to a test-tool
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: move "check-name" to a test-tool
    +    submodule--helper: fix "sm_path" and other "module_cb_list" leaks
     
    -    Move the "check-name" helper to a test-tool, since
    -    a6226fd772b (submodule--helper: convert the bulk of cmd_add() to C,
    -    2021-08-10) it has only been used by this test, not git-submodule.sh.
    +    Fix leaks in "struct module_cb_list" and the "struct module_cb" which
    +    it contains, these fix leaks in e83e3333b57 (submodule: port submodule
    +    subcommand 'summary' from shell to C, 2020-08-13).
     
    -    As noted with its introduction in 0383bbb9015 (submodule-config:
    -    verify submodule names as paths, 2018-04-30) the intent of
    -    t7450-bad-git-dotfiles.sh has always been to unit test the
    -    check_submodule_name() function.
    +    The "sm_path" should always have been a "char *", not a "const
    +    char *", we always create it with xstrdup().
    +
    +    We can't mark any tests passing passing with SANITIZE=leak using
    +    "TEST_PASSES_SANITIZE_LEAK=true" as a result of this change, but
    +    "t7401-submodule-summary.sh" gets closer to passing as a result of
    +    this change.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int absorb_git_dirs(int argc, const char **argv, const char *prefix)
    - 	return 0;
    - }
    - 
    --/*
    -- * Exit non-zero if any of the submodule names given on the command line is
    -- * invalid. If no names are given, filter stdin to print only valid names
    -- * (which is primarily intended for testing).
    -- */
    --static int check_name(int argc, const char **argv, const char *prefix)
    --{
    --	if (argc > 1) {
    --		while (*++argv) {
    --			if (check_submodule_name(*argv) < 0)
    --				return 1;
    --		}
    --	} else {
    --		struct strbuf buf = STRBUF_INIT;
    --		while (strbuf_getline(&buf, stdin) != EOF) {
    --			if (!check_submodule_name(buf.buf))
    --				printf("%s\n", buf.buf);
    --		}
    --		strbuf_release(&buf);
    --	}
    --	return 0;
    --}
    --
    - static int module_config(int argc, const char **argv, const char *prefix)
    - {
    - 	enum {
    -@@ builtin/submodule--helper.c: static struct cmd_struct commands[] = {
    - 	{"summary", module_summary, 0},
    - 	{"push-check", push_check, 0},
    - 	{"absorbgitdirs", absorb_git_dirs, SUPPORT_SUPER_PREFIX},
    --	{"check-name", check_name, 0},
    - 	{"config", module_config, 0},
    - 	{"set-url", module_set_url, 0},
    - 	{"set-branch", module_set_branch, 0},
    -
    - ## t/helper/test-submodule.c ##
    -@@
    - #include "test-tool-utils.h"
    - #include "cache.h"
    - #include "parse-options.h"
    -+#include "submodule-config.h"
    - #include "submodule.h"
    - 
    -+#define TEST_TOOL_CHECK_NAME_USAGE \
    -+	"test-tool submodule check-name <name>"
    -+static const char *submodule_check_name_usage[] = {
    -+	TEST_TOOL_CHECK_NAME_USAGE,
    -+	NULL
    -+};
    -+
    - #define TEST_TOOL_IS_ACTIVE_USAGE \
    - 	"test-tool submodule is-active <name>"
    - static const char *submodule_is_active_usage[] = {
    -@@ t/helper/test-submodule.c: static const char *submodule_is_active_usage[] = {
    - };
    - 
    - static const char *submodule_usage[] = {
    -+	TEST_TOOL_CHECK_NAME_USAGE,
    - 	TEST_TOOL_IS_ACTIVE_USAGE,
    - 	NULL
    +@@ builtin/submodule--helper.c: struct module_cb {
    + 	struct object_id oid_src;
    + 	struct object_id oid_dst;
    + 	char status;
    +-	const char *sm_path;
    ++	char *sm_path;
      };
    + #define MODULE_CB_INIT { 0 }
      
    -+/*
    -+ * Exit non-zero if any of the submodule names given on the command line is
    -+ * invalid. If no names are given, filter stdin to print only valid names
    -+ * (which is primarily intended for testing).
    -+ */
    -+static int check_name(int argc, const char **argv)
    ++static void module_cb_release(struct module_cb *mcb)
     +{
    -+	if (argc > 1) {
    -+		while (*++argv) {
    -+			if (check_submodule_name(*argv) < 0)
    -+				return 1;
    -+		}
    -+	} else {
    -+		struct strbuf buf = STRBUF_INIT;
    -+		while (strbuf_getline(&buf, stdin) != EOF) {
    -+			if (!check_submodule_name(buf.buf))
    -+				printf("%s\n", buf.buf);
    -+		}
    -+		strbuf_release(&buf);
    -+	}
    -+	return 0;
    ++	free(mcb->sm_path);
     +}
     +
    -+static int cmd__submodule_check_name(int argc, const char **argv)
    + struct module_cb_list {
    + 	struct module_cb **entries;
    + 	int alloc, nr;
    + };
    + #define MODULE_CB_LIST_INIT { 0 }
    + 
    ++static void module_cb_list_release(struct module_cb_list *mcbl)
     +{
    -+	struct option options[] = {
    -+		OPT_END()
    -+	};
    -+	argc = parse_options(argc, argv, "test-tools", options,
    -+			     submodule_check_name_usage, 0);
    -+	if (argc)
    -+		usage_with_options(submodule_check_name_usage, options);
    ++	int i;
    ++
    ++	for (i = 0; i < mcbl->nr; i++) {
    ++		struct module_cb *mcb = mcbl->entries[i];
     +
    -+	return check_name(argc, argv);
    ++		module_cb_release(mcb);
    ++		free(mcb);
    ++	}
    ++	free(mcbl->entries);
     +}
     +
    - static int cmd__submodule_is_active(int argc, const char **argv)
    - {
    - 	struct option options[] = {
    -@@ t/helper/test-submodule.c: static int cmd__submodule_is_active(int argc, const char **argv)
    + struct summary_cb {
    + 	int argc;
    + 	const char **argv;
    +@@ builtin/submodule--helper.c: static int compute_summary_module_list(struct object_id *head_oid,
    + cleanup:
    + 	strvec_clear(&diff_args);
    + 	release_revisions(&rev);
    ++	module_cb_list_release(&list);
    + 	return ret;
      }
      
    - static struct test_cmd cmds[] = {
    -+	{ "check-name", cmd__submodule_check_name },
    - 	{ "is-active", cmd__submodule_is_active },
    - };
    - 
    -
    - ## t/t7450-bad-git-dotfiles.sh ##
    -@@ t/t7450-bad-git-dotfiles.sh: test_expect_success 'check names' '
    - 	valid/with/paths
    - 	EOF
    - 
    --	git submodule--helper check-name >actual <<-\EOF &&
    -+	test-tool submodule check-name >actual <<-\EOF &&
    - 	valid
    - 	valid/with/paths
    - 
17:  23eb07176d9 !  9:  6f40dfe8c70 submodule--helper: don't redundantly check "else if (res)"
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: don't redundantly check "else if (res)"
    +    submodule--helper: fix a leak with repo_clear()
     
    -    The "res" variable must be true at this point in update_submodule(),
    -    as just a few lines above this we've unconditionally:
    -
    -            if (!res)
    -                    return 0;
    -
    -    So we don't need to guard the "return 1" with an "else if (res)", we
    -    an return unconditionally at this point. See b3c5f5cb048 (submodule:
    -    move core cmd_update() logic to C, 2022-03-15) for the initial
    -    introduction of this code, this check of "res" has always been
    -    redundant.
    +    Call repo_clear() in ensure_core_worktree() to free the "struct
    +    repository". Fixes a leak that's been here since
    +    74d4731da1f (submodule--helper: replace connect-gitdir-workingtree by
    +    ensure-core-worktree, 2018-08-13).
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
    - 			    update_data->displaypath);
    - 		if (res == 128)
    - 			exit(res);
    --		else if (res)
    --			return 1;
    -+		return 1;
    +@@ builtin/submodule--helper.c: static int ensure_core_worktree(const char *path)
    + 		strbuf_release(&sb);
      	}
      
    ++	repo_clear(&subrepo);
      	return 0;
    + }
    + 
23:  db2d2fb5a21 ! 10:  29afc8e83c1 submodule--helper: use "code" in run_update_command()
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: use "code" in run_update_command()
    +    submodule--helper: fix a memory leak in get_default_remote_submodule()
     
    -    Apply some DRY principles in run_update_command() and don't have two
    -    "switch" statements over "ud->update_strategy.type" determine the same
    -    thing.
    -
    -    First we were setting "must_die_on_failure = 1" in all cases except
    -    "SM_UPDATE_CHECKOUT" (and we'd BUG(...) out on the rest). This code
    -    was added in c51f8f94e5b (submodule--helper: run update procedures
    -    from C, 2021-08-24).
    -
    -    Then we'd duplicate same "switch" logic when we were using the
    -    "must_die_on_failure" variable.
    -
    -    Let's instead have the "case" branches in that inner "switch"
    -    determine whether or not the "update must continue" by picking an exit
    -    code.
    -
    -    This also mostly avoids hardcoding the "128" exit code, instead we can
    -    make use of the return value of the die_message() function, which
    -    we've been calling here since 55b3f12cb54 (submodule update: use
    -    die_message(), 2022-03-15). We're still hardcoding it to determine if
    -    we "exit()", but subsequent commit(s) will address that.
    +    Fix a memory leak in the get_default_remote_submodule() function added
    +    in a77c3fcb5ec (submodule--helper: get remote names from any
    +    repository, 2022-03-04), we need to repo_clear() the submodule we
    +    initialize.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int run_update_command(struct update_data *ud, int subforce)
    +@@ builtin/submodule--helper.c: static int repo_get_default_remote(struct repository *repo, char **default_remot
    + static int get_default_remote_submodule(const char *module_path, char **default_remote)
      {
    - 	struct child_process cp = CHILD_PROCESS_INIT;
    - 	char *oid = oid_to_hex(&ud->oid);
    --	int must_die_on_failure = 0;
    + 	struct repository subrepo;
    ++	int ret;
      
    - 	switch (ud->update_strategy.type) {
    - 	case SM_UPDATE_CHECKOUT:
    -@@ builtin/submodule--helper.c: static int run_update_command(struct update_data *ud, int subforce)
    - 		strvec_push(&cp.args, "rebase");
    - 		if (ud->quiet)
    - 			strvec_push(&cp.args, "--quiet");
    --		must_die_on_failure = 1;
    - 		break;
    - 	case SM_UPDATE_MERGE:
    - 		cp.git_cmd = 1;
    - 		strvec_push(&cp.args, "merge");
    - 		if (ud->quiet)
    - 			strvec_push(&cp.args, "--quiet");
    --		must_die_on_failure = 1;
    - 		break;
    - 	case SM_UPDATE_COMMAND:
    - 		cp.use_shell = 1;
    - 		strvec_push(&cp.args, ud->update_strategy.command);
    --		must_die_on_failure = 1;
    - 		break;
    - 	default:
    - 		BUG("unexpected update strategy type: %d",
    -@@ builtin/submodule--helper.c: static int run_update_command(struct update_data *ud, int subforce)
    - 	cp.dir = xstrdup(ud->sm_path);
    - 	prepare_submodule_repo_env(&cp.env);
    - 	if (run_command(&cp)) {
    -+		int ret;
    + 	if (repo_submodule_init(&subrepo, the_repository, module_path,
    + 				null_oid()) < 0)
    + 		return die_message(_("could not get a repository handle for submodule '%s'"),
    + 				   module_path);
    +-	return repo_get_default_remote(&subrepo, default_remote);
    ++	ret = repo_get_default_remote(&subrepo, default_remote);
    ++	repo_clear(&subrepo);
     +
    - 		switch (ud->update_strategy.type) {
    - 		case SM_UPDATE_CHECKOUT:
    - 			die_message(_("Unable to checkout '%s' in submodule path '%s'"),
    - 				    oid, ud->displaypath);
    -+			/* the command failed, but update must continue */
    -+			ret = 1;
    - 			break;
    - 		case SM_UPDATE_REBASE:
    --			die_message(_("Unable to rebase '%s' in submodule path '%s'"),
    --			    oid, ud->displaypath);
    -+			ret = die_message(_("Unable to rebase '%s' in submodule path '%s'"),
    -+					  oid, ud->displaypath);
    - 			break;
    - 		case SM_UPDATE_MERGE:
    --			die_message(_("Unable to merge '%s' in submodule path '%s'"),
    --			    oid, ud->displaypath);
    -+			ret = die_message(_("Unable to merge '%s' in submodule path '%s'"),
    -+					  oid, ud->displaypath);
    - 			break;
    - 		case SM_UPDATE_COMMAND:
    --			die_message(_("Execution of '%s %s' failed in submodule path '%s'"),
    --			    ud->update_strategy.command, oid, ud->displaypath);
    -+			ret = die_message(_("Execution of '%s %s' failed in submodule path '%s'"),
    -+					  ud->update_strategy.command, oid, ud->displaypath);
    - 			break;
    - 		default:
    - 			BUG("unexpected update strategy type: %d",
    - 			    ud->update_strategy.type);
    - 		}
    --		if (must_die_on_failure)
    --			exit(128);
    - 
    --		/* the command failed, but update must continue */
    --		return 1;
    -+		if (ret == 128)
    -+			exit(ret);
    -+		return ret;
    - 	}
    ++	return ret;
    + }
      
    - 	if (ud->quiet)
    + static char *get_default_remote(void)
14:  866b8397a59 ! 11:  9893b72f643 submodule--helper: pass a "const struct module_clone_data" to clone_submodule()
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: pass a "const struct module_clone_data" to clone_submodule()
    +    submodule--helper: fix "reference" leak
     
    -    Add "const" to the "struct module_clone_data" that we pass to
    -    clone_submodule(), which makes the ownership clear, and stops us from
    -    clobbering the "clone_data->path".
    +    Fix leaks in the "reference" variable declared in add_submodule() and
    +    module_clone().
     
    -    We still need to add to the "reference" member, which is a "struct
    -    string_list". Let's do this by having clone_submodule() create its
    -    own, and copy the contents over, allowing us to pass it as a
    -    separate parameter.
    +    In preceding commits this variable was refactored out of the "struct
    +    module_clone_data", but the leak has been with us since
    +    31224cbdc72 (clone: recursive and reference option triggers submodule
    +    alternates, 2016-08-17) and 8c8195e9c3e (submodule--helper: introduce
    +    add-clone subcommand, 2021-07-10).
     
    -    This new "struct string_list" still leaks memory, just as the "struct
    -    module_clone_data" did before. let's not fix that for now, to fix that
    -    we'll need to add some "goto cleanup" to the relevant code. That will
    -    eventually be done in follow-up commits, this change makes it easier
    -    to fix the memory leak.
    +    Those commits added an xstrdup()'d member of the
    +    STRING_LIST_INIT_NODUP'd "struct string_list". We need to free()
    +    those, but not the ones we get from argv, let's make use of the "util"
    +    member, if it has a pointer it's the pointer we'll need to free,
    +    otherwise it'll be NULL (i.e. from argv).
     
    -    The scope of the new "reference" variable in add_submodule() could be
    -    narrowed to the "else" block, but as we'll eventually free it with a
    -    "goto cleanup" let's declare it at the start of the function.
    +    Note that the free() of the "util" member is needed in both
    +    module_clone() and add_submodule(). The module_clone() function itself
    +    doesn't populate the "util" pointer as add_submodule() does, but
    +    module_clone() is upstream of the
    +    add_possible_reference_from_superproject() caller we're modifying
    +    here, which does do that.
    +
    +    This does preclude the use of the "util" pointer for any other reasons
    +    for now, but that's OK. If we ever need to use it for something else
    +    we could turn it into a small "struct" with an optional "to_free"
    +    member, and switch to using string_list_clear_func().
    +
    +    Alternatively we could have another "struct string_list to_free" which
    +    would keep a copy of the strings we've dup'd to free(). But for now
    +    this is perfectly adequate.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: struct module_clone_data {
    - 	const char *url;
    - 	const char *depth;
    - 	struct list_objects_filter_options *filter_options;
    --	struct string_list reference;
    - 	unsigned int quiet: 1;
    - 	unsigned int progress: 1;
    - 	unsigned int dissociate: 1;
    -@@ builtin/submodule--helper.c: struct module_clone_data {
    - 	int single_branch;
    - };
    - #define MODULE_CLONE_DATA_INIT { \
    --	.reference = STRING_LIST_INIT_NODUP, \
    - 	.single_branch = -1, \
    - }
    - 
    -@@ builtin/submodule--helper.c: static char *clone_submodule_sm_gitdir(const char *name)
    - 	return sm_gitdir;
    - }
    - 
    --static int clone_submodule(struct module_clone_data *clone_data)
    -+static int clone_submodule(const struct module_clone_data *clone_data,
    -+			   struct string_list *reference)
    - {
    - 	char *p;
    - 	char *sm_gitdir = clone_submodule_sm_gitdir(clone_data->name);
    - 	char *sm_alternate = NULL, *error_strategy = NULL;
    - 	struct child_process cp = CHILD_PROCESS_INIT;
    -+	const char *clone_data_path;
    - 
    - 	if (!is_absolute_path(clone_data->path))
    --		clone_data->path = xstrfmt("%s/%s", get_git_work_tree(),
    --					   clone_data->path);
    -+		clone_data_path = xstrfmt("%s/%s", get_git_work_tree(),
    -+					  clone_data->path);
    - 	else
    --		clone_data->path = xstrdup(clone_data->path);
    -+		clone_data_path = xstrdup(clone_data->path);
    - 
    - 	if (validate_submodule_git_dir(sm_gitdir, clone_data->name) < 0)
    - 		die(_("refusing to create/use '%s' in another submodule's "
    -@@ builtin/submodule--helper.c: static int clone_submodule(struct module_clone_data *clone_data)
    - 		if (safe_create_leading_directories_const(sm_gitdir) < 0)
    - 			die(_("could not create directory '%s'"), sm_gitdir);
    - 
    --		prepare_possible_alternates(clone_data->name, &clone_data->reference);
    -+		prepare_possible_alternates(clone_data->name, reference);
    - 
    - 		strvec_push(&cp.args, "clone");
    - 		strvec_push(&cp.args, "--no-checkout");
    -@@ builtin/submodule--helper.c: static int clone_submodule(struct module_clone_data *clone_data)
    - 			strvec_push(&cp.args, "--progress");
    - 		if (clone_data->depth && *(clone_data->depth))
    - 			strvec_pushl(&cp.args, "--depth", clone_data->depth, NULL);
    --		if (clone_data->reference.nr) {
    -+		if (reference->nr) {
    - 			struct string_list_item *item;
    - 
    --			for_each_string_list_item(item, &clone_data->reference)
    -+			for_each_string_list_item(item, reference)
    - 				strvec_pushl(&cp.args, "--reference",
    - 					     item->string, NULL);
    - 		}
    -@@ builtin/submodule--helper.c: static int clone_submodule(struct module_clone_data *clone_data)
    - 
    - 		strvec_push(&cp.args, "--");
    - 		strvec_push(&cp.args, clone_data->url);
    --		strvec_push(&cp.args, clone_data->path);
    -+		strvec_push(&cp.args, clone_data_path);
    - 
    - 		cp.git_cmd = 1;
    - 		prepare_submodule_repo_env(&cp.env);
    -@@ builtin/submodule--helper.c: static int clone_submodule(struct module_clone_data *clone_data)
    - 
    - 		if(run_command(&cp))
    - 			die(_("clone of '%s' into submodule path '%s' failed"),
    --			    clone_data->url, clone_data->path);
    -+			    clone_data->url, clone_data_path);
    - 	} else {
    - 		char *path;
    - 
    --		if (clone_data->require_init && !access(clone_data->path, X_OK) &&
    --		    !is_empty_dir(clone_data->path))
    --			die(_("directory not empty: '%s'"), clone_data->path);
    --		if (safe_create_leading_directories_const(clone_data->path) < 0)
    --			die(_("could not create directory '%s'"), clone_data->path);
    -+		if (clone_data->require_init && !access(clone_data_path, X_OK) &&
    -+		    !is_empty_dir(clone_data_path))
    -+			die(_("directory not empty: '%s'"), clone_data_path);
    -+		if (safe_create_leading_directories_const(clone_data_path) < 0)
    -+			die(_("could not create directory '%s'"), clone_data_path);
    - 		path = xstrfmt("%s/index", sm_gitdir);
    - 		unlink_or_warn(path);
    - 		free(path);
    - 	}
    - 
    --	connect_work_tree_and_git_dir(clone_data->path, sm_gitdir, 0);
    -+	connect_work_tree_and_git_dir(clone_data_path, sm_gitdir, 0);
    - 
    --	p = git_pathdup_submodule(clone_data->path, "config");
    -+	p = git_pathdup_submodule(clone_data_path, "config");
    - 	if (!p)
    --		die(_("could not get submodule directory for '%s'"), clone_data->path);
    -+		die(_("could not get submodule directory for '%s'"), clone_data_path);
    +@@ builtin/submodule--helper.c: static int add_possible_reference_from_superproject(
      
    - 	/* setup alternateLocation and alternateErrorStrategy in the cloned submodule if needed */
    - 	git_config_get_string("submodule.alternateLocation", &sm_alternate);
    -@@ builtin/submodule--helper.c: static int module_clone(int argc, const char **argv, const char *prefix)
    - 	int dissociate = 0, quiet = 0, progress = 0, require_init = 0;
    - 	struct module_clone_data clone_data = MODULE_CLONE_DATA_INIT;
    - 	struct list_objects_filter_options filter_options = { 0 };
    -+	struct string_list reference = STRING_LIST_INIT_NODUP;
    - 	struct option module_clone_options[] = {
    - 		OPT_STRING(0, "prefix", &clone_data.prefix,
    - 			   N_("path"),
    -@@ builtin/submodule--helper.c: static int module_clone(int argc, const char **argv, const char *prefix)
    - 		OPT_STRING(0, "url", &clone_data.url,
    - 			   N_("string"),
    - 			   N_("url where to clone the submodule from")),
    --		OPT_STRING_LIST(0, "reference", &clone_data.reference,
    -+		OPT_STRING_LIST(0, "reference", &reference,
    - 			   N_("repo"),
    - 			   N_("reference repository")),
    - 		OPT_BOOL(0, "dissociate", &dissociate,
    + 		sm_alternate = compute_alternate_path(sb.buf, &err);
    + 		if (sm_alternate) {
    +-			string_list_append(sas->reference, xstrdup(sb.buf));
    ++			char *p = strbuf_detach(&sb, NULL);
    ++
    ++			string_list_append(sas->reference, p)->util = p;
    + 			free(sm_alternate);
    + 		} else {
    + 			switch (sas->error_mode) {
     @@ builtin/submodule--helper.c: static int module_clone(int argc, const char **argv, const char *prefix)
    - 		usage_with_options(git_submodule_helper_usage,
    - 				   module_clone_options);
      
    --	clone_submodule(&clone_data);
    -+	clone_submodule(&clone_data, &reference);
    + 	clone_submodule(&clone_data, &reference);
      	list_objects_filter_release(&filter_options);
    ++	string_list_clear(&reference, 1);
      	return 0;
      }
    + 
     @@ builtin/submodule--helper.c: static int add_submodule(const struct add_data *add_data)
    - {
      	char *submod_gitdir_path;
      	struct module_clone_data clone_data = MODULE_CLONE_DATA_INIT;
    -+	struct string_list reference = STRING_LIST_INIT_NODUP;
    + 	struct string_list reference = STRING_LIST_INIT_NODUP;
    ++	int ret = -1;
      
      	/* perhaps the path already exists and is already a git repo, else clone it */
      	if (is_directory(add_data->sm_path)) {
     @@ builtin/submodule--helper.c: static int add_submodule(const struct add_data *add_data)
    - 		free(submod_gitdir_path);
    - 	} else {
    - 		struct child_process cp = CHILD_PROCESS_INIT;
    -+
    - 		submod_gitdir_path = xstrfmt(".git/modules/%s", add_data->sm_name);
    - 
    - 		if (is_directory(submod_gitdir_path)) {
    -@@ builtin/submodule--helper.c: static int add_submodule(const struct add_data *add_data)
    + 		clone_data.url = add_data->realrepo;
      		clone_data.quiet = add_data->quiet;
      		clone_data.progress = add_data->progress;
    - 		if (add_data->reference_path)
    --			string_list_append(&clone_data.reference,
    -+			string_list_append(&reference,
    - 					   xstrdup(add_data->reference_path));
    +-		if (add_data->reference_path)
    +-			string_list_append(&reference,
    +-					   xstrdup(add_data->reference_path));
    ++		if (add_data->reference_path) {
    ++			char *p = xstrdup(add_data->reference_path);
    ++
    ++			string_list_append(&reference, p)->util = p;
    ++		}
      		clone_data.dissociate = add_data->dissociate;
      		if (add_data->depth >= 0)
      			clone_data.depth = xstrfmt("%d", add_data->depth);
      
    --		if (clone_submodule(&clone_data))
    -+		if (clone_submodule(&clone_data, &reference))
    - 			return -1;
    + 		if (clone_submodule(&clone_data, &reference))
    +-			return -1;
    ++			goto cleanup;
      
      		prepare_submodule_repo_env(&cp.env);
    + 		cp.git_cmd = 1;
    +@@ builtin/submodule--helper.c: static int add_submodule(const struct add_data *add_data)
    + 		if (run_command(&cp))
    + 			die(_("unable to checkout submodule '%s'"), add_data->sm_path);
    + 	}
    +-	return 0;
    ++	ret = 0;
    ++cleanup:
    ++	string_list_clear(&reference, 1);
    ++	return ret;
    + }
    + 
    + static int config_submodule_in_gitmodules(const char *name, const char *var, const char *value)
25:  9981a75d7e8 ! 12:  8f297c618bc submodule--helper: libify determine_submodule_update_strategy()
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: libify determine_submodule_update_strategy()
    +    submodule--helper: fix obscure leak in module_add()
     
    -    Libify the determine_submodule_update_strategy() by having it invoke
    -    die_message() rather than die(), and returning the code die_message()
    -    returns on failure.
    +    Fix an obscure leak in module_add(), if the "git add" command we were
    +    piping to failed we'd fail to strbuf_release(&sb). This fixes a leak
    +    introduced in a6226fd772b (submodule--helper: convert the bulk of
    +    cmd_add() to C, 2021-08-10).
    +
    +    In fixing it move to a "goto cleanup" pattern, and since we need to
    +    introduce a "ret" variable to do that let's also get rid of the
    +    intermediate "exit_code" variable. The initialization to "-1" in
    +    a6226fd772b has always been redundant, we'd only use the "exit_code"
    +    value after assigning the return value of pipe_command() to it.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int module_clone(int argc, const char **argv, const char *prefix)
    - 	return 0;
    - }
    +@@ builtin/submodule--helper.c: static int module_add(int argc, const char **argv, const char *prefix)
    + 		N_("git submodule add [<options>] [--] <repository> [<path>]"),
    + 		NULL
    + 	};
    ++	struct strbuf sb = STRBUF_INIT;
    ++	int ret = 1;
      
    --static void determine_submodule_update_strategy(struct repository *r,
    --						int just_cloned,
    --						const char *path,
    --						enum submodule_update_type update,
    --						struct submodule_update_strategy *out)
    -+static int determine_submodule_update_strategy(struct repository *r,
    -+					       int just_cloned,
    -+					       const char *path,
    -+					       enum submodule_update_type update,
    -+					       struct submodule_update_strategy *out)
    - {
    - 	const struct submodule *sub = submodule_from_path(r, null_oid(), path);
    - 	char *key;
    - 	const char *val;
    -+	int ret;
    + 	argc = parse_options(argc, argv, prefix, options, usage, 0);
      
    - 	key = xstrfmt("submodule.%s.update", sub->name);
    +@@ builtin/submodule--helper.c: static int module_add(int argc, const char **argv, const char *prefix)
    + 	die_on_repo_without_commits(add_data.sm_path);
    + 
    + 	if (!force) {
    +-		int exit_code = -1;
    +-		struct strbuf sb = STRBUF_INIT;
    + 		struct child_process cp = CHILD_PROCESS_INIT;
      
    - 	if (update) {
    - 		out->type = update;
    - 	} else if (!repo_config_get_string_tmp(r, key, &val)) {
    --		if (parse_submodule_update_strategy(val, out) < 0)
    --			die(_("Invalid update mode '%s' configured for submodule path '%s'"),
    --				val, path);
    -+		if (parse_submodule_update_strategy(val, out) < 0) {
    -+			ret = die_message(_("Invalid update mode '%s' configured for submodule path '%s'"),
    -+					  val, path);
    + 		cp.git_cmd = 1;
    + 		cp.no_stdout = 1;
    + 		strvec_pushl(&cp.args, "add", "--dry-run", "--ignore-missing",
    + 			     "--no-warn-embedded-repo", add_data.sm_path, NULL);
    +-		if ((exit_code = pipe_command(&cp, NULL, 0, NULL, 0, &sb, 0))) {
    ++		if ((ret = pipe_command(&cp, NULL, 0, NULL, 0, &sb, 0))) {
    + 			strbuf_complete_line(&sb);
    + 			fputs(sb.buf, stderr);
    +-			free(add_data.sm_path);
    +-			return exit_code;
     +			goto cleanup;
    -+		}
    - 	} else if (sub->update_strategy.type != SM_UPDATE_UNSPECIFIED) {
    - 		if (sub->update_strategy.type == SM_UPDATE_COMMAND)
    - 			BUG("how did we read update = !command from .gitmodules?");
    -@@ builtin/submodule--helper.c: static void determine_submodule_update_strategy(struct repository *r,
    - 	     out->type == SM_UPDATE_NONE))
    - 		out->type = SM_UPDATE_CHECKOUT;
    + 		}
    +-		strbuf_release(&sb);
    + 	}
    + 
    + 	if(!add_data.sm_name)
    +@@ builtin/submodule--helper.c: static int module_add(int argc, const char **argv, const char *prefix)
    + 	add_data.progress = !!progress;
    + 	add_data.dissociate = !!dissociate;
      
    +-	if (add_submodule(&add_data)) {
    +-		free(add_data.sm_path);
    +-		return 1;
    +-	}
    ++	if (add_submodule(&add_data))
    ++		goto cleanup;
    + 	configure_added_submodule(&add_data);
    ++
     +	ret = 0;
     +cleanup:
    - 	free(key);
    + 	free(add_data.sm_path);
    + 	free(to_free);
    ++	strbuf_release(&sb);
    + 
    +-	return 0;
     +	return ret;
      }
      
    - struct update_clone_data {
    -@@ builtin/submodule--helper.c: static void update_data_to_args(struct update_data *update_data, struct strvec *
    - static int update_submodule(struct update_data *update_data,
    - 			    int *must_die_on_failure)
    - {
    -+	int ret;
    -+
    - 	ensure_core_worktree(update_data->sm_path);
    - 
    - 	update_data->displaypath = get_submodule_displaypath(
    - 		update_data->sm_path, update_data->prefix);
    - 
    --	determine_submodule_update_strategy(the_repository, update_data->just_cloned,
    --					    update_data->sm_path, update_data->update_default,
    --					    &update_data->update_strategy);
    -+	ret = determine_submodule_update_strategy(the_repository,
    -+						  update_data->just_cloned,
    -+						  update_data->sm_path,
    -+						  update_data->update_default,
    -+						  &update_data->update_strategy);
    -+	if (ret) {
    -+		*must_die_on_failure = 1;
    -+		return ret;
    -+	}
    - 
    - 	if (update_data->just_cloned)
    - 		oidcpy(&update_data->suboid, null_oid());
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data,
    - 	}
    - 
    - 	if (!oideq(&update_data->oid, &update_data->suboid) || update_data->force) {
    --		int ret;
    --
    - 		ret = run_update_procedure(update_data, must_die_on_failure);
    - 		if (*must_die_on_failure)
    - 			return ret;
    -@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data,
    - 	if (update_data->recursive) {
    - 		struct child_process cp = CHILD_PROCESS_INIT;
    - 		struct update_data next = *update_data;
    --		int ret;
    - 
    - 		next.prefix = NULL;
    - 		oidcpy(&next.oid, null_oid());
    + #define SUPPORT_SUPER_PREFIX (1<<0)
13:  91558745e2e ! 13:  4b83ea4ca63 submodule--helper: move "sb" in clone_submodule() to its own scope
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: move "sb" in clone_submodule() to its own scope
    +    submodule--helper: fix a leak in module_add()
     
    -    Refactor the only remaining use of a "struct strbuf sb" in
    -    clone_submodule() to live in its own scope. This makes the code
    -    clearer by limiting its lifetime.
    +    Fix a leak in module_path(), since a6226fd772b (submodule--helper:
    +    convert the bulk of cmd_add() to C, 2021-08-10), we've been freeing
    +    add_data.sm_path, but in this case we clobbered it, and didn't free
    +    the value we clobbered.
    +
    +    This makes test 28 of "t/t7400-submodule-basic.sh" ("submodule add in
    +    subdirectory") pass when we're compiled with SANITIZE=leak..
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static void prepare_possible_alternates(const char *sm_name,
    - 	free(error_strategy);
    - }
    - 
    --static int clone_submodule(struct module_clone_data *clone_data)
    -+static char *clone_submodule_sm_gitdir(const char *name)
    - {
    --	char *p, *sm_gitdir;
    --	char *sm_alternate = NULL, *error_strategy = NULL;
    - 	struct strbuf sb = STRBUF_INIT;
    --	struct child_process cp = CHILD_PROCESS_INIT;
    -+	char *sm_gitdir;
    +@@ builtin/submodule--helper.c: static int module_add(int argc, const char **argv, const char *prefix)
    + 	else
    + 		add_data.sm_path = xstrdup(argv[1]);
      
    --	submodule_name_to_gitdir(&sb, the_repository, clone_data->name);
    -+	submodule_name_to_gitdir(&sb, the_repository, name);
    - 	sm_gitdir = absolute_pathdup(sb.buf);
    --	strbuf_reset(&sb);
    -+	strbuf_release(&sb);
    +-	if (prefix && *prefix && !is_absolute_path(add_data.sm_path))
    +-		add_data.sm_path = xstrfmt("%s%s", prefix, add_data.sm_path);
    ++	if (prefix && *prefix && !is_absolute_path(add_data.sm_path)) {
    ++		char *sm_path = add_data.sm_path;
     +
    -+	return sm_gitdir;
    -+}
    -+
    -+static int clone_submodule(struct module_clone_data *clone_data)
    -+{
    -+	char *p;
    -+	char *sm_gitdir = clone_submodule_sm_gitdir(clone_data->name);
    -+	char *sm_alternate = NULL, *error_strategy = NULL;
    -+	struct child_process cp = CHILD_PROCESS_INIT;
    - 
    - 	if (!is_absolute_path(clone_data->path))
    - 		clone_data->path = xstrfmt("%s/%s", get_git_work_tree(),
    -@@ builtin/submodule--helper.c: static int clone_submodule(struct module_clone_data *clone_data)
    - 	free(sm_alternate);
    - 	free(error_strategy);
    ++		add_data.sm_path = xstrfmt("%s%s", prefix, sm_path);
    ++		free(sm_path);
    ++	}
      
    --	strbuf_release(&sb);
    - 	free(sm_gitdir);
    - 	free(p);
    - 	return 0;
    + 	if (starts_with_dot_dot_slash(add_data.repo) ||
    + 	    starts_with_dot_slash(add_data.repo)) {
16:  d3a7e646adc ! 14:  721f86ca30f submodule--helper: refactor "errmsg_str" to be a "struct strbuf"
    @@
      ## Metadata ##
    -Author: Glen Choo <chooglen@google.com>
    +Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: refactor "errmsg_str" to be a "struct strbuf"
    +    submodule--helper: fix a memory leak in print_status()
     
    -    Refactor code added in e83e3333b57 (submodule: port submodule
    -    subcommand 'summary' from shell to C, 2020-08-13) so that "errmsg" and
    -    "errmsg_str" are folded into one. The distinction between the empty
    -    string and NULL is something that's tested for by
    -    e.g. "t/t7401-submodule-summary.sh".
    +    Fix a leak in print_status(), the compute_rev_name() function
    +    implemented in this file will return a strbuf_detach()'d value, or
    +    NULL.
     
    -    This is in preparation for fixing a memory leak the "struct strbuf" in
    -    the pre-image.
    +    This leak has existed since this code was added in
    +    a9f8a37584a (submodule: port submodule subcommand 'status' from shell
    +    to C, 2017-10-06), but in 0b5e2ea7cf3 (submodule--helper: don't print
    +    null in 'submodule status', 2018-04-18) we added a "const"
    +    intermediate variable for the return value, that "const" should be
    +    removed.
     
    -    Let's also pass a "const char *" to print_submodule_summary(), as it
    -    should not be modifying the "errmsg".
    -
    -    Signed-off-by: Glen Choo <chooglen@google.com>
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static char *verify_submodule_committish(const char *sm_path,
    - 	return strbuf_detach(&result, NULL);
    - }
    +@@ builtin/submodule--helper.c: static void print_status(unsigned int flags, char state, const char *path,
    + 	printf("%c%s %s", state, oid_to_hex(oid), displaypath);
      
    --static void print_submodule_summary(struct summary_cb *info, char *errmsg,
    -+static void print_submodule_summary(struct summary_cb *info, const char *errmsg,
    - 				    int total_commits, const char *displaypath,
    - 				    const char *src_abbrev, const char *dst_abbrev,
    - 				    struct module_cb *p)
    -@@ builtin/submodule--helper.c: static void generate_submodule_summary(struct summary_cb *info,
    - {
    - 	char *displaypath, *src_abbrev = NULL, *dst_abbrev;
    - 	int missing_src = 0, missing_dst = 0;
    --	char *errmsg = NULL;
    -+	struct strbuf errmsg = STRBUF_INIT;
    - 	int total_commits = -1;
    + 	if (state == ' ' || state == '+') {
    +-		const char *name = compute_rev_name(path, oid_to_hex(oid));
    ++		char *name = compute_rev_name(path, oid_to_hex(oid));
      
    - 	if (!info->cached && oideq(&p->oid_dst, null_oid())) {
    -@@ builtin/submodule--helper.c: static void generate_submodule_summary(struct summary_cb *info,
    - 		 * submodule, i.e., deleted or changed to blob
    - 		 */
    - 		if (S_ISGITLINK(p->mod_dst)) {
    --			struct strbuf errmsg_str = STRBUF_INIT;
    - 			if (missing_src && missing_dst) {
    --				strbuf_addf(&errmsg_str, "  Warn: %s doesn't contain commits %s and %s\n",
    -+				strbuf_addf(&errmsg, "  Warn: %s doesn't contain commits %s and %s\n",
    - 					    displaypath, oid_to_hex(&p->oid_src),
    - 					    oid_to_hex(&p->oid_dst));
    - 			} else {
    --				strbuf_addf(&errmsg_str, "  Warn: %s doesn't contain commit %s\n",
    -+				strbuf_addf(&errmsg, "  Warn: %s doesn't contain commit %s\n",
    - 					    displaypath, missing_src ?
    - 					    oid_to_hex(&p->oid_src) :
    - 					    oid_to_hex(&p->oid_dst));
    - 			}
    --			errmsg = strbuf_detach(&errmsg_str, NULL);
    - 		}
    + 		if (name)
    + 			printf(" (%s)", name);
    ++		free(name);
      	}
      
    --	print_submodule_summary(info, errmsg, total_commits,
    --				displaypath, src_abbrev,
    -+	print_submodule_summary(info, errmsg.len ? errmsg.buf : NULL,
    -+				total_commits, displaypath, src_abbrev,
    - 				dst_abbrev, p);
    - 
    - 	free(displaypath);
    + 	printf("\n");
10:  5f5e68a868b ! 15:  289c6fd81a7 submodule--helper style: add \n\n after variable declarations
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper style: add \n\n after variable declarations
    +    submodule--helper: free some "displaypath" in "struct update_data"
     
    -    Since the preceding commit fixed style issues with \n\n among the
    -    declared variables let's fix the minor stylistic issues with those
    -    variables not being consistently followed by a \n\n.
    +    Make the update_data_release() function free "displaypath" member when
    +    appropriate. The "displaypath" member is always ours, the "const" on
    +    the "char *" was wrong to begin with.
    +
    +    This leaves a leak of "displaypath" in update_submodule(), which as
    +    we'll see in subsequent commits is harder to deal with than this
    +    trivial fix.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static int module_list_compute(int argc, const char **argv,
    - {
    - 	int i, result = 0;
    - 	char *ps_matched = NULL;
    -+
    - 	parse_pathspec(pathspec, 0,
    - 		       PATHSPEC_PREFER_FULL,
    - 		       prefix, argv);
    -@@ builtin/submodule--helper.c: static void for_each_listed_submodule(const struct module_list *list,
    - 				      each_submodule_fn fn, void *cb_data)
    - {
    - 	int i;
    -+
    - 	for (i = 0; i < list->nr; i++)
    - 		fn(list->entries[i], cb_data);
    - }
    -@@ builtin/submodule--helper.c: static void runcommand_in_submodule_cb(const struct cache_entry *list_item,
    - 	struct foreach_cb *info = cb_data;
    - 	const char *path = list_item->name;
    - 	const struct object_id *ce_oid = &list_item->oid;
    --
    - 	const struct submodule *sub;
    - 	struct child_process cp = CHILD_PROCESS_INIT;
    - 	char *displaypath;
    -@@ builtin/submodule--helper.c: static void init_submodule(const char *path, const char *prefix,
    - 		if (starts_with_dot_dot_slash(url) ||
    - 		    starts_with_dot_slash(url)) {
    - 			char *oldurl = url;
    -+
    - 			url = resolve_relative_url(oldurl, NULL, 0);
    - 			free(oldurl);
    - 		}
    -@@ builtin/submodule--helper.c: static void init_submodule(const char *path, const char *prefix,
    - static void init_submodule_cb(const struct cache_entry *list_item, void *cb_data)
    - {
    - 	struct init_cb *info = cb_data;
    -+
    - 	init_submodule(list_item->name, info->prefix, info->flags);
    - }
    +@@ builtin/submodule--helper.c: static void submodule_update_clone_release(struct submodule_update_clone *suc)
      
    -@@ builtin/submodule--helper.c: static int handle_submodule_head_ref(const char *refname,
    - 				     void *cb_data)
    - {
    - 	struct object_id *output = cb_data;
    -+
    - 	if (oid)
    - 		oidcpy(output, oid);
    + struct update_data {
    + 	const char *prefix;
    +-	const char *displaypath;
    ++	char *displaypath;
    + 	enum submodule_update_type update_default;
    + 	struct object_id suboid;
    + 	struct string_list references;
    +@@ builtin/submodule--helper.c: struct update_data {
      
    -@@ builtin/submodule--helper.c: static void status_submodule_cb(const struct cache_entry *list_item,
    - 				void *cb_data)
    - {
    - 	struct status_cb *info = cb_data;
    -+
    - 	status_submodule(list_item->name, &list_item->oid, list_item->ce_flags,
    - 			 info->prefix, info->flags);
    - }
    -@@ builtin/submodule--helper.c: static void generate_submodule_summary(struct summary_cb *info,
    - 	if (!info->cached && oideq(&p->oid_dst, null_oid())) {
    - 		if (S_ISGITLINK(p->mod_dst)) {
    - 			struct ref_store *refs = get_submodule_ref_store(p->sm_path);
    -+
    - 			if (refs)
    - 				refs_head_ref(refs, handle_submodule_head_ref, &p->oid_dst);
    - 		} else if (S_ISLNK(p->mod_dst) || S_ISREG(p->mod_dst)) {
    -@@ builtin/submodule--helper.c: static void sync_submodule(const char *path, const char *prefix,
    - 		if (starts_with_dot_dot_slash(sub->url) ||
    - 		    starts_with_dot_slash(sub->url)) {
    - 			char *up_path = get_up_path(path);
    -+
    - 			sub_origin_url = resolve_relative_url(sub->url, up_path, 1);
    - 			super_config_url = resolve_relative_url(sub->url, NULL, 1);
    - 			free(up_path);
    -@@ builtin/submodule--helper.c: static void sync_submodule(const char *path, const char *prefix,
    - static void sync_submodule_cb(const struct cache_entry *list_item, void *cb_data)
    + static void update_data_release(struct update_data *ud)
      {
    - 	struct sync_cb *info = cb_data;
    -+
    - 	sync_submodule(list_item->name, info->prefix, info->flags);
    ++	free(ud->displaypath);
    + 	module_list_release(&ud->list);
      }
      
    -@@ builtin/submodule--helper.c: static void deinit_submodule(const char *path, const char *prefix,
    +
    + ## t/t2403-worktree-move.sh ##
    +@@
      
    - 		if (!(flags & OPT_FORCE)) {
    - 			struct child_process cp_rm = CHILD_PROCESS_INIT;
    -+
    - 			cp_rm.git_cmd = 1;
    - 			strvec_pushl(&cp_rm.args, "rm", "-qn",
    - 				     path, NULL);
    -@@ builtin/submodule--helper.c: static void deinit_submodule(const char *path, const char *prefix,
    - 	/* remove the .git/config entries (unless the user already did it) */
    - 	if (!capture_command(&cp_config, &sb_config, 0) && sb_config.len) {
    - 		char *sub_key = xstrfmt("submodule.%s", sub->name);
    -+
    - 		/*
    - 		 * remove the whole section so we have a clean state when
    - 		 * the user later decides to init this submodule again
    -@@ builtin/submodule--helper.c: static int clone_submodule(struct module_clone_data *clone_data)
    - 			strvec_pushl(&cp.args, "--depth", clone_data->depth, NULL);
    - 		if (clone_data->reference.nr) {
    - 			struct string_list_item *item;
    -+
    - 			for_each_string_list_item(item, &clone_data->reference)
    - 				strvec_pushl(&cp.args, "--reference",
    - 					     item->string, NULL);
    -@@ builtin/submodule--helper.c: static int prepare_to_clone_next_submodule(const struct cache_entry *ce,
    - 	strvec_pushl(&child->args, "--url", url, NULL);
    - 	if (suc->update_data->references.nr) {
    - 		struct string_list_item *item;
    -+
    - 		for_each_string_list_item(item, &suc->update_data->references)
    - 			strvec_pushl(&child->args, "--reference", item->string, NULL);
    - 	}
    -@@ builtin/submodule--helper.c: static int update_clone_get_next_task(struct child_process *child,
    - 		ce = suc->update_data->list.entries[suc->current];
    - 		if (prepare_to_clone_next_submodule(ce, child, suc, err)) {
    - 			int *p = xmalloc(sizeof(*p));
    -+
    - 			*p = suc->current;
    - 			*idx_task_cb = p;
    - 			suc->current++;
    -@@ builtin/submodule--helper.c: static int update_clone_get_next_task(struct child_process *child,
    - 	index = suc->current - suc->update_data->list.nr;
    - 	if (index < suc->failed_clones_nr) {
    - 		int *p;
    -+
    - 		ce = suc->failed_clones[index];
    - 		if (!prepare_to_clone_next_submodule(ce, child, suc, err)) {
    - 			suc->current ++;
    -@@ builtin/submodule--helper.c: static int update_clone_start_failure(struct strbuf *err,
    - 				      void *idx_task_cb)
    - {
    - 	struct submodule_update_clone *suc = suc_cb;
    -+
    - 	suc->quickstop = 1;
    - 	return 1;
    - }
    -@@ builtin/submodule--helper.c: static int update_clone_task_finished(int result,
    - {
    - 	const struct cache_entry *ce;
    - 	struct submodule_update_clone *suc = suc_cb;
    --
    - 	int *idxP = idx_task_cb;
    - 	int idx = *idxP;
    -+
    - 	free(idxP);
    + test_description='test git worktree move, remove, lock and unlock'
      
    - 	if (!result)
    -@@ builtin/submodule--helper.c: static int git_update_clone_config(const char *var, const char *value,
    - 				   void *cb)
    - {
    - 	int *max_jobs = cb;
    -+
    - 	if (!strcmp(var, "submodule.fetchjobs"))
    - 		*max_jobs = parse_submodule_fetchjobs(var, value);
    - 	return 0;
    -@@ builtin/submodule--helper.c: static int fetch_in_submodule(const char *module_path, int depth, int quiet, str
    - 	if (oid) {
    - 		char *hex = oid_to_hex(oid);
    - 		char *remote = get_default_remote();
    -+
    - 		strvec_pushl(&cp.args, remote, hex, NULL);
    - 		free(remote);
    - 	}
    -@@ builtin/submodule--helper.c: static void update_data_to_args(struct update_data *update_data, struct strvec *
    ++TEST_PASSES_SANITIZE_LEAK=true
    + . ./test-lib.sh
    + 
    + test_expect_success 'setup' '
    +
    + ## t/t7412-submodule-absorbgitdirs.sh ##
    +@@ t/t7412-submodule-absorbgitdirs.sh: This test verifies that `git submodue absorbgitdirs` moves a submodules git
    + directory into the superproject.
    + '
    + 
    ++TEST_PASSES_SANITIZE_LEAK=true
    + . ./test-lib.sh
      
    - 	if (update_data->references.nr) {
    - 		struct string_list_item *item;
    -+
    - 		for_each_string_list_item(item, &update_data->references)
    - 			strvec_pushl(args, "--reference", item->string, NULL);
    - 	}
    -@@ builtin/submodule--helper.c: static void append_fetch_remotes(struct strbuf *msg, const char *git_dir_path)
    - 	if (!capture_command(&cp_remote, &sb_remote_out, 0)) {
    - 		char *next_line;
    - 		char *line = sb_remote_out.buf;
    -+
    - 		while ((next_line = strchr(line, '\n')) != NULL) {
    - 			size_t len = next_line - line;
    -+
    - 			if (strip_suffix_mem(line, &len, " (fetch)"))
    - 				strbuf_addf(msg, "  %.*s\n", (int)len, line);
    - 			line = next_line + 1;
    -@@ builtin/submodule--helper.c: static int module_add(int argc, const char **argv, const char *prefix)
    - 		int exit_code = -1;
    - 		struct strbuf sb = STRBUF_INIT;
    - 		struct child_process cp = CHILD_PROCESS_INIT;
    -+
    - 		cp.git_cmd = 1;
    - 		cp.no_stdout = 1;
    - 		strvec_pushl(&cp.args, "add", "--dry-run", "--ignore-missing",
    + test_expect_success 'setup a real submodule' '
 8:  de49f31dab0 ! 16:  49a439cdc9d submodule--helper: move "resolve-relative-url-test" to a test-tool
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: move "resolve-relative-url-test" to a test-tool
    +    submodule--helper: free rest of "displaypath" in "struct update_data"
     
    -    As its name suggests the "resolve-relative-url-test" has never been
    -    used outside of the test suite, see 63e95beb085 (submodule: port
    -    resolve_relative_url from shell to C, 2016-04-15) for its original
    -    addition.
    +    Fix a leak in code added in c51f8f94e5b (submodule--helper: run update
    +    procedures from C, 2021-08-24), we clobber the "displaypath" member of
    +    the passed-in "struct update_data" both so that die() messages in this
    +    update_submodule() function itself can use it, and for the
    +    run_update_procedure() called within this function.
     
    -    Perhaps it would make sense to drop this code entirely, as we feel
    -    that we've got enough indirect test coverage, but let's leave that
    -    question to a possible follow-up change. For now let's keep the test
    -    coverage this gives us.
    +    To make managing that clobbering easier let's wrap the
    +    update_submodule() in a new update_submodule_outer() function, which
    +    will do the clobbering and free(to_free) dance for us.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    -@@ builtin/submodule--helper.c: static char *resolve_relative_url(const char *rel_url, const char *up_path, int
    - 	return resolved_url;
    - }
    +@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
    + {
    + 	int ret;
      
    --static int resolve_relative_url_test(int argc, const char **argv, const char *prefix)
    --{
    --	char *remoteurl, *res;
    --	const char *up_path, *url;
    --
    --	if (argc != 4)
    --		die("resolve-relative-url-test only accepts three arguments: <up_path> <remoteurl> <url>");
    --
    --	up_path = argv[1];
    --	remoteurl = xstrdup(argv[2]);
    --	url = argv[3];
    --
    --	if (!strcmp(up_path, "(null)"))
    --		up_path = NULL;
    +-	ret = ensure_core_worktree(update_data->sm_path);
    +-	if (ret)
    +-		return ret;
     -
    --	res = relative_url(remoteurl, url, up_path);
    --	puts(res);
    --	free(res);
    --	free(remoteurl);
    --	return 0;
    --}
    +-	update_data->displaypath = get_submodule_displaypath(
    +-		update_data->sm_path, update_data->prefix);
     -
    - /* the result should be freed by the caller. */
    - static char *get_submodule_displaypath(const char *path, const char *prefix)
    - {
    -@@ builtin/submodule--helper.c: static struct cmd_struct commands[] = {
    - 	{"clone", module_clone, SUPPORT_SUPER_PREFIX},
    - 	{"add", module_add, 0},
    - 	{"update", module_update, SUPPORT_SUPER_PREFIX},
    --	{"resolve-relative-url-test", resolve_relative_url_test, 0},
    - 	{"foreach", module_foreach, SUPPORT_SUPER_PREFIX},
    - 	{"init", module_init, 0},
    - 	{"status", module_status, SUPPORT_SUPER_PREFIX},
    -
    - ## t/helper/test-submodule.c ##
    -@@
    - #include "test-tool-utils.h"
    - #include "cache.h"
    - #include "parse-options.h"
    -+#include "remote.h"
    - #include "submodule-config.h"
    - #include "submodule.h"
    - 
    -@@ t/helper/test-submodule.c: static const char *submodule_is_active_usage[] = {
    - 	NULL
    - };
    - 
    -+#define TEST_TOOL_RESOLVE_RELATIVE_URL_USAGE \
    -+	"test-tool submodule resolve-relative-url <up_path> <remoteurl> <url>"
    -+static const char *submodule_resolve_relative_url_usage[] = {
    -+	TEST_TOOL_RESOLVE_RELATIVE_URL_USAGE,
    -+	NULL,
    -+};
    -+
    - static const char *submodule_usage[] = {
    - 	TEST_TOOL_CHECK_NAME_USAGE,
    - 	TEST_TOOL_IS_ACTIVE_USAGE,
    -+	TEST_TOOL_RESOLVE_RELATIVE_URL_USAGE,
    - 	NULL
    - };
    - 
    -@@ t/helper/test-submodule.c: static int cmd__submodule_is_active(int argc, const char **argv)
    - 	return !is_submodule_active(the_repository, argv[0]);
    + 	ret = determine_submodule_update_strategy(the_repository,
    + 						  update_data->just_cloned,
    + 						  update_data->sm_path,
    +@@ builtin/submodule--helper.c: static int update_submodule(struct update_data *update_data)
    + 	return 0;
      }
      
    -+static int resolve_relative_url(int argc, const char **argv)
    ++static int update_submodule_outer(struct update_data *update_data)
     +{
    -+	char *remoteurl, *res;
    -+	const char *up_path, *url;
    ++	char *to_free, *restore = update_data->displaypath;
    ++	int ret;
     +
    -+	up_path = argv[0];
    -+	remoteurl = xstrdup(argv[1]);
    -+	url = argv[2];
    ++	ensure_core_worktree(update_data->sm_path);
     +
    -+	if (!strcmp(up_path, "(null)"))
    -+		up_path = NULL;
    ++	update_data->displaypath = to_free = get_submodule_displaypath(
    ++		update_data->sm_path, update_data->prefix);
     +
    -+	res = relative_url(remoteurl, url, up_path);
    -+	puts(res);
    -+	free(res);
    -+	free(remoteurl);
    -+	return 0;
    -+}
    ++	ret = update_submodule(update_data);
     +
    -+static int cmd__submodule_resolve_relative_url(int argc, const char **argv)
    -+{
    -+	struct option options[] = {
    -+		OPT_END()
    -+	};
    -+	argc = parse_options(argc, argv, "test-tools", options,
    -+			     submodule_resolve_relative_url_usage, 0);
    -+	if (argc != 3)
    -+		usage_with_options(submodule_resolve_relative_url_usage, options);
    ++	free(to_free);
    ++	update_data->displaypath = restore;
     +
    -+	return resolve_relative_url(argc, argv);
    ++	return ret;
     +}
     +
    - static struct test_cmd cmds[] = {
    - 	{ "check-name", cmd__submodule_check_name },
    - 	{ "is-active", cmd__submodule_is_active },
    -+	{ "resolve-relative-url", cmd__submodule_resolve_relative_url},
    - };
    - 
    - int cmd__submodule(int argc, const char **argv)
    -
    - ## t/t0060-path-utils.sh ##
    -@@ t/t0060-path-utils.sh: relative_path() {
    + static int update_submodules(struct update_data *update_data)
    + {
    + 	int i, ret = 0;
    +@@ builtin/submodule--helper.c: static int update_submodules(struct update_data *update_data)
    + 		update_data->just_cloned = ucd.just_cloned;
    + 		update_data->sm_path = ucd.sub->path;
      
    - test_submodule_relative_url() {
    - 	test_expect_success "test_submodule_relative_url: $1 $2 $3 => $4" "
    --		actual=\$(git submodule--helper resolve-relative-url-test '$1' '$2' '$3') &&
    -+		actual=\$(test-tool submodule resolve-relative-url '$1' '$2' '$3') &&
    - 		test \"\$actual\" = '$4'
    - 	"
    - }
    +-		code = update_submodule(update_data);
    ++		code = update_submodule_outer(update_data);
    + 		if (!code)
    + 			continue;
    + 		ret = code;
12:  e5e267dccd5 <  -:  ----------- submodule--helper: use xstrfmt() in clone_submodule()
15:  1ff380ec7b5 <  -:  ----------- submodule--helper: add "const" to copy of "update_data"
19:  f0258e37ebe <  -:  ----------- submodule--helper: return "ret", not "1" from update_submodule()
20:  70f030cca4e <  -:  ----------- submodule--helper: add missing braces to "else" arm
21:  bce1a014a2f <  -:  ----------- submodule--helper: don't call submodule_strategy_to_string() in BUG()
22:  98c3e562c82 <  -:  ----------- submodule--helper: move submodule_strategy_to_string() to only user
28:  6160a1ab250 ! 17:  d307c5e0706 submodule--helper: fix bad config API usage
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    submodule--helper: fix bad config API usage
    +    submodule--helper: fix a configure_added_submodule() leak
     
    -    Fix bad config API usage added in a452128a36c (submodule--helper:
    -    introduce add-config subcommand, 2021-08-06). After
    -    git_config_get_string() returns successfully we know the "char **dest"
    -    will be non-NULL.
    +    Fix config API a memory leak added in a452128a36c (submodule--helper:
    +    introduce add-config subcommand, 2021-08-06) by using the *_tmp()
    +    variant of git_config_get_string().
     
    -    A coccinelle patch that transforms this turns up a couple of other
    -    such issues, one in fetch-pack.c, and another in upload-pack.c:
    +    In this case we're only checking whether
    +    the (repo|git)_config_get_string() call is telling us that the
    +    "submodule.active" key exists.
     
    -            @@
    -            identifier F =~ "^(repo|git)_config_get_string(_tmp)?$";
    -            identifier V;
    -            @@
    -              !F(..., &V)
    -            - && (V)
    +    As with the preceding commit we'll find many other such patterns in
    +    the codebase if we go fishing. E.g. "git gc" leaks in the code added
    +    in 61f7a383d3b (maintenance: use 'incremental' strategy by default,
    +    2020-10-15). Similar code in "git gc" added in
    +    b08ff1fee00 (maintenance: add --schedule option and config,
    +    2020-09-11) doesn't leak, but we could avoid the malloc() & free() in
    +    that case.
     
    -    But let's focus narrowly on submodule--helper for now, we can fix
    -    those some other time.
    +    A coccinelle rule to find those would find and fix some leaks, and
    +    cases where we're doing needless malloc() + free()'s but only care
    +    about the key existence, or are copying
    +    the (repo|git)_config_get_string() return value right away.
    +
    +    But as with the preceding commit let's punt on all of that for now,
    +    and just narrowly fix this specific case in submodule--helper.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/submodule--helper.c ##
    +@@ builtin/submodule--helper.c: static int config_submodule_in_gitmodules(const char *name, const char *var, con
    + static void configure_added_submodule(struct add_data *add_data)
    + {
    + 	char *key;
    +-	char *val = NULL;
    ++	const char *val;
    + 	struct child_process add_submod = CHILD_PROCESS_INIT;
    + 	struct child_process add_gitmodules = CHILD_PROCESS_INIT;
    + 
     @@ builtin/submodule--helper.c: static void configure_added_submodule(struct add_data *add_data)
      	 * is_submodule_active(), since that function needs to find
      	 * out the value of "submodule.active" again anyway.
      	 */
    --	if (!git_config_get_string("submodule.active", &val) && val) {
    -+	if (!git_config_get_string("submodule.active", &val)) {
    +-	if (!git_config_get_string("submodule.active", &val)) {
    ++	if (!git_config_get_string_tmp("submodule.active", &val)) {
      		/*
      		 * If the submodule being added isn't already covered by the
      		 * current configured pathspec, set the submodule's active flag
    +
    + ## t/t7413-submodule-is-active.sh ##
    +@@ t/t7413-submodule-is-active.sh: This is a unit test of the submodule.c is_submodule_active() function,
    + which is also indirectly tested elsewhere.
    + '
    + 
    ++TEST_PASSES_SANITIZE_LEAK=true
    + . ./test-lib.sh
    + 
    + test_expect_success 'setup' '
-- 
2.37.2.1279.g64dec4e13cf

