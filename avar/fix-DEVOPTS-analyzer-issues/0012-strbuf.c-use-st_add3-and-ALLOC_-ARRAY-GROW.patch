From 9b3c0eef45b9a82a723e1bf285d46f53752543f1 Mon Sep 17 00:00:00 2001
Message-Id: <RFC-patch-12.14-9b3c0eef45b-20220603T162512Z-avarab@gmail.com>
In-Reply-To: <RFC-cover-00.14-00000000000-20220603T162512Z-avarab@gmail.com>
References: <RFC-cover-00.14-00000000000-20220603T162512Z-avarab@gmail.com>
From: =?UTF-8?q?=C3=86var=20Arnfj=C3=B6r=C3=B0=20Bjarmason?=
 <avarab@gmail.com>
Date: Fri, 3 Jun 2022 17:20:04 +0200
Subject: [RFC PATCH 12/14] strbuf.c: use st_add3() and ALLOC_{ARRAY,GROW}()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Change the strbuf_grow() function so that GCC v12's -fanalyze doesn't
yell at us about sb->buf[0] dereferencing NULL, this also makes this
code easier to understand.

This allows us to get rid of our own unsigned_add_overflows() was
originally added in b449f4cfc97 (Rework strbuf API and semantics.,
2007-09-06) and adjusted in 1368f65002b (compat: helper for detecting
unsigned overflow, 2010-10-10). Instead we compute a "sz" with
st_add3().

That was done at a time when the underlying xrealloc() in
git-compat-util.h didn't use st_mult() yet, that has been the case
since the later e7792a74bcf (harden REALLOC_ARRAY and xcalloc against
size_t overflow, 2016-02-22).

But more importantly by splitting up the ALLOC_ARRAY() case from
ALLOC_GROW() we make it clearer to both human and machine what it is
that we need for each of these cases. We only needed to set sb->buf to
NULL because we were unconditionally calling realloc(), let's instead
call malloc() in that case.

The only behavior change here should be the very obscure edge case
that we'd previously die() in cases where we strictly didn't need to,
as we'd check both "extra + 1" and "sb->len + extra + 1" for
overflow. If we overflowed only on the latter but were doing the
former we'd needlessly die() die. I don't think that difference
mattered, but it's noted here for completeness.

Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
---
 strbuf.c | 16 ++++++++++------
 1 file changed, 10 insertions(+), 6 deletions(-)

diff --git a/strbuf.c b/strbuf.c
index dd9eb85527a..6a6bb8a2840 100644
--- a/strbuf.c
+++ b/strbuf.c
@@ -91,14 +91,18 @@ void strbuf_attach(struct strbuf *sb, void *buf, size_t len, size_t alloc)
 void strbuf_grow(struct strbuf *sb, size_t extra)
 {
 	int new_buf = !sb->alloc;
-	if (unsigned_add_overflows(extra, 1) ||
-	    unsigned_add_overflows(sb->len, extra + 1))
-		die("you want to use way too much memory");
-	if (new_buf)
+	const size_t sz_buf = new_buf ? 0 : sb->len;
+	const size_t sz = st_add3(sz_buf, extra, 1 /* for \0 */);
+
+	if (new_buf) {
 		sb->buf = NULL;
-	ALLOC_GROW(sb->buf, sb->len + extra + 1, sb->alloc);
-	if (new_buf)
+		ALLOC_ARRAY(sb->buf, sz);
+		sb->alloc = sz;
 		sb->buf[0] = '\0';
+		return;
+	}
+
+	ALLOC_GROW(sb->buf, sz, sb->alloc);
 }
 
 void strbuf_trim(struct strbuf *sb)
-- 
2.36.1.1122.g5c3e018b1ae

