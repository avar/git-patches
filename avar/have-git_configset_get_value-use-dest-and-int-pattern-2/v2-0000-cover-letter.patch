From e2f8f7c52e3deaf3789af2a7855de0915158205a Mon Sep 17 00:00:00 2001
Message-Id: <cover-v2-0.9-00000000000-20221101T225459Z-avarab@gmail.com>
In-Reply-To: <cover-00.10-00000000000-20221026T151328Z-avarab@gmail.com>
References: <cover-00.10-00000000000-20221026T151328Z-avarab@gmail.com>
From: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
Date: Tue, 1 Nov 2022 23:54:59 +0100
Subject: [PATCH v2 0/9] *** SUBJECT HERE ***
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

*** BLURB HERE ***

Ævar Arnfjörð Bjarmason (9):
  for-each-repo tests: test bad --config keys
  config tests: cover blind spots in git_die_config() tests
  config tests: add "NULL" tests for *_get_value_multi()
  versioncmp.c: refactor config reading next commit
  config API: have *_multi() return an "int" and take a "dest"
  for-each-repo: error on bad --config
  config API users: test for *_get_value_multi() segfaults
  config API: add "string" version of *_value_multi(), fix segfaults
  for-each-repo: with bad config, don't conflate <path> and <cmd>

 builtin/for-each-repo.c              | 14 ++---
 builtin/gc.c                         |  6 +-
 builtin/log.c                        |  5 +-
 builtin/submodule--helper.c          |  6 +-
 config.c                             | 88 +++++++++++++++++++++++-----
 config.h                             | 50 +++++++++++++---
 pack-bitmap.c                        |  6 +-
 submodule.c                          |  3 +-
 t/helper/test-config.c               |  6 +-
 t/t0068-for-each-repo.sh             | 19 ++++++
 t/t1308-config-set.sh                | 30 ++++++++++
 t/t3309-notes-merge-auto-resolve.sh  |  7 ++-
 t/t4202-log.sh                       | 15 +++++
 t/t5304-prune.sh                     | 12 +++-
 t/t5310-pack-bitmaps.sh              | 21 +++++++
 t/t5552-skipping-fetch-negotiator.sh | 16 +++++
 t/t7004-tag.sh                       | 17 ++++++
 t/t7413-submodule-is-active.sh       | 16 +++++
 t/t7900-maintenance.sh               | 38 ++++++++++++
 versioncmp.c                         | 22 ++++---
 20 files changed, 337 insertions(+), 60 deletions(-)

Range-diff against v1:
 2:  e17de2a2664 !  1:  b8fd3bea4d1 for-each-repo: error on bad --config
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    for-each-repo: error on bad --config
    +    for-each-repo tests: test bad --config keys
     
         As noted in 6c62f015520 (for-each-repo: do nothing on empty config,
         2021-01-08) this command wants to ignore a non-existing config key,
    -    but let's not conflate that with bad config.
    +    but it's been conflating that with bad config keys.
     
    -    We could preserve the comment added in 6c62f015520, but now that we're
    -    directly using the documented repo_config_get_value_multi() value it's
    -    just narrating something that should be obvious from the API use, so
    -    let's drop it.
    +    A subsequent commit will address that, but for now let's fix the gaps
    +    in test coverage, and show what we're currently doing in these cases.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
    - ## builtin/for-each-repo.c ##
    -@@ builtin/for-each-repo.c: int cmd_for_each_repo(int argc, const char **argv, const char *prefix)
    - {
    - 	static const char *config_key = NULL;
    - 	int i, result = 0;
    --	const struct string_list *values = NULL;
    -+	const struct string_list *values;
    -+	int err;
    - 
    - 	const struct option options[] = {
    - 		OPT_STRING(0, "config", &config_key, N_("config"),
    -@@ builtin/for-each-repo.c: int cmd_for_each_repo(int argc, const char **argv, const char *prefix)
    - 	if (!config_key)
    - 		die(_("missing --config=<config>"));
    - 
    --	repo_config_get_value_multi(the_repository, config_key, &values);
    --
    --	/*
    --	 * Do nothing on an empty list, which is equivalent to the case
    --	 * where the config variable does not exist at all.
    --	 */
    --	if (!values)
    -+	err = repo_config_get_value_multi(the_repository, config_key, &values);
    -+	if (err < 0)
    -+		usage_msg_optf(_("got bad config --config=%s"),
    -+			       for_each_repo_usage, options, config_key);
    -+	else if (err)
    - 		return 0;
    - 
    - 	for (i = 0; !result && i < values->nr; i++)
    -
      ## t/t0068-for-each-repo.sh ##
     @@ t/t0068-for-each-repo.sh: test_expect_success 'do nothing on empty config' '
      	git for-each-repo --config=bogus.config -- help --no-such-option
      '
      
    -+test_expect_success 'error on bad config keys' '
    -+	test_expect_code 129 git for-each-repo --config=a &&
    -+	test_expect_code 129 git for-each-repo --config=a.b. &&
    -+	test_expect_code 129 git for-each-repo --config="'\''.b"
    ++test_expect_success 'bad config keys' '
    ++	git for-each-repo --config=a &&
    ++	git for-each-repo --config=a.b. &&
    ++	git for-each-repo --config="'\''.b"
     +'
     +
      test_done
 6:  9c36f17481b !  2:  6cd0d6faf3c builtin/gc.c: use "unsorted_string_list_has_string()" where appropriate
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    builtin/gc.c: use "unsorted_string_list_has_string()" where appropriate
    +    config tests: cover blind spots in git_die_config() tests
     
    -    Refactor a "do I have an element like this?" pattern added in [1] and
    -    [2] to use unsorted_string_list_has_string() instead of a
    -    for_each_string_list_item() loop.
    +    There were no tests checking for the output of the git_die_config()
    +    function in the config API, added in 5a80e97c827 (config: add
    +    `git_die_config()` to the config-set API, 2014-08-07). We only tested
    +    "test_must_fail", but didn't assert the output.
     
    -    A preceding commit added a "const" to the "struct string_list *"
    -    argument of unsorted_string_list_has_string(), it'll thus play nicely
    -    with git_config_get_const_value_multi() without needing a cast here.
    +    Let's check for that by extending the existing tests, and adding a new
    +    one for "fetch.negotiationAlgorithm" so that we have a test for a user
    +    of git_config_get_string*() calling git_die_config().
     
    -    1. 1ebe6b02970 (maintenance: add 'unregister --force', 2022-09-27)
    -    2. 50a044f1e40 (gc: replace config subprocesses with API calls,
    -       2022-09-27)
    +    The other ones are testing:
    +
    +    - For *-resolve.sh: A custom call to git_die_config(), or via
    +      git_config_get_notes_strategy()
    +    - For *-prune.sh: A call via git_config_get_expiry().
    +
    +    We also cover both the "from command-line config" and "in file..at
    +    line" cases here.
    +
    +    The clobbering of existing ".git/config" files here is so that we're
    +    not implicitly testing the line count of the default config.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
    - ## builtin/gc.c ##
    -@@ builtin/gc.c: static int maintenance_register(int argc, const char **argv, const char *prefix)
    - 	const char *key = "maintenance.repo";
    - 	char *config_value;
    - 	char *maintpath = get_maintpath();
    --	struct string_list_item *item;
    - 	const struct string_list *list;
    - 
    - 	argc = parse_options(argc, argv, prefix, options,
    -@@ builtin/gc.c: static int maintenance_register(int argc, const char **argv, const char *prefix)
    - 	else
    - 		git_config_set("maintenance.strategy", "incremental");
    + ## t/t3309-notes-merge-auto-resolve.sh ##
    +@@ t/t3309-notes-merge-auto-resolve.sh: test_expect_success 'merge z into y with invalid strategy => Fail/No changes' '
      
    --	if (!git_config_get_knownkey_value_multi(key, &list)) {
    --		for_each_string_list_item(item, list) {
    --			if (!strcmp(maintpath, item->string)) {
    --				found = 1;
    --				break;
    --			}
    --		}
    --	}
    -+	if (!git_config_get_knownkey_value_multi(key, &list))
    -+		found = unsorted_string_list_has_string(list, maintpath);
    - 
    - 	if (!found) {
    - 		int rc;
    -@@ builtin/gc.c: static int maintenance_unregister(int argc, const char **argv, const char *prefi
    - 	const char *key = "maintenance.repo";
    - 	char *maintpath = get_maintpath();
    - 	int found = 0;
    --	struct string_list_item *item;
    - 	const struct string_list *list;
    + test_expect_success 'merge z into y with invalid configuration option => Fail/No changes' '
    + 	git config core.notesRef refs/notes/y &&
    +-	test_must_fail git -c notes.mergeStrategy="foo" notes merge z &&
    ++	cat >expect <<-\EOF &&
    ++	error: unknown notes merge strategy foo
    ++	fatal: unable to parse '\''notes.mergeStrategy'\'' from command-line config
    ++	EOF
    ++	test_must_fail git -c notes.mergeStrategy="foo" notes merge z 2>actual &&
    ++	test_cmp expect actual &&
    + 	# Verify no changes (y)
    + 	verify_notes y y
    + '
    +
    + ## t/t5304-prune.sh ##
    +@@ t/t5304-prune.sh: test_expect_success 'gc: implicit prune --expire' '
    + '
      
    - 	argc = parse_options(argc, argv, prefix, options,
    -@@ builtin/gc.c: static int maintenance_unregister(int argc, const char **argv, const char *prefi
    - 		usage_with_options(builtin_maintenance_unregister_usage,
    - 				   options);
    + test_expect_success 'gc: refuse to start with invalid gc.pruneExpire' '
    +-	git config gc.pruneExpire invalid &&
    +-	test_must_fail git gc
    ++	test_when_finished "rm -rf repo" &&
    ++	git init repo &&
    ++	>repo/.git/config &&
    ++	git -C repo config gc.pruneExpire invalid &&
    ++	cat >expect <<-\EOF &&
    ++	error: Invalid gc.pruneexpire: '\''invalid'\''
    ++	fatal: bad config variable '\''gc.pruneexpire'\'' in file '\''.git/config'\'' at line 2
    ++	EOF
    ++	test_must_fail git -C repo gc 2>actual &&
    ++	test_cmp expect actual
    + '
      
    --	if (!git_config_get_knownkey_value_multi(key, &list)) {
    --		for_each_string_list_item(item, list) {
    --			if (!strcmp(maintpath, item->string)) {
    --				found = 1;
    --				break;
    --			}
    --		}
    --	}
    -+	if (!git_config_get_knownkey_value_multi(key, &list))
    -+		found = unsorted_string_list_has_string(list, maintpath);
    + test_expect_success 'gc: start with ok gc.pruneExpire' '
    +
    + ## t/t5552-skipping-fetch-negotiator.sh ##
    +@@
    + test_description='test skipping fetch negotiator'
    + . ./test-lib.sh
      
    - 	if (found) {
    - 		int rc;
    ++test_expect_success 'fetch.negotiationalgorithm config' '
    ++	test_when_finished "rm -rf repo" &&
    ++	git init repo &&
    ++	cat >repo/.git/config <<-\EOF &&
    ++	[fetch]
    ++	negotiationAlgorithm
    ++	EOF
    ++	cat >expect <<-\EOF &&
    ++	error: missing value for '\''fetch.negotiationalgorithm'\''
    ++	fatal: bad config variable '\''fetch.negotiationalgorithm'\'' in file '\''.git/config'\'' at line 2
    ++	EOF
    ++	test_expect_code 128 git -C repo fetch >out 2>actual &&
    ++	test_must_be_empty out &&
    ++	test_cmp expect actual
    ++'
    ++
    + have_sent () {
    + 	while test "$#" -ne 0
    + 	do
 8:  e7568dbe6fe =  3:  f2a8766a802 config tests: add "NULL" tests for *_get_value_multi()
 3:  3519d3de010 !  4:  42cfc61202d config API: mark *_multi() with RESULT_MUST_BE_USED
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    config API: mark *_multi() with RESULT_MUST_BE_USED
    +    versioncmp.c: refactor config reading next commit
     
    -    Use the RESULT_MUST_BE_USED attribute to assert that all users of
    -    the *_multi() API use the return values, in the preceding commit
    -    "for-each-repo" started using the return value meaningfully.
    +    Refactor the reading of the versionSort.suffix and
    +    versionSort.prereleaseSuffix configuration variables to stay within
    +    the bounds of our CodingGuidelines when it comes to line length, and
    +    ta avoid repeating ourselves.
     
    -    This requires changing versioncmp() so that we use the "ret" versions
    -    of the return values, and don't implicitly rely on
    -    "deprecated_prereleases" being set to NULL if the key didn't exist.
    +    Let's also split out the names of the config variables into variables
    +    of our own, so we don't have to repeat ourselves, and refactor the
    +    nested if/else to avoid indenting it, and the existing bracing style
    +    issue.
     
    -    See 1e8697b5c4e (submodule--helper: check repo{_submodule,}_init()
    -    return values, 2022-09-01) for the introduction of
    -    RESULT_MUST_BE_USED.
    +    This all helps with the subsequent commit, where we'll need to start
    +    checking different git_config_get_value_multi() return value. See
    +    c026557a373 (versioncmp: generalize version sort suffix reordering,
    +    2016-12-08) for the original implementation of most of this.
     
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +    Moving the "initialized = 1" assignment allows us to move some of this
    +    to the variable declarations in the subsequent commit.
     
    - ## config.h ##
    -@@ config.h: int git_configset_add_parameters(struct config_set *cs);
    -  * The caller should not free or modify the returned pointer, as it is
    -  * owned by the cache.
    -  */
    -+RESULT_MUST_BE_USED
    - int git_configset_get_value_multi(struct config_set *cs, const char *key,
    - 				  const struct string_list **dest);
    - 
    -@@ config.h: int git_configset_get_value_multi(struct config_set *cs, const char *key,
    -  * value is < 0. Use it for keys known to pass git_config_parse_key(),
    -  * i.e. those hardcoded in the code, and never user-provided keys.
    -  */
    -+RESULT_MUST_BE_USED
    - int git_configset_get_knownkey_value_multi(struct config_set *cs,
    - 					   const char *const key,
    - 					   const struct string_list **dest);
    -@@ config.h: struct repository;
    - void repo_config(struct repository *repo, config_fn_t fn, void *data);
    - int repo_config_get_value(struct repository *repo,
    - 			  const char *key, const char **value);
    -+RESULT_MUST_BE_USED
    - int repo_config_get_value_multi(struct repository *repo,
    - 				const char *key,
    - 				const struct string_list **dest);
    -+RESULT_MUST_BE_USED
    - int repo_config_get_knownkey_value_multi(struct repository *repo,
    - 					 const char *const key,
    - 					 const struct string_list **dest);
    -@@ config.h: int git_config_get_value(const char *key, const char **value);
    -  * The caller should not free or modify the returned pointer, as it is
    -  * owned by the cache.
    -  */
    -+RESULT_MUST_BE_USED
    - int git_config_get_value_multi(const char *key,
    - 			       const struct string_list **dest);
    - 
    -@@ config.h: int git_config_get_value_multi(const char *key,
    -  * git_configset_get_knownkey_value_multi() does for
    -  * git_configset_get_value_multi().
    -  */
    -+RESULT_MUST_BE_USED
    - int git_config_get_knownkey_value_multi(const char *const key,
    - 					const struct string_list **dest);
    - 
    +    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## versioncmp.c ##
     @@ versioncmp.c: int versioncmp(const char *s1, const char *s2)
      	}
      
      	if (!initialized) {
    --		const struct string_list *deprecated_prereleases = NULL;
    -+		const struct string_list *deprecated_prereleases;
    -+		int prereleases_ret, deprecated_prereleases_ret;
    - 
    +-		const struct string_list *deprecated_prereleases;
    ++		const char *const newk = "versionsort.suffix";
    ++		const char *const oldk = "versionsort.prereleasesuffix";
    ++		const struct string_list *oldl;
    ++
    ++		prereleases = git_config_get_value_multi(newk);
    ++		oldl = git_config_get_value_multi(oldk);
    ++		if (prereleases && oldl)
    ++			warning("ignoring %s because %s is set", oldk, newk);
    ++		else if (!prereleases)
    ++			prereleases = oldl;
    ++
      		initialized = 1;
    --		git_config_get_knownkey_value_multi("versionsort.suffix",
    --						 &prereleases);
    --		git_config_get_value_multi("versionsort.prereleasesuffix",
    --					   &deprecated_prereleases);
    --
    +-		prereleases = git_config_get_value_multi("versionsort.suffix");
    +-		deprecated_prereleases = git_config_get_value_multi("versionsort.prereleasesuffix");
     -		if (prereleases) {
     -			if (deprecated_prereleases)
    -+		prereleases_ret =
    -+			git_config_get_knownkey_value_multi("versionsort.suffix",
    -+							    &prereleases);
    -+		deprecated_prereleases_ret =
    -+			git_config_get_knownkey_value_multi("versionsort.prereleasesuffix",
    -+							    &deprecated_prereleases);
    -+
    -+		if (!prereleases_ret) {
    -+			if (!deprecated_prereleases_ret)
    - 				warning("ignoring versionsort.prereleasesuffix because versionsort.suffix is set");
    +-				warning("ignoring versionsort.prereleasesuffix because versionsort.suffix is set");
     -		} else
    -+		} else if (!deprecated_prereleases_ret) {
    - 			prereleases = deprecated_prereleases;
    -+		}
    +-			prereleases = deprecated_prereleases;
      	}
      	if (prereleases && swap_prereleases(s1, s2, (const char *) p1 - s1 - 1,
      					    &diff))
 1:  eefa253ab1f !  5:  48fb7cbf585 config API: have *_multi() return an "int" and take a "dest"
    @@ Metadata
      ## Commit message ##
         config API: have *_multi() return an "int" and take a "dest"
     
    -    The git_configset_get_value_multi() function added in 3c8687a73ee (add
    -    `config_set` API for caching config-like files, 2014-07-28) is a
    -    fundamental part of of the config API, and
    -    e.g. "git_config_get_value()" and others are implemented in terms of
    -    it.
    +    Have the "git_configset_get_value_multi()" function and its siblings
    +    return an "int" and populate a "**dest" parameter like every other
    +    git_configset_get_*()" in the API.
     
    -    But it has had the limitation that configset_find_element() calls
    -    git_config_parse_key(), but then throws away the distinction between a
    -    "ret < 1" return value from it, and return values that indicate a key
    -    doesn't exist. As a result the git_config_get_value_multi() function
    -    would either return a "const struct string_list *", or NULL.
    +    As we'll see in in subsequent commits this fixes a blind spot in the
    +    API where it wasn't possible to tell whether a list was empty from
    +    whether a config key existed. We'll take advantage of that in
    +    subsequent commits, but for now we're faithfully converting existing
    +    API callers.
     
    -    By changing the *_multi() function to return an "int" for the status
    -    and to write to a "const struct string_list **dest" parameter we can
    -    avoid losing this information. API callers can now do:
    +    See [1] for the initial addition of "git_configset_get_value_multi()"
     
    -            const struct string_list *dest;
    -            int ret;
    +    1. 3c8687a73ee (add `config_set` API for caching config-like files,
    +       2014-07-28).
     
    -            ret = git_config_get_value_multi(key, &dest);
    -            if (ret < 1)
    -                    die("bad key: %s", key);
    -            else if (ret)
    -                    ; /* key does not exist */
    -            else
    -                    ; /* got key, can use "dest" */
    -
    -    A "get_knownkey_value_multi" variant is also provided, which will
    -    BUG() out in the "ret < 1" case. This is useful in the cases where we
    -    hardcode the keyname in our source code, and therefore use the more
    -    idiomatic pattern of:
    -
    -            if (!git_config_get_value_multi(key, &dest)
    -                    ; /* got key, can use "dest" */
    -            else
    -                    ; /* key does not exist */
    +    A logical follow-up to this would be to change the various "*_get_*()"
    +    functions to ferry the git_configset_get_value() return value to their
    +    own callers, e.g. git_configset_get_int() returns "1" rather than
    +    ferrying up the "-1" that "git_configset_get_value()" might return,
    +    but that's not being done in this series
     
    -    The "knownkey" name was picked instead of e.g. "const" to avoid a
    -    repeat of the issues noted in f1de981e8b6 (config: fix leaks from
    -    git_config_get_string_const(), 2020-08-14) and 9a53219f69b (config:
    -    drop git_config_get_string_const(), 2020-08-17). API users might think
    -    that "const" means that the value(s) don't need to be free'd.
    +    Most of this is straightforward, commentary on cases that stand out:
     
    -    As noted in commentary here we treat git_die_config() as a
    -    special-case, i.e. we assume that a value we're complaining about has
    -    already had its key pass the git_config_parse_key() check.
    +    - As we've tested for in a preceding commit we can rely on getting the
    +      config list in git_die_config(), and as we need to handle the new
    +      return value let's BUG() out if we can't acquire it.
     
    -    Likewise we consider the keys passed to "t/helper/test-config.c" to be
    -    "knownkey", and will emit a BUG() if they don't pass
    -    git_config_parse_key(). Those will come from our *.sh tests, so
    -    they're also "known keys" coming from our sources.
    +    - In "builtin/for-each-ref.c" we could preserve the comment added in
    +      6c62f015520, but now that we're directly using the documented
    +      repo_config_get_value_multi() value it's just narrating something that
    +      should be obvious from the API use, so let's drop it.
     
    -    A logical follow-up to this would be to change the various "*_get_*()"
    -    functions to ferry the git_configset_get_value() return value to their
    -    own callers, e.g.:
    +    - The loops after getting the "list" value in "builtin/gc.c" could
    +      also make use of "unsorted_string_list_has_string()" instead of using
    +      that loop, but let's leave that for now.
     
    -            diff --git a/config.c b/config.c
    -            index 094ad899e0b..7e8ee4cfec1 100644
    -            --- a/config.c
    -            +++ b/config.c
    -            @@ -2479,11 +2479,14 @@ static int git_configset_get_string_tmp(struct config_set *cs, const char *key,
    -             int git_configset_get_int(struct config_set *cs, const char *key, int *dest)
    -             {
    -                    const char *value;
    -            -       if (!git_configset_get_value(cs, key, &value)) {
    -            -               *dest = git_config_int(key, value);
    -            -               return 0;
    -            -       } else
    -            -               return 1;
    -            +       int ret;
    -            +
    -            +       if ((ret = git_configset_get_value(cs, key, &value)))
    -            +               goto done;
    -            +
    -            +       *dest = git_config_int(key, value);
    -            +done:
    -            +       return ret;
    -             }
    +    - We have code e.g. in "builtin/submodule--helper.c" that only wants
    +      to check if a config key exists, and would be better served with
    +      another API, but let's keep using "git_configset_get_value_multi()"
    +      for now.
     
    -             int git_configset_get_ulong(struct config_set *cs, const char *key, unsigned long *dest)
    +    - In "versioncmp.c" we now use the return value of the functions,
    +      instead of checking if the lists are still non-NULL. This is strictly
    +      speaking unnecessary, but makes the API use consistent with the rest,
    +      but more importantly...
     
    -    Most of those callers don't care, and call those functions as
    -    "if (!func(...))", but if they do they'll be able to tell key
    -    non-existence from errors we encounter. Before this change those API
    -    users would have been unable to tell the two conditions apart, as
    -    git_configset_get_value() hid the difference.
    +    - ...because we always check our return values we can assert that with
    +      the RESULT_MUST_BE_USED macro added in 1e8697b5c4e (submodule--helper:
    +      check repo{_submodule,}_init() return values, 2022-09-01)
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## builtin/for-each-repo.c ##
     @@ builtin/for-each-repo.c: int cmd_for_each_repo(int argc, const char **argv, const char *prefix)
    - {
      	static const char *config_key = NULL;
      	int i, result = 0;
    --	const struct string_list *values;
    -+	const struct string_list *values = NULL;
    + 	const struct string_list *values;
    ++	int err;
      
      	const struct option options[] = {
      		OPT_STRING(0, "config", &config_key, N_("config"),
    @@ builtin/for-each-repo.c: int cmd_for_each_repo(int argc, const char **argv, cons
      
     -	values = repo_config_get_value_multi(the_repository,
     -					     config_key);
    -+	repo_config_get_value_multi(the_repository, config_key, &values);
    +-
    +-	/*
    +-	 * Do nothing on an empty list, which is equivalent to the case
    +-	 * where the config variable does not exist at all.
    +-	 */
    +-	if (!values)
    ++	err = repo_config_get_value_multi(the_repository, config_key, &values);
    ++	if (err < 0)
    ++		return 0;
    ++	else if (err)
    + 		return 0;
      
    - 	/*
    - 	 * Do nothing on an empty list, which is equivalent to the case
    + 	for (i = 0; !result && i < values->nr; i++)
     
      ## builtin/gc.c ##
     @@ builtin/gc.c: static int maintenance_register(int argc, const char **argv, const char *prefix)
    @@ builtin/gc.c: static int maintenance_register(int argc, const char **argv, const
      
     -	list = git_config_get_value_multi(key);
     -	if (list) {
    -+	if (!git_config_get_knownkey_value_multi(key, &list)) {
    ++	if (!git_config_get_value_multi(key, &list)) {
      		for_each_string_list_item(item, list) {
      			if (!strcmp(maintpath, item->string)) {
      				found = 1;
    @@ builtin/gc.c: static int maintenance_unregister(int argc, const char **argv, con
      
     -	list = git_config_get_value_multi(key);
     -	if (list) {
    -+	if (!git_config_get_knownkey_value_multi(key, &list)) {
    ++	if (!git_config_get_value_multi(key, &list)) {
      		for_each_string_list_item(item, list) {
      			if (!strcmp(maintpath, item->string)) {
      				found = 1;
    @@ builtin/log.c: static void set_default_decoration_filter(struct decoration_filte
     +	const struct string_list *config_exclude;
      
     -	if (config_exclude) {
    -+	if (!git_config_get_knownkey_value_multi("log.excludeDecoration",
    -+					      &config_exclude)) {
    ++	if (!git_config_get_value_multi("log.excludeDecoration",
    ++					&config_exclude)) {
      		struct string_list_item *item;
      		for_each_string_list_item(item, config_exclude)
      			string_list_append(decoration_filter->exclude_ref_config_pattern,
    @@ builtin/submodule--helper.c: static int module_update(int argc, const char **arg
      		struct init_cb info = INIT_CB_INIT;
     +		const struct string_list *values;
      
    - 		if (module_list_compute(argc, argv, opt.prefix,
    + 		if (module_list_compute(argv, opt.prefix,
      					&pathspec2, &list) < 0) {
     @@ builtin/submodule--helper.c: static int module_update(int argc, const char **argv, const char *prefix)
      		 * If there are no path args and submodule.active is set then,
    @@ config.c: static int configset_add_value(struct config_set *cs, const char *key,
      	/*
      	 * Since the keys are being fed by git_config*() callback mechanism, they
      	 * are already normalized. So simply add them without any further munging.
    -@@ config.c: int git_configset_add_parameters(struct config_set *cs)
    +@@ config.c: int git_configset_add_file(struct config_set *cs, const char *filename)
      int git_configset_get_value(struct config_set *cs, const char *key, const char **value)
      {
      	const struct string_list *values = NULL;
    @@ config.c: int git_configset_add_parameters(struct config_set *cs)
      }
      
     -const struct string_list *git_configset_get_value_multi(struct config_set *cs, const char *key)
    -+static int git_configset_get_value_multi_1(struct config_set *cs, const char *key,
    -+					   const struct string_list **dest,
    -+					   int knownkey)
    ++int git_configset_get_value_multi(struct config_set *cs, const char *key,
    ++				  const struct string_list **dest)
      {
     -	struct config_set_element *e = configset_find_element(cs, key);
     -	return e ? &e->value_list : NULL;
    @@ config.c: int git_configset_add_parameters(struct config_set *cs)
     +	int ret;
     +
     +	ret = configset_find_element(cs, key, &e);
    -+	if (ret < 0 && knownkey)
    -+		BUG("*_get_knownkey_*() only accepts known-good (hardcoded) keys, but '%s' is bad!", key);
    -+	else if (ret < 0)
    ++	if (ret < 0)
     +		return ret;
     +	else if (!e)
     +		return 1;
     +	*dest = &e->value_list;
     +
     +	return 0;
    -+}
    -+
    -+int git_configset_get_value_multi(struct config_set *cs, const char *key,
    -+				  const struct string_list **dest)
    -+{
    -+	return git_configset_get_value_multi_1(cs, key, dest, 0);
    -+}
    -+
    -+int git_configset_get_knownkey_value_multi(struct config_set *cs,
    -+					   const char *const key,
    -+					   const struct string_list **dest)
    -+{
    -+	return git_configset_get_value_multi_1(cs, key, dest, 1);
      }
      
      int git_configset_get_string(struct config_set *cs, const char *key, char **dest)
    @@ config.c: int repo_config_get_value(struct repository *repo,
      
     -const struct string_list *repo_config_get_value_multi(struct repository *repo,
     -						      const char *key)
    -+int repo_config_get_value_multi(struct repository *repo,
    -+				const char *key,
    ++int repo_config_get_value_multi(struct repository *repo, const char *key,
     +				const struct string_list **dest)
      {
      	git_config_check_init(repo);
     -	return git_configset_get_value_multi(repo->config, key);
     +	return git_configset_get_value_multi(repo->config, key, dest);
    -+}
    -+
    -+int repo_config_get_knownkey_value_multi(struct repository *repo,
    -+					 const char *const key,
    -+					 const struct string_list **dest)
    -+{
    -+	git_config_check_init(repo);
    -+	return git_configset_get_knownkey_value_multi(repo->config, key, dest);
      }
      
      int repo_config_get_string(struct repository *repo,
    @@ config.c: int git_config_get_value(const char *key, const char **value)
      
     -const struct string_list *git_config_get_value_multi(const char *key)
     +int git_config_get_value_multi(const char *key, const struct string_list **dest)
    -+{
    -+	return repo_config_get_value_multi(the_repository, key, dest);
    -+}
    -+
    -+int git_config_get_knownkey_value_multi(const char *const key,
    -+					const struct string_list **dest)
      {
     -	return repo_config_get_value_multi(the_repository, key);
    -+	return repo_config_get_knownkey_value_multi(the_repository, key, dest);
    ++	return repo_config_get_value_multi(the_repository, key, dest);
      }
      
      int git_config_get_string(const char *key, char **dest)
    @@ config.c: void git_die_config(const char *key, const char *err, ...)
      		va_end(params);
      	}
     -	values = git_config_get_value_multi(key);
    -+
    -+	/*
    -+	 * We don't have a "const" key here, but we should definitely
    -+	 * have one that's passed git_config_parse_key() already, if
    -+	 * we're at the point of complaining about its value. So let's
    -+	 * use *_knownkey_value_multi() here to get that BUG(...).
    -+	 */
    -+	if (git_config_get_knownkey_value_multi(key, &values))
    -+		BUG("key '%s' does not exist, should not be given to git_die_config()",
    -+		    key);
    ++	if (git_config_get_value_multi(key, &values))
    ++		BUG("for key '%s' we must have a value to report on", key);
      	kv_info = values->items[values->nr - 1].util;
      	git_die_config_linenr(key, kv_info->filename, kv_info->linenr);
      }
     
      ## config.h ##
     @@ config.h: int git_configset_add_parameters(struct config_set *cs);
    - 
      /**
       * Finds and returns the value list, sorted in order of increasing priority
    -- * for the configuration variable `key` and config set `cs`. When the
    +  * for the configuration variable `key` and config set `cs`. When the
     - * configuration variable `key` is not found, returns NULL. The caller
     - * should not free or modify the returned pointer, as it is owned by the cache.
    -+ * for the configuration variable `key` and config set `cs`.
    -+ *
    -+ * When the configuration variable `key` is not found, returns 1
    -+ * without touching `value`.
    ++ * configuration variable `key` is not found, returns 1 without touching
    ++ * `value`.
     + *
     + * The key will be parsed for validity with git_config_parse_key(), on
    -+ * error a negative value will be returned. See
    -+ * git_configset_get_knownkey_value_multi() for a version of this which
    -+ * BUG()s out on negative return values.
    ++ * error a negative value will be returned.
     + *
     + * The caller should not free or modify the returned pointer, as it is
     + * owned by the cache.
    -+ */
    -+int git_configset_get_value_multi(struct config_set *cs, const char *key,
    -+				  const struct string_list **dest);
    -+
    -+/**
    -+ * Like git_configset_get_value_multi(), but BUG()s out if the return
    -+ * value is < 0. Use it for keys known to pass git_config_parse_key(),
    -+ * i.e. those hardcoded in the code, and never user-provided keys.
       */
     -const struct string_list *git_configset_get_value_multi(struct config_set *cs, const char *key);
    -+int git_configset_get_knownkey_value_multi(struct config_set *cs,
    -+					   const char *const key,
    -+					   const struct string_list **dest);
    ++RESULT_MUST_BE_USED
    ++int git_configset_get_value_multi(struct config_set *cs, const char *key,
    ++				  const struct string_list **dest);
      
      /**
       * Clears `config_set` structure, removes all saved variable-value pairs.
    @@ config.h: struct repository;
      			  const char *key, const char **value);
     -const struct string_list *repo_config_get_value_multi(struct repository *repo,
     -						      const char *key);
    -+int repo_config_get_value_multi(struct repository *repo,
    -+				const char *key,
    ++RESULT_MUST_BE_USED
    ++int repo_config_get_value_multi(struct repository *repo, const char *key,
     +				const struct string_list **dest);
    -+int repo_config_get_knownkey_value_multi(struct repository *repo,
    -+					 const char *const key,
    -+					 const struct string_list **dest);
      int repo_config_get_string(struct repository *repo,
      			   const char *key, char **dest);
      int repo_config_get_string_tmp(struct repository *repo,
    @@ config.h: int git_config_get_value(const char *key, const char **value);
     + *
     + * The caller should not free or modify the returned pointer, as it is
     + * owned by the cache.
    -+ */
    -+int git_config_get_value_multi(const char *key,
    -+			       const struct string_list **dest);
    -+
    -+/**
    -+ * A wrapper for git_config_get_value_multi() which does for it what
    -+ * git_configset_get_knownkey_value_multi() does for
    -+ * git_configset_get_value_multi().
       */
     -const struct string_list *git_config_get_value_multi(const char *key);
    -+int git_config_get_knownkey_value_multi(const char *const key,
    -+					const struct string_list **dest);
    ++RESULT_MUST_BE_USED
    ++int git_config_get_value_multi(const char *key,
    ++			       const struct string_list **dest);
      
      /**
       * Resets and invalidates the config cache.
    @@ pack-bitmap.c: int bitmap_is_midx(struct bitmap_index *bitmap_git)
     -	return repo_config_get_value_multi(r, "pack.preferbitmaptips");
     +	const struct string_list *dest;
     +
    -+	if (!repo_config_get_knownkey_value_multi(r, "pack.preferbitmaptips",
    -+					       &dest))
    ++	if (!repo_config_get_value_multi(r, "pack.preferbitmaptips", &dest))
     +		return dest;
     +	return NULL;
      }
    @@ submodule.c: int is_tree_submodule_active(struct repository *repo,
      	/* submodule.active is set */
     -	sl = repo_config_get_value_multi(repo, "submodule.active");
     -	if (sl) {
    -+	if (!repo_config_get_knownkey_value_multi(repo, "submodule.active", &sl)) {
    ++	if (!repo_config_get_value_multi(repo, "submodule.active", &sl)) {
      		struct pathspec ps;
      		struct strvec args = STRVEC_INIT;
      		const struct string_list_item *item;
    @@ t/helper/test-config.c: int cmd__config(int argc, const char **argv)
      	} else if (argc == 3 && !strcmp(argv[1], "get_value_multi")) {
     -		strptr = git_config_get_value_multi(argv[2]);
     -		if (strptr) {
    -+		if (!git_config_get_knownkey_value_multi(argv[2], &strptr)) {
    ++		if (!git_config_get_value_multi(argv[2], &strptr)) {
      			for (i = 0; i < strptr->nr; i++) {
      				v = strptr->items[i].string;
      				if (!v)
    @@ t/helper/test-config.c: int cmd__config(int argc, const char **argv)
      		}
     -		strptr = git_configset_get_value_multi(&cs, argv[2]);
     -		if (strptr) {
    -+		if (!git_configset_get_knownkey_value_multi(&cs, argv[2], &strptr)) {
    ++		if (!git_configset_get_value_multi(&cs, argv[2], &strptr)) {
      			for (i = 0; i < strptr->nr; i++) {
      				v = strptr->items[i].string;
      				if (!v)
     
      ## versioncmp.c ##
     @@ versioncmp.c: int versioncmp(const char *s1, const char *s2)
    - 	}
    - 
      	if (!initialized) {
    --		const struct string_list *deprecated_prereleases;
    -+		const struct string_list *deprecated_prereleases = NULL;
    -+
    + 		const char *const newk = "versionsort.suffix";
    + 		const char *const oldk = "versionsort.prereleasesuffix";
    ++		const struct string_list *newl;
    + 		const struct string_list *oldl;
    ++		int new = git_config_get_value_multi(newk, &newl);
    ++		int old = git_config_get_value_multi(oldk, &oldl);
    + 
    +-		prereleases = git_config_get_value_multi(newk);
    +-		oldl = git_config_get_value_multi(oldk);
    +-		if (prereleases && oldl)
    ++		if (!new && !old)
    + 			warning("ignoring %s because %s is set", oldk, newk);
    +-		else if (!prereleases)
    ++		if (!new)
    ++			prereleases = newl;
    ++		else if (!old)
    + 			prereleases = oldl;
    + 
      		initialized = 1;
    --		prereleases = git_config_get_value_multi("versionsort.suffix");
    --		deprecated_prereleases = git_config_get_value_multi("versionsort.prereleasesuffix");
    -+		git_config_get_knownkey_value_multi("versionsort.suffix",
    -+						 &prereleases);
    -+		git_config_get_value_multi("versionsort.prereleasesuffix",
    -+					   &deprecated_prereleases);
    -+
    - 		if (prereleases) {
    - 			if (deprecated_prereleases)
    - 				warning("ignoring versionsort.prereleasesuffix because versionsort.suffix is set");
 4:  40b3cc9b8d4 <  -:  ----------- string-list API: mark "struct_string_list" to "for_each_string_list" const
 5:  b32b2e99aba <  -:  ----------- string-list API: make has_string() and list_lookup() "const"
 7:  c01f7d85c94 !  6:  a0c29d46556 config API: add and use "lookup_value" functions
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    config API: add and use "lookup_value" functions
    +    for-each-repo: error on bad --config
     
    -    Change various users of the config API who only wanted to ask if a
    -    configuration key existed to use a new *_config*_lookup_value() family
    -    of functions. Unlike the existing API functions in the API this one
    -    doesn't take a "dest" argument.
    -
    -    Some of these were using either git_config_get_string() or
    -    git_config_get_string_tmp(), see fe4c750fb13 (submodule--helper: fix a
    -    configure_added_submodule() leak, 2022-09-01) for a recent example. We
    -    can now use a helper function that doesn't require a throwaway
    -    variable.
    -
    -    We could have changed git_configset_get_value_multi() to accept a
    -    "NULL" as a "dest" for all callers, but let's avoid changing the
    -    behavior of existing API users. The new "lookup" API and the older API
    -    call our static "git_configset_get_value_multi_1()" helper with a new
    -    "read_only" argument instead.
    +    As noted in 6c62f015520 (for-each-repo: do nothing on empty config,
    +    2021-01-08) this command wants to ignore a non-existing config key,
    +    but let's not conflate that with bad config.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
    - ## builtin/gc.c ##
    -@@ builtin/gc.c: static int maintenance_register(int argc, const char **argv, const char *prefix)
    - 	};
    - 	int found = 0;
    - 	const char *key = "maintenance.repo";
    --	char *config_value;
    - 	char *maintpath = get_maintpath();
    - 	const struct string_list *list;
    + ## builtin/for-each-repo.c ##
    +@@ builtin/for-each-repo.c: int cmd_for_each_repo(int argc, const char **argv, const char *prefix)
      
    -@@ builtin/gc.c: static int maintenance_register(int argc, const char **argv, const char *prefix)
    - 	git_config_set("maintenance.auto", "false");
    + 	err = repo_config_get_value_multi(the_repository, config_key, &values);
    + 	if (err < 0)
    +-		return 0;
    ++		usage_msg_optf(_("got bad config --config=%s"),
    ++			       for_each_repo_usage, options, config_key);
    + 	else if (err)
    + 		return 0;
      
    - 	/* Set maintenance strategy, if unset */
    --	if (!git_config_get_string("maintenance.strategy", &config_value))
    --		free(config_value);
    --	else
    -+	if (git_config_lookup_value("maintenance.strategy"))
    - 		git_config_set("maintenance.strategy", "incremental");
    - 
    - 	if (!git_config_get_knownkey_value_multi(key, &list))
     
      ## builtin/submodule--helper.c ##
     @@ builtin/submodule--helper.c: static int module_init(int argc, const char **argv, const char *prefix)
    @@ builtin/submodule--helper.c: static int module_init(int argc, const char **argv,
      	};
      	int ret = 1;
     -	const struct string_list *values;
    ++	const struct string_list *unused;
      
      	argc = parse_options(argc, argv, prefix, module_init_options,
      			     git_submodule_helper_usage, 0);
    @@ builtin/submodule--helper.c: static int module_init(int argc, const char **argv,
      	 * by default, only initialize 'active' modules.
      	 */
     -	if (!argc && !git_config_get_value_multi("submodule.active", &values))
    -+	if (!argc && !git_config_lookup_value("submodule.active"))
    ++	if (!argc && !git_config_get_value_multi("submodule.active", &unused))
      		module_list_active(&list);
      
      	info.prefix = prefix;
    @@ builtin/submodule--helper.c: static int module_update(int argc, const char **arg
      		struct module_list list = MODULE_LIST_INIT;
      		struct init_cb info = INIT_CB_INIT;
     -		const struct string_list *values;
    ++		const struct string_list *unused;
      
    - 		if (module_list_compute(argc, argv, opt.prefix,
    + 		if (module_list_compute(argv, opt.prefix,
      					&pathspec2, &list) < 0) {
     @@ builtin/submodule--helper.c: static int module_update(int argc, const char **argv, const char *prefix)
      		 * If there are no path args and submodule.active is set then,
      		 * by default, only initialize 'active' modules.
      		 */
     -		if (!argc && !git_config_get_value_multi("submodule.active", &values))
    -+		if (!argc && !git_config_lookup_value("submodule.active"))
    ++		if (!argc && !git_config_get_value_multi("submodule.active", &unused))
      			module_list_active(&list);
      
      		info.prefix = opt.prefix;
    -@@ builtin/submodule--helper.c: static int config_submodule_in_gitmodules(const char *name, const char *var, con
    - static void configure_added_submodule(struct add_data *add_data)
    - {
    - 	char *key;
    --	const char *val;
    - 	struct child_process add_submod = CHILD_PROCESS_INIT;
    - 	struct child_process add_gitmodules = CHILD_PROCESS_INIT;
    - 
    -@@ builtin/submodule--helper.c: static void configure_added_submodule(struct add_data *add_data)
    - 	 * is_submodule_active(), since that function needs to find
    - 	 * out the value of "submodule.active" again anyway.
    - 	 */
    --	if (!git_config_get_string_tmp("submodule.active", &val)) {
    -+	if (!git_config_lookup_value("submodule.active")) {
    - 		/*
    - 		 * If the submodule being added isn't already covered by the
    - 		 * current configured pathspec, set the submodule's active flag
    -
    - ## builtin/worktree.c ##
    -@@ builtin/worktree.c: static void copy_filtered_worktree_config(const char *worktree_git_dir)
    - 
    - 	if (file_exists(from_file)) {
    - 		struct config_set cs = { { 0 } };
    --		const char *core_worktree;
    - 		int bare;
    - 
    - 		if (safe_create_leading_directories(to_file) ||
    -@@ builtin/worktree.c: static void copy_filtered_worktree_config(const char *worktree_git_dir)
    - 				to_file, "core.bare", NULL, "true", 0))
    - 			error(_("failed to unset '%s' in '%s'"),
    - 				"core.bare", to_file);
    --		if (!git_configset_get_value(&cs, "core.worktree", &core_worktree) &&
    -+		if (!git_configset_lookup_value(&cs, "core.worktree") &&
    - 			git_config_set_in_file_gently(to_file,
    - 							"core.worktree", NULL))
    - 			error(_("failed to unset '%s' in '%s'"),
     
    - ## config.c ##
    -@@ config.c: int git_configset_get_value(struct config_set *cs, const char *key, const char *
    - 
    - static int git_configset_get_value_multi_1(struct config_set *cs, const char *key,
    - 					   const struct string_list **dest,
    --					   int knownkey)
    -+					   int read_only, int knownkey)
    - {
    - 	struct config_set_element *e;
    - 	int ret;
    -@@ config.c: static int git_configset_get_value_multi_1(struct config_set *cs, const char *ke
    - 		return ret;
    - 	else if (!e)
    - 		return 1;
    --	*dest = &e->value_list;
    -+	if (!read_only)
    -+		*dest = &e->value_list;
    - 
    - 	return 0;
    - }
    -@@ config.c: static int git_configset_get_value_multi_1(struct config_set *cs, const char *ke
    - int git_configset_get_value_multi(struct config_set *cs, const char *key,
    - 				  const struct string_list **dest)
    - {
    --	return git_configset_get_value_multi_1(cs, key, dest, 0);
    -+	return git_configset_get_value_multi_1(cs, key, dest, 0, 0);
    - }
    - 
    - int git_configset_get_knownkey_value_multi(struct config_set *cs,
    - 					   const char *const key,
    - 					   const struct string_list **dest)
    - {
    --	return git_configset_get_value_multi_1(cs, key, dest, 1);
    -+	return git_configset_get_value_multi_1(cs, key, dest, 0, 1);
    -+}
    -+
    -+int git_configset_lookup_value(struct config_set *cs, const char *key)
    -+{
    -+	return git_configset_get_value_multi_1(cs, key, NULL, 1, 0);
    - }
    - 
    - int git_configset_get_string(struct config_set *cs, const char *key, char **dest)
    -@@ config.c: void repo_config(struct repository *repo, config_fn_t fn, void *data)
    - 	configset_iter(repo->config, fn, data);
    - }
    - 
    -+int repo_config_lookup_value(struct repository *repo, const char *key)
    -+{
    -+	git_config_check_init(repo);
    -+	return git_configset_get_value_multi_1(repo->config, key, NULL, 1, 0);
    -+}
    -+
    - int repo_config_get_value(struct repository *repo,
    - 			  const char *key, const char **value)
    - {
    -@@ config.c: void git_config_clear(void)
    - 	repo_config_clear(the_repository);
    - }
    - 
    -+int git_config_lookup_value(const char *key)
    -+{
    -+	return repo_config_lookup_value(the_repository, key);
    -+}
    -+
    - int git_config_get_value(const char *key, const char **value)
    - {
    - 	return repo_config_get_value(the_repository, key, value);
    -
    - ## config.h ##
    -@@ config.h: void git_configset_clear(struct config_set *cs);
    -  * is owned by the cache.
    -  */
    - int git_configset_get_value(struct config_set *cs, const char *key, const char **dest);
    -+RESULT_MUST_BE_USED
    -+int git_configset_lookup_value(struct config_set *cs, const char *key);
    - 
    - int git_configset_get_string(struct config_set *cs, const char *key, char **dest);
    - int git_configset_get_int(struct config_set *cs, const char *key, int *dest);
    -@@ config.h: RESULT_MUST_BE_USED
    - int repo_config_get_knownkey_value_multi(struct repository *repo,
    - 					 const char *const key,
    - 					 const struct string_list **dest);
    -+RESULT_MUST_BE_USED
    -+int repo_config_lookup_value(struct repository *repo, const char *key);
    - int repo_config_get_string(struct repository *repo,
    - 			   const char *key, char **dest);
    - int repo_config_get_string_tmp(struct repository *repo,
    -@@ config.h: RESULT_MUST_BE_USED
    - int git_config_get_knownkey_value_multi(const char *const key,
    - 					const struct string_list **dest);
    - 
    -+/**
    -+ * The same as git_config_value(), except without the extra work to
    -+ * return the value to the user, used to check if a value for a key
    -+ * exists.
    -+ */
    -+RESULT_MUST_BE_USED
    -+int git_config_lookup_value(const char *key);
    -+
    - /**
    -  * Resets and invalidates the config cache.
    -  */
    + ## t/t0068-for-each-repo.sh ##
    +@@ t/t0068-for-each-repo.sh: test_expect_success 'do nothing on empty config' '
    + 	git for-each-repo --config=bogus.config -- help --no-such-option
    + '
    + 
    +-test_expect_success 'bad config keys' '
    +-	git for-each-repo --config=a &&
    +-	git for-each-repo --config=a.b. &&
    +-	git for-each-repo --config="'\''.b"
    ++test_expect_success 'error on bad config keys' '
    ++	test_expect_code 129 git for-each-repo --config=a &&
    ++	test_expect_code 129 git for-each-repo --config=a.b. &&
    ++	test_expect_code 129 git for-each-repo --config="'\''.b"
    + '
    + 
    + test_done
 -:  ----------- >  7:  c12805f3d55 config API users: test for *_get_value_multi() segfaults
 9:  bda9d504b89 !  8:  6b76f9eac90 config API: add "string" version of *_value_multi(), fix segfaults
    @@ Commit message
         an empty key in the config syntax yields a "NULL" string, which these
         users would give to strcmp() (or similar), resulting in segfaults.
     
    -    As this change shows, these non-test users of
    -    the *_config_*value_multi() API didn't really want such an an unsafe
    -    and low-level API, let's give them something with the safety of
    -    git_config_get_string() instead.
    +    As this change shows, most users users of the *_config_*value_multi()
    +    API didn't really want such an an unsafe and low-level API, let's give
    +    them something with the safety of git_config_get_string() instead.
     
         This fix is similar to what the *_string() functions and others
    -    acquired in[1] and [2]. Namely introducing and using a
    -    safer *_config_*value_multi_string() variant of the
    -    low-level *_config_*value_multi_string() function.
    +    acquired in[1] and [2]. Namely introducing and using a safer
    +    "*_get_string_multi()" variant of the low-level "_*value_multi()"
    +    function.
     
         This fixes segfaults in code introduced in:
     
    @@ Commit message
           - 92156291ca8 (log: add default decoration filter, 2022-08-05)
           - 50a044f1e40 (gc: replace config subprocesses with API calls, 2022-09-27)
     
    -    There are now two remaining user of the low-level API, one is the
    -    "t/helper/test-config.c" code added in [3]. The other we'll address in
    -    a subsequent commit.
    +    There are now three remaining files using the low-level API:
    +
    +    - Two cases in "builtin/submodule--helper.c", where it's used safely
    +      to see if any config exists.
    +    - One in "builtin/for-each-repo.c", which we'll convert in a
    +      subsequent commit.
    +    - The "t/helper/test-config.c" code added in [3].
     
         As seen in the preceding commit we need to give the
    -    "t/helper/test-config.c" caller these "NULL" entries. We thus cannot
    -    alter the underlying git_configset_get_value_multi_1() function itself
    -    to make it "safe".
    +    "t/helper/test-config.c" caller these "NULL" entries.
    +
    +    We could also alter the underlying git_configset_get_value_multi()
    +    function to be "string safe", but doing so would leave no room for
    +    other variants of "*_get_value_multi()" that coerce to other types.
     
    -    Such a thing would also be undesirable, as casting or forbidding NULL
    -    values might only be one potential use-case of the underlying
    -    function. It's better to have a "raw" low-level function, and
    -    corresponding wrapper functions that coerce its values. The callback
    -    pattern being used here will make it easy to introduce e.g. a "multi"
    -    variant which coerces its values to "bool", "int", "path" etc.
    +    Such coercion can't be built on the string version, since as we've
    +    established "NULL" is a true value in the boolean context, but if we
    +    coerced it to "" for use in a list of strings it'll be subsequently
    +    coerced to "false" as a boolean.
    +
    +    The callback pattern being used here will make it easy to introduce
    +    e.g. a "multi" variant which coerces its values to "bool", "int",
    +    "path" etc.
     
         1. 40ea4ed9032 (Add config_error_nonbool() helper function,
            2008-02-11)
    @@ Commit message
     
      ## builtin/gc.c ##
     @@ builtin/gc.c: static int maintenance_register(int argc, const char **argv, const char *prefix)
    - 	if (git_config_lookup_value("maintenance.strategy"))
    + 	else
      		git_config_set("maintenance.strategy", "incremental");
      
    --	if (!git_config_get_knownkey_value_multi(key, &list))
    -+	if (!git_config_get_knownkey_value_multi_string(key, &list))
    - 		found = unsorted_string_list_has_string(list, maintpath);
    - 
    - 	if (!found) {
    +-	if (!git_config_get_value_multi(key, &list)) {
    ++	if (!git_config_get_string_multi(key, &list)) {
    + 		for_each_string_list_item(item, list) {
    + 			if (!strcmp(maintpath, item->string)) {
    + 				found = 1;
     @@ builtin/gc.c: static int maintenance_unregister(int argc, const char **argv, const char *prefi
      		usage_with_options(builtin_maintenance_unregister_usage,
      				   options);
      
    --	if (!git_config_get_knownkey_value_multi(key, &list))
    -+	if (!git_config_get_knownkey_value_multi_string(key, &list))
    - 		found = unsorted_string_list_has_string(list, maintpath);
    - 
    - 	if (found) {
    +-	if (!git_config_get_value_multi(key, &list)) {
    ++	if (!git_config_get_string_multi(key, &list)) {
    + 		for_each_string_list_item(item, list) {
    + 			if (!strcmp(maintpath, item->string)) {
    + 				found = 1;
     
      ## builtin/log.c ##
     @@ builtin/log.c: static void set_default_decoration_filter(struct decoration_filter *decoration_f
      	struct string_list *include = decoration_filter->include_ref_pattern;
      	const struct string_list *config_exclude;
      
    --	if (!git_config_get_knownkey_value_multi("log.excludeDecoration",
    -+	if (!git_config_get_knownkey_value_multi_string("log.excludeDecoration",
    - 					      &config_exclude)) {
    +-	if (!git_config_get_value_multi("log.excludeDecoration",
    +-					&config_exclude)) {
    ++	if (!git_config_get_string_multi("log.excludeDecoration", &config_exclude)) {
      		struct string_list_item *item;
      		for_each_string_list_item(item, config_exclude)
    + 			string_list_append(decoration_filter->exclude_ref_config_pattern,
     
      ## config.c ##
    -@@ config.c: int git_configset_get_value(struct config_set *cs, const char *key, const char *
    - 
    - static int git_configset_get_value_multi_1(struct config_set *cs, const char *key,
    - 					   const struct string_list **dest,
    --					   int read_only, int knownkey)
    -+					   int read_only, int knownkey,
    -+					   string_list_each_func_t check_fn)
    - {
    - 	struct config_set_element *e;
    - 	int ret;
    -@@ config.c: static int git_configset_get_value_multi_1(struct config_set *cs, const char *ke
    - 		return ret;
    - 	else if (!e)
    - 		return 1;
    -+	if (check_fn &&
    -+	    (ret = for_each_string_list(&e->value_list, check_fn, (void *)key)))
    -+		return ret;
    - 	if (!read_only)
    - 		*dest = &e->value_list;
    - 
    +@@ config.c: int git_configset_get_value_multi(struct config_set *cs, const char *key,
      	return 0;
      }
      
    @@ config.c: static int git_configset_get_value_multi_1(struct config_set *cs, cons
     +	return item->string ? 0 : config_error_nonbool(util);
     +}
     +
    - int git_configset_get_value_multi(struct config_set *cs, const char *key,
    - 				  const struct string_list **dest)
    - {
    --	return git_configset_get_value_multi_1(cs, key, dest, 0, 0);
    -+	return git_configset_get_value_multi_1(cs, key, dest, 0, 0, NULL);
    - }
    - 
    - int git_configset_get_knownkey_value_multi(struct config_set *cs,
    - 					   const char *const key,
    - 					   const struct string_list **dest)
    - {
    --	return git_configset_get_value_multi_1(cs, key, dest, 0, 1);
    -+	return git_configset_get_value_multi_1(cs, key, dest, 0, 1, NULL);
    -+}
    -+
    -+int git_configset_get_value_multi_string(struct config_set *cs, const char *key,
    -+					 const struct string_list **dest)
    ++int git_configset_get_string_multi(struct config_set *cs, const char *key,
    ++				   const struct string_list **dest)
     +{
    -+	return git_configset_get_value_multi_1(cs, key, dest, 0, 0,
    -+					       check_multi_string);
    ++	int ret;
    ++
    ++	if ((ret = git_configset_get_value_multi(cs, key, dest)))
    ++		return ret;
    ++	if ((ret = for_each_string_list((struct string_list *)*dest,
    ++					check_multi_string, (void *)key)))
    ++		return ret;
    ++
    ++	return 0;
     +}
     +
    -+int git_configset_get_knownkey_value_multi_string(struct config_set *cs,
    -+						  const char *const key,
    -+						  const struct string_list **dest)
    -+{
    -+	return git_configset_get_value_multi_1(cs, key, dest, 0, 1,
    -+					       check_multi_string);
    - }
    - 
    - int git_configset_lookup_value(struct config_set *cs, const char *key)
    - {
    --	return git_configset_get_value_multi_1(cs, key, NULL, 1, 0);
    -+	return git_configset_get_value_multi_1(cs, key, NULL, 1, 0, NULL);
    - }
    - 
      int git_configset_get_string(struct config_set *cs, const char *key, char **dest)
    -@@ config.c: void repo_config(struct repository *repo, config_fn_t fn, void *data)
    - int repo_config_lookup_value(struct repository *repo, const char *key)
      {
    - 	git_config_check_init(repo);
    --	return git_configset_get_value_multi_1(repo->config, key, NULL, 1, 0);
    -+	return git_configset_get_value_multi_1(repo->config, key, NULL, 1, 0,
    -+					       NULL);
    - }
    - 
    - int repo_config_get_value(struct repository *repo,
    -@@ config.c: int repo_config_get_knownkey_value_multi(struct repository *repo,
    - 	return git_configset_get_knownkey_value_multi(repo->config, key, dest);
    + 	const char *value;
    +@@ config.c: int repo_config_get_value_multi(struct repository *repo, const char *key,
    + 	return git_configset_get_value_multi(repo->config, key, dest);
      }
      
    -+int repo_config_get_value_multi_string(struct repository *repo,
    -+				       const char *key,
    -+				       const struct string_list **dest)
    -+{
    -+	git_config_check_init(repo);
    -+	return git_configset_get_value_multi_string(repo->config, key, dest);
    -+}
    -+
    -+int repo_config_get_knownkey_value_multi_string(struct repository *repo,
    -+						const char *key,
    -+						const struct string_list **dest)
    ++int repo_config_get_string_multi(struct repository *repo, const char *key,
    ++				 const struct string_list **dest)
     +{
     +	git_config_check_init(repo);
    -+	return git_configset_get_knownkey_value_multi_string(repo->config, key, dest);
    ++	return git_configset_get_string_multi(repo->config, key, dest);
     +}
     +
      int repo_config_get_string(struct repository *repo,
      			   const char *key, char **dest)
      {
    -@@ config.c: int git_config_get_knownkey_value_multi(const char *const key,
    - 	return repo_config_get_knownkey_value_multi(the_repository, key, dest);
    +@@ config.c: int git_config_get_value_multi(const char *key, const struct string_list **dest)
    + 	return repo_config_get_value_multi(the_repository, key, dest);
      }
      
    -+int git_config_get_value_multi_string(const char *key,
    -+				      const struct string_list **dest)
    -+{
    -+	return repo_config_get_value_multi_string(the_repository, key, dest);
    -+}
    -+
    -+int git_config_get_knownkey_value_multi_string(const char *key,
    -+					       const struct string_list **dest)
    ++int git_config_get_string_multi(const char *key,
    ++				const struct string_list **dest)
     +{
    -+	return repo_config_get_knownkey_value_multi_string(the_repository, key, dest);
    ++	return repo_config_get_string_multi(the_repository, key, dest);
     +}
     +
      int git_config_get_string(const char *key, char **dest)
      {
      	return repo_config_get_string(the_repository, key, dest);
    +@@ config.c: void git_die_config(const char *key, const char *err, ...)
    + 		va_end(params);
    + 	}
    + 	if (git_config_get_value_multi(key, &values))
    +-		BUG("for key '%s' we must have a value to report on", key);
    ++		BUG("key '%s' does not exist, should not be given to git_die_config()",
    ++		    key);
    + 	kv_info = values->items[values->nr - 1].util;
    + 	git_die_config_linenr(key, kv_info->filename, kv_info->linenr);
    + }
     
      ## config.h ##
    -@@ config.h: int git_configset_get_knownkey_value_multi(struct config_set *cs,
    - 					   const char *const key,
    - 					   const struct string_list **dest);
    +@@ config.h: RESULT_MUST_BE_USED
    + int git_configset_get_value_multi(struct config_set *cs, const char *key,
    + 				  const struct string_list **dest);
      
     +/**
     + * A validation wrapper for git_configset_get_value_multi() which does
    @@ config.h: int git_configset_get_knownkey_value_multi(struct config_set *cs,
     + * "[section] key =" which is the empty string. Most users of the API
     + * are not prepared to handle NULL in a "struct string_list".
     + */
    -+int git_configset_get_value_multi_string(struct config_set *cs, const char *key,
    -+					 const struct string_list **dest);
    -+
    -+/**
    -+ * A wrapper for git_configset_get_value_multi_string() which does for
    -+ * it what git_configset_get_knownkey_value_multi() does for
    -+ * git_configset_get_value_multi().
    -+ */
    -+RESULT_MUST_BE_USED
    -+int git_configset_get_knownkey_value_multi_string(struct config_set *cs,
    -+						  const char *const key,
    -+						  const struct string_list **dest);
    -+
    ++int git_configset_get_string_multi(struct config_set *cs, const char *key,
    ++				   const struct string_list **dest);
     +
      /**
       * Clears `config_set` structure, removes all saved variable-value pairs.
       */
    -@@ config.h: int repo_config_get_knownkey_value_multi(struct repository *repo,
    - 					 const char *const key,
    - 					 const struct string_list **dest);
    +@@ config.h: int repo_config_get_value(struct repository *repo,
      RESULT_MUST_BE_USED
    -+int repo_config_get_value_multi_string(struct repository *repo,
    -+				       const char *key,
    -+				       const struct string_list **dest);
    + int repo_config_get_value_multi(struct repository *repo, const char *key,
    + 				const struct string_list **dest);
     +RESULT_MUST_BE_USED
    -+int repo_config_get_knownkey_value_multi_string(struct repository *repo,
    -+						const char *const key,
    -+						const struct string_list **dest);
    -+RESULT_MUST_BE_USED
    - int repo_config_lookup_value(struct repository *repo, const char *key);
    ++int repo_config_get_string_multi(struct repository *repo, const char *key,
    ++				 const struct string_list **dest);
      int repo_config_get_string(struct repository *repo,
      			   const char *key, char **dest);
    -@@ config.h: RESULT_MUST_BE_USED
    - int git_config_get_knownkey_value_multi(const char *const key,
    - 					const struct string_list **dest);
    - 
    -+RESULT_MUST_BE_USED
    -+int git_config_get_value_multi_string(const char *key,
    -+				      const struct string_list **dest);
    -+
    + int repo_config_get_string_tmp(struct repository *repo,
    +@@ config.h: int git_config_get_value(const char *key, const char **value);
    + RESULT_MUST_BE_USED
    + int git_config_get_value_multi(const char *key,
    + 			       const struct string_list **dest);
     +RESULT_MUST_BE_USED
    -+int git_config_get_knownkey_value_multi_string(const char *const key,
    -+					       const struct string_list **dest);
    -+
    ++int git_config_get_string_multi(const char *key,
    ++				const struct string_list **dest);
    + 
      /**
    -  * The same as git_config_value(), except without the extra work to
    -  * return the value to the user, used to check if a value for a key
    +  * Resets and invalidates the config cache.
     
      ## pack-bitmap.c ##
     @@ pack-bitmap.c: const struct string_list *bitmap_preferred_tips(struct repository *r)
      {
      	const struct string_list *dest;
      
    --	if (!repo_config_get_knownkey_value_multi(r, "pack.preferbitmaptips",
    -+	if (!repo_config_get_knownkey_value_multi_string(r, "pack.preferbitmaptips",
    - 					       &dest))
    +-	if (!repo_config_get_value_multi(r, "pack.preferbitmaptips", &dest))
    ++	if (!repo_config_get_string_multi(r, "pack.preferbitmaptips", &dest))
      		return dest;
      	return NULL;
    + }
     
      ## submodule.c ##
     @@ submodule.c: int is_tree_submodule_active(struct repository *repo,
      	free(key);
      
      	/* submodule.active is set */
    --	if (!repo_config_get_knownkey_value_multi(repo, "submodule.active", &sl)) {
    -+	if (!repo_config_get_knownkey_value_multi_string(repo, "submodule.active", &sl)) {
    +-	if (!repo_config_get_value_multi(repo, "submodule.active", &sl)) {
    ++	if (!repo_config_get_string_multi(repo, "submodule.active", &sl)) {
      		struct pathspec ps;
      		struct strvec args = STRVEC_INIT;
      		const struct string_list_item *item;
    @@ t/t4202-log.sh: test_expect_success 'log.decorate configuration' '
      
      '
      
    +-test_expect_failure 'parse log.excludeDecoration with no value' '
     +test_expect_success 'parse log.excludeDecoration with no value' '
    -+	cp .git/config .git/config.orig &&
    -+	test_when_finished mv .git/config.orig .git/config &&
    -+
    -+	cat >>.git/config <<-\EOF &&
    -+	[log]
    -+		excludeDecoration
    -+	EOF
    + 	cp .git/config .git/config.orig &&
    + 	test_when_finished mv .git/config.orig .git/config &&
    + 
    +@@ t/t4202-log.sh: test_expect_failure 'parse log.excludeDecoration with no value' '
    + 	[log]
    + 		excludeDecoration
    + 	EOF
    +-	git log --decorate=short
     +	cat >expect <<-\EOF &&
     +	error: missing value for '\''log.excludeDecoration'\''
     +	EOF
     +	git log --decorate=short 2>actual &&
     +	test_cmp expect actual
    -+'
    -+
    + '
    + 
      test_expect_success 'decorate-refs with glob' '
    - 	cat >expect.decorate <<-\EOF &&
    - 	Merge-tag-reach
     
      ## t/t5310-pack-bitmaps.sh ##
     @@ t/t5310-pack-bitmaps.sh: test_bitmap_cases () {
      		)
      	'
      
    +-	test_expect_failure 'pack.preferBitmapTips' '
     +	test_expect_success 'pack.preferBitmapTips' '
    -+		git init repo &&
    -+		test_when_finished "rm -rf repo" &&
    -+		(
    -+			cd repo &&
    -+			git config pack.writeBitmapLookupTable '"$writeLookupTable"' &&
    -+			test_commit_bulk --message="%s" 103 &&
    -+
    -+			cat >>.git/config <<-\EOF &&
    -+			[pack]
    -+				preferBitmapTips
    -+			EOF
    + 		git init repo &&
    + 		test_when_finished "rm -rf repo" &&
    + 		(
    +@@ t/t5310-pack-bitmaps.sh: test_bitmap_cases () {
    + 			[pack]
    + 				preferBitmapTips
    + 			EOF
    +-			git repack -adb
     +
     +			cat >expect <<-\EOF &&
     +			error: missing value for '\''pack.preferbitmaptips'\''
     +			EOF
     +			git repack -adb 2>actual &&
     +			test_cmp expect actual
    -+		)
    -+	'
    -+
    - 	test_expect_success 'complains about multiple pack bitmaps' '
    - 		rm -fr repo &&
    - 		git init repo &&
    + 		)
    + 	'
    + 
     
      ## t/t7004-tag.sh ##
     @@ t/t7004-tag.sh: test_expect_success 'invalid sort parameter in configuratoin' '
      	test_must_fail git tag -l "foo*"
      '
      
    +-test_expect_failure 'version sort handles empty value for versionsort.{prereleaseSuffix,suffix}' '
     +test_expect_success 'version sort handles empty value for versionsort.{prereleaseSuffix,suffix}' '
    -+	cp .git/config .git/config.orig &&
    -+	test_when_finished mv .git/config.orig .git/config &&
    -+
    -+	cat >>.git/config <<-\EOF &&
    -+	[versionsort]
    -+		prereleaseSuffix
    -+		suffix
    -+	EOF
    + 	cp .git/config .git/config.orig &&
    + 	test_when_finished mv .git/config.orig .git/config &&
    + 
    +@@ t/t7004-tag.sh: test_expect_failure 'version sort handles empty value for versionsort.{prereleas
    + 		prereleaseSuffix
    + 		suffix
    + 	EOF
    +-	git tag -l --sort=version:refname
     +	cat >expect <<-\EOF &&
     +	error: missing value for '\''versionsort.suffix'\''
     +	error: missing value for '\''versionsort.prereleasesuffix'\''
     +	EOF
     +	git tag -l --sort=version:refname 2>actual &&
     +	test_cmp expect actual
    -+'
    -+
    + '
    + 
      test_expect_success 'version sort with prerelease reordering' '
    - 	test_config versionsort.prereleaseSuffix -rc &&
    - 	git tag foo1.6-rc1 &&
     
      ## t/t7413-submodule-is-active.sh ##
     @@ t/t7413-submodule-is-active.sh: test_expect_success 'is-active works with submodule.<name>.active config' '
      	test-tool -C super submodule is-active sub1
      '
      
    +-test_expect_failure 'is-active handles submodule.active config missing a value' '
     +test_expect_success 'is-active handles submodule.active config missing a value' '
    -+	cp super/.git/config super/.git/config.orig &&
    -+	test_when_finished mv super/.git/config.orig super/.git/config &&
    -+
    -+	cat >>super/.git/config <<-\EOF &&
    -+	[submodule]
    -+		active
    -+	EOF
    -+
    + 	cp super/.git/config super/.git/config.orig &&
    + 	test_when_finished mv super/.git/config.orig super/.git/config &&
    + 
    +@@ t/t7413-submodule-is-active.sh: test_expect_failure 'is-active handles submodule.active config missing a value'
    + 		active
    + 	EOF
    + 
    +-	test-tool -C super submodule is-active sub1
     +	cat >expect <<-\EOF &&
     +	error: missing value for '\''submodule.active'\''
     +	EOF
     +	test-tool -C super submodule is-active sub1 2>actual &&
     +	test_cmp expect actual
    -+'
    -+
    + '
    + 
      test_expect_success 'is-active works with basic submodule.active config' '
    - 	test_when_finished "git -C super config submodule.sub1.URL ../sub" &&
    - 	test_when_finished "git -C super config --unset-all submodule.active" &&
     
      ## t/t7900-maintenance.sh ##
     @@ t/t7900-maintenance.sh: test_expect_success 'register and unregister' '
      	git maintenance unregister --force
      '
      
    +-test_expect_failure 'register with no value for maintenance.repo' '
     +test_expect_success 'register with no value for maintenance.repo' '
    -+	cp .git/config .git/config.orig &&
    -+	test_when_finished mv .git/config.orig .git/config &&
    -+
    -+	cat >>.git/config <<-\EOF &&
    -+	[maintenance]
    -+		repo
    -+	EOF
    + 	cp .git/config .git/config.orig &&
    + 	test_when_finished mv .git/config.orig .git/config &&
    + 
    +@@ t/t7900-maintenance.sh: test_expect_failure 'register with no value for maintenance.repo' '
    + 	[maintenance]
    + 		repo
    + 	EOF
    +-	git maintenance register
     +	cat >expect <<-\EOF &&
     +	error: missing value for '\''maintenance.repo'\''
     +	EOF
     +	git maintenance register 2>actual &&
     +	test_cmp expect actual &&
     +	git config maintenance.repo
    -+'
    -+
    + '
    + 
    +-test_expect_failure 'unregister with no value for maintenance.repo' '
     +test_expect_success 'unregister with no value for maintenance.repo' '
    -+	cp .git/config .git/config.orig &&
    -+	test_when_finished mv .git/config.orig .git/config &&
    -+
    -+	cat >>.git/config <<-\EOF &&
    -+	[maintenance]
    -+		repo
    -+	EOF
    -+	cat >expect <<-\EOF &&
    -+	error: missing value for '\''maintenance.repo'\''
    -+	EOF
    + 	cp .git/config .git/config.orig &&
    + 	test_when_finished mv .git/config.orig .git/config &&
    + 
    +@@ t/t7900-maintenance.sh: test_expect_failure 'unregister with no value for maintenance.repo' '
    + 	cat >expect <<-\EOF &&
    + 	error: missing value for '\''maintenance.repo'\''
    + 	EOF
    +-	git maintenance unregister &&
    +-	git maintenance unregister --force
     +	test_expect_code 128 git maintenance unregister 2>actual.raw &&
     +	grep ^error actual.raw >actual &&
     +	test_cmp expect actual &&
    @@ t/t7900-maintenance.sh: test_expect_success 'register and unregister' '
     +	grep ^error actual.raw >actual &&
     +	test_cmp expect actual &&
     +	git config maintenance.repo
    -+'
    -+
    + '
    + 
      test_expect_success !MINGW 'register and unregister with regex metacharacters' '
    - 	META="a+b*c" &&
    - 	git init "$META" &&
     
      ## versioncmp.c ##
     @@ versioncmp.c: int versioncmp(const char *s1, const char *s2)
    + 		const char *const oldk = "versionsort.prereleasesuffix";
    + 		const struct string_list *newl;
    + 		const struct string_list *oldl;
    +-		int new = git_config_get_value_multi(newk, &newl);
    +-		int old = git_config_get_value_multi(oldk, &oldl);
    ++		int new = git_config_get_string_multi(newk, &newl);
    ++		int old = git_config_get_string_multi(oldk, &oldl);
      
    - 		initialized = 1;
    - 		prereleases_ret =
    --			git_config_get_knownkey_value_multi("versionsort.suffix",
    --							    &prereleases);
    -+			git_config_get_knownkey_value_multi_string("versionsort.suffix",
    -+								   &prereleases);
    - 		deprecated_prereleases_ret =
    --			git_config_get_knownkey_value_multi("versionsort.prereleasesuffix",
    --							    &deprecated_prereleases);
    -+			git_config_get_knownkey_value_multi_string("versionsort.prereleasesuffix",
    -+								   &deprecated_prereleases);
    - 
    - 		if (!prereleases_ret) {
    - 			if (!deprecated_prereleases_ret)
    + 		if (!new && !old)
    + 			warning("ignoring %s because %s is set", oldk, newk);
10:  b59cbed8f61 !  9:  e2f8f7c52e3 for-each-repo: with bad config, don't conflate <path> and <cmd>
    @@ Commit message
         running commands.
     
         As noted in the preceding commit the fix is to move to a safer
    -    "*_multi_string()" version of the *__multi() API. This change is
    +    "*_string_multi()" version of the *_multi() API. This change is
         separated from the rest because those all segfaulted. In this change
         we ended up with different behavior.
     
    @@ builtin/for-each-repo.c: int cmd_for_each_repo(int argc, const char **argv, cons
      		die(_("missing --config=<config>"));
      
     -	err = repo_config_get_value_multi(the_repository, config_key, &values);
    -+	err = repo_config_get_value_multi_string(the_repository, config_key, &values);
    ++	err = repo_config_get_string_multi(the_repository, config_key, &values);
      	if (err < 0)
      		usage_msg_optf(_("got bad config --config=%s"),
      			       for_each_repo_usage, options, config_key);
-- 
2.38.0.1280.g8136eb6fab2

