From f718ac37e7b817faed3d733d706eb613f61215b9 Mon Sep 17 00:00:00 2001
Message-Id: <cover-v8-00.12-00000000000-20220118T155150Z-avarab@gmail.com>
In-Reply-To: <cover-v7-00.10-00000000000-20211228T004707Z-avarab@gmail.com>
References: <cover-v7-00.10-00000000000-20211228T004707Z-avarab@gmail.com>
From: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
Date: Tue, 18 Jan 2022 16:51:50 +0100
Subject: [PATCH v8 00/12] *** SUBJECT HERE ***
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

*** BLURB HERE ***

Ævar Arnfjörð Bjarmason (12):
  grep.h: make patmatch() a public function
  pickaxe: use PCREv2 for -G and -S
  Remove unused kwset.[ch]
  diffcore-pickaxe: add --pickaxe-patch for use with -G
  wip reg_newline etc. test
  only compile pattern once: TODO, free it
  Revert "wip reg_newline etc. test"
  free stuff, is the objfind a bug?
  better?
  fixup earlier, ./t7810-grep.sh (and maybe ./t4014-format-patch.sh?)
    fails without this
  remove ad-hoc debug
  fixup for being on top of avar/drop-grep-prefix-length now

 Documentation/diff-options.txt                |  17 +
 Makefile                                      |   3 -
 compat/obstack.c                              | 413 ----------
 compat/obstack.h                              | 511 ------------
 ctype.c                                       |  36 -
 diff.c                                        |  13 +
 diff.h                                        |  27 +-
 diffcore-pickaxe.c                            | 161 ++--
 git-compat-util.h                             |   3 -
 grep.c                                        |   6 +-
 grep.h                                        |   3 +
 kwset.c                                       | 775 ------------------
 kwset.h                                       |  65 --
 t/t4013-diff-various.sh                       |   3 +-
 ...-s_--pickaxe-patch_--pretty=oneline_master |   3 +
 ...-s_--pickaxe-patch_--pretty=oneline_master |   4 +
 t/t4209-log-pickaxe.sh                        |  50 ++
 17 files changed, 183 insertions(+), 1910 deletions(-)
 delete mode 100644 compat/obstack.c
 delete mode 100644 compat/obstack.h
 delete mode 100644 kwset.c
 delete mode 100644 kwset.h
 create mode 100644 t/t4013/diff.log_-GD_-U0_-s_--pickaxe-patch_--pretty=oneline_master
 create mode 100644 t/t4013/diff.log_-GD_-U1_-s_--pickaxe-patch_--pretty=oneline_master

Range-diff against v7:
 1:  b62e6b6162a <  -:  ----------- grep.h: remove unused "regex_t regexp" from grep_opt
10:  b764c09d2b7 !  1:  ec13470c081 grep.[ch]: remove GREP_PATTERN_TYPE_UNSPECIFIED
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    grep.[ch]: remove GREP_PATTERN_TYPE_UNSPECIFIED
    +    grep.h: make patmatch() a public function
     
    -    Remove the need for "GREP_PATTERN_TYPE_UNSPECIFIED" in favor of having
    -    the users of the "pattern_type_option" member check whether that
    -    member is set or not.
    +    I'd like to use the PCRE & ERE etc. code in grep.c for more things in
    +    git, starting with diffcore-pickaxe.c.
     
    -    The "UNSPECIFIED" case was already handled implicitly in
    -    compile_regexp(), and we don't use this "enum" in a "switch"
    -    statement, so let's not explicitly name the
    -    "GREP_PATTERN_TYPE_UNSPECIFIED = 0" case. It is still important that
    -    "GREP_PATTERN_TYPE_BRE != 0", as can be seen in failing tests if the
    -    parsing for "basic" in parse_pattern_type_arg() is made to "return 0".
    +    The current API just exposes grep_{source,buffer}() for that
    +    purpose. I could use those, but they're very fat entry points into the
    +    entire set of bells and whistles that grep.c supports for "git
    +    grep". I just want the equivalent of a light regexec() wrapper for my
    +    compiled patterns.
    +
    +    So let's expose patmatch() for that purpose. It's not perfect, in
    +    particular it's a bit ugly that we need to pop a pattern off the
    +    opt->pattern_list if all we've got is the "grep_opt" wrapper struct,
    +    but it'll do for now.
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## grep.c ##
    -@@ grep.c: static const char *color_grep_slots[] = {
    - static int parse_pattern_type_arg(const char *opt, const char *arg)
    - {
    - 	if (!strcmp(arg, "default"))
    --		return GREP_PATTERN_TYPE_UNSPECIFIED;
    -+		return 0;
    - 	else if (!strcmp(arg, "basic"))
    - 		return GREP_PATTERN_TYPE_BRE;
    - 	else if (!strcmp(arg, "extended"))
    -@@ grep.c: define_list_config_array_extra(color_grep_slots, {"match"});
    - 
    - static void adjust_pattern_type(enum grep_pattern_type *pto, const int ero)
    - {
    --	if (*pto == GREP_PATTERN_TYPE_UNSPECIFIED)
    --		*pto = ero ? GREP_PATTERN_TYPE_ERE : GREP_PATTERN_TYPE_BRE;
    -+	*pto = ero ? GREP_PATTERN_TYPE_ERE : GREP_PATTERN_TYPE_BRE;
    +@@ grep.c: static void show_name(struct grep_opt *opt, const char *name)
    + 	opt->output(opt, opt->null_following_name ? "\0" : "\n", 1);
      }
      
    - /*
    -@@ grep.c: int grep_config(const char *var, const char *value, void *cb)
    - 
    - 	if (!strcmp(var, "grep.extendedregexp")) {
    - 		ero = git_config_bool(var, value);
    -+		if (opt->pattern_type_option)
    -+			return 0;
    - 		adjust_pattern_type(&opt->pattern_type_option, ero);
    - 		return 0;
    - 	}
    +-static int patmatch(struct grep_pat *p,
    +-		    const char *line, const char *eol,
    +-		    regmatch_t *match, int eflags)
    ++int patmatch(struct grep_pat *p,
    ++	     const char *line, const char *eol,
    ++	     regmatch_t *match, int eflags)
    + {
    + 	int hit;
      
    - 	if (!strcmp(var, "grep.patterntype")) {
    - 		opt->pattern_type_option = parse_pattern_type_arg(var, value);
    -+		if (opt->pattern_type_option)
    -+			return 0;
    - 		if (ero == -1)
    - 			return 0;
    - 		adjust_pattern_type(&opt->pattern_type_option, ero);
     
      ## grep.h ##
    -@@ grep.h: enum grep_expr_node {
    - };
    +@@ grep.h: void grep_source_load_driver(struct grep_source *gs,
    + 
    + 
    + int grep_source(struct grep_opt *opt, struct grep_source *gs);
    ++int patmatch(struct grep_pat *p,
    ++	     const char *line, const char *eol,
    ++	     regmatch_t *match, int eflags);
    + 
    + struct grep_opt *grep_opt_dup(const struct grep_opt *opt);
      
    - enum grep_pattern_type {
    --	GREP_PATTERN_TYPE_UNSPECIFIED = 0,
    --	GREP_PATTERN_TYPE_BRE,
    -+	GREP_PATTERN_TYPE_BRE = 1,
    - 	GREP_PATTERN_TYPE_ERE,
    - 	GREP_PATTERN_TYPE_FIXED,
    - 	GREP_PATTERN_TYPE_PCRE
    -@@ grep.h: struct grep_opt {
    - 	.relative = 1, \
    - 	.pathname = 1, \
    - 	.max_depth = -1, \
    --	.pattern_type_option = GREP_PATTERN_TYPE_UNSPECIFIED, \
    - 	.colors = { \
    - 		[GREP_COLOR_CONTEXT] = "", \
    - 		[GREP_COLOR_FILENAME] = "", \
 9:  c6ca39b4554 !  2:  ff9accc3985 grep: simplify config parsing and option parsing
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    grep: simplify config parsing and option parsing
    +    pickaxe: use PCREv2 for -G and -S
     
    -    Simplify the parsing of "grep.patternType" and
    -    "grep.extendedRegexp". This changes no behavior, but gets rid of
    -    complex parsing logic that isn't needed anymore.
    +    Follow-up b65abcafc7a (grep: use PCRE v2 for optimized fixed-string
    +    search, 2019-07-01) and remove the use of kwset in the pickaxe code
    +    for fixed-string search, in favor of optimistically using PCRE v2.
     
    -    When "grep.patternType" was introduced in 84befcd0a4a (grep: add a
    -    grep.patternType configuration setting, 2012-08-03) we promised that:
    +    This does mean that the semantics of the -G option subtly change,
    +    before it's an ERE, whereas now it'll be a PCRE if we're compiled with
    +    PCRE. Since PCRE is almost entirely a strict superset of ERE syntax I
    +    think this is OK.
     
    -     1. You can set "grep.patternType", and "[setting it to] 'default'
    -        will return to the default matching behavior".
    +    Now when running the newly added t/perf/p4209-pickaxe.sh[1] and the
    +    latest PCRE v2 we'll get the following performance improvements (well,
    +    mostly improvements):
     
    -        In that context "the default" meant whatever the configuration
    -        system specified before that change, i.e. via grep.extendedRegexp.
    +        Test                                                                           origin/next       HEAD
    +        -----------------------------------------------------------------------------------------------------------------------
    +        4209.1: git log -S'a' <limit-rev>..                                            0.34(0.31+0.03)   0.40(0.35+0.05) +17.6%
    +        4209.2: git log -S'uncommon' <limit-rev>..                                     0.34(0.31+0.02)   0.34(0.31+0.03) +0.0%
    +        4209.3: git log -S'ö' <limit-rev>..                                            0.46(0.41+0.04)   0.30(0.25+0.04) -34.8%
    +        4209.4: git log --pickaxe-regex -S'[þæö]' <limit-rev>..                        0.36(0.32+0.04)   0.45(0.41+0.03) +25.0%
    +        4209.5: git log -G'a' <limit-rev>..                                            0.57(0.53+0.04)   0.48(0.43+0.05) -15.8%
    +        4209.6: git log --pickaxe-regex -S'a' <limit-rev>..                            0.62(0.55+0.07)   0.41(0.36+0.05) -33.9%
    +        4209.7: git log --text -G'a' <limit-rev>..                                     0.57(0.52+0.04)   0.49(0.43+0.05) -14.0%
    +        4209.8: git log --text --pickaxe-all -G'a' <limit-rev>..                       0.41(0.37+0.04)   0.36(0.32+0.04) -12.2%
    +        4209.9: git log --pickaxe-all -G'a' <limit-rev>..                              0.42(0.35+0.07)   0.36(0.31+0.05) -14.3%
    +        4209.10: git log --pickaxe-all --pickaxe-regex -S'a' <limit-rev>..             0.50(0.47+0.03)   0.34(0.29+0.04) -32.0%
    +        4209.11: git log -G'uncommon' <limit-rev>..                                    0.58(0.52+0.06)   0.49(0.41+0.08) -15.5%
    +        4209.12: git log --pickaxe-regex -S'uncommon' <limit-rev>..                    0.42(0.37+0.04)   0.34(0.30+0.03) -19.0%
    +        4209.13: git log --text -G'uncommon' <limit-rev>..                             0.58(0.51+0.06)   0.49(0.43+0.05) -15.5%
    +        4209.14: git log --text --pickaxe-all -G'uncommon' <limit-rev>..               0.58(0.52+0.05)   0.48(0.44+0.04) -17.2%
    +        4209.15: git log --pickaxe-all -G'uncommon' <limit-rev>..                      0.58(0.53+0.05)   0.50(0.45+0.04) -13.8%
    +        4209.16: git log --pickaxe-all --pickaxe-regex -S'uncommon' <limit-rev>..      0.41(0.37+0.04)   0.34(0.30+0.04) -17.1%
    +        4209.17: git log -G'[þæö]' <limit-rev>..                                       0.57(0.51+0.06)   0.49(0.46+0.03) -14.0%
    +        4209.18: git log --pickaxe-regex -S'[þæö]' <limit-rev>..                       0.36(0.32+0.04)   0.45(0.41+0.04) +25.0%
    +        4209.19: git log --text -G'[þæö]' <limit-rev>..                                0.58(0.52+0.05)   0.48(0.45+0.04) -17.2%
    +        4209.20: git log --text --pickaxe-all -G'[þæö]' <limit-rev>..                  0.57(0.52+0.04)   0.48(0.42+0.06) -15.8%
    +        4209.21: git log --pickaxe-all -G'[þæö]' <limit-rev>..                         0.59(0.52+0.05)   0.51(0.46+0.05) -13.6%
    +        4209.22: git log --pickaxe-all --pickaxe-regex -S'[þæö]' <limit-rev>..         0.36(0.33+0.02)   0.46(0.41+0.04) +27.8%
    +        4209.23: git log -i -S'a' <limit-rev>..                                        0.71(0.67+0.03)   0.42(0.38+0.03) -40.8%
    +        4209.24: git log -i -S'uncommon' <limit-rev>..                                 0.34(0.30+0.04)   0.34(0.31+0.03) +0.0%
    +        4209.25: git log -i -S'ö' <limit-rev>..                                        0.35(0.33+0.01)   0.30(0.25+0.05) -14.3%
    +        4209.26: git log -i --pickaxe-regex -S'[þæö]' <limit-rev>..                    0.36(0.34+0.02)   0.46(0.42+0.03) +27.8%
    +        4209.27: git log -i -G'a' <limit-rev>..                                        0.57(0.51+0.05)   0.49(0.45+0.04) -14.0%
    +        4209.28: git log -i --pickaxe-regex -S'a' <limit-rev>..                        0.77(0.67+0.04)   0.41(0.35+0.06) -46.8%
    +        4209.29: git log -i --text -G'a' <limit-rev>..                                 0.57(0.50+0.06)   0.48(0.43+0.05) -15.8%
    +        4209.30: git log -i --text --pickaxe-all -G'a' <limit-rev>..                   0.41(0.36+0.04)   0.36(0.32+0.04) -12.2%
    +        4209.31: git log -i --pickaxe-all -G'a' <limit-rev>..                          0.41(0.36+0.05)   0.36(0.30+0.06) -12.2%
    +        4209.32: git log -i --pickaxe-all --pickaxe-regex -S'a' <limit-rev>..          0.56(0.54+0.02)   0.34(0.31+0.03) -39.3%
    +        4209.33: git log -i -G'uncommon' <limit-rev>..                                 0.59(0.53+0.05)   0.52(0.44+0.05) -11.9%
    +        4209.34: git log -i --pickaxe-regex -S'uncommon' <limit-rev>..                 0.44(0.39+0.05)   0.34(0.30+0.04) -22.7%
    +        4209.35: git log -i --text -G'uncommon' <limit-rev>..                          0.58(0.53+0.05)   0.49(0.43+0.05) -15.5%
    +        4209.36: git log -i --text --pickaxe-all -G'uncommon' <limit-rev>..            0.58(0.52+0.06)   0.49(0.45+0.02) -15.5%
    +        4209.37: git log -i --pickaxe-all -G'uncommon' <limit-rev>..                   0.59(0.54+0.04)   0.49(0.45+0.04) -16.9%
    +        4209.38: git log -i --pickaxe-all --pickaxe-regex -S'uncommon' <limit-rev>..   0.44(0.40+0.03)   0.35(0.30+0.04) -20.5%
    +        4209.39: git log -i -G'[þæö]' <limit-rev>..                                    0.57(0.51+0.06)   0.49(0.44+0.04) -14.0%
    +        4209.40: git log -i --pickaxe-regex -S'[þæö]' <limit-rev>..                    0.37(0.33+0.03)   0.46(0.40+0.06) +24.3%
    +        4209.41: git log -i --text -G'[þæö]' <limit-rev>..                             0.57(0.51+0.06)   0.48(0.43+0.05) -15.8%
    +        4209.42: git log -i --text --pickaxe-all -G'[þæö]' <limit-rev>..               0.57(0.53+0.04)   0.48(0.43+0.05) -15.8%
    +        4209.43: git log -i --pickaxe-all -G'[þæö]' <limit-rev>..                      0.58(0.50+0.07)   0.49(0.42+0.07) -15.5%
    +        4209.44: git log -i --pickaxe-all --pickaxe-regex -S'[þæö]' <limit-rev>..      0.37(0.34+0.03)   0.45(0.42+0.03) +21.6%
     
    -     2. We'd support the existing "grep.extendedRegexp" option, but ignore
    -        it when the new "grep.patternType" option is set. We said we'd
    -        only ignore the older "grep.extendedRegexp" option "when the
    -        `grep.patternType` option is set. to a value other than
    -        'default'".
    +    1. With these options:
     
    -    In a preceding commit we changed grep_config() to be called after
    -    grep_init(), which means that much of the complexity here can go
    -    away.
    -
    -    As before both "grep.patternType" and "grep.extendedRegexp" are
    -    last-one-wins variable, with "grep.extendedRegexp" yielding to
    -    "grep.patternType", except when "grep.patternType=default".
    -
    -    Note that this applies as we parse the config, i.e. a sequence of:
    -
    -        -c grep.patternType=perl
    -        -c grep.extendedRegexp=true \
    -        -c grep.patternType=default
    -
    -    Should select ERE due to "grep.extendedRegexp=true and
    -    grep.extendedRegexp=default", not BRE, even though that's the
    -    "default" patternType. We can determine this as we parse the config,
    -    because:
    -
    -     * If we see "grep.extendedRegexp" we set the internal "ero" to its
    -       boolean value.
    -
    -     * If we see "grep.extendedRegexp" but
    -       "grep.patternType=[default|<unset>]" is in effect we *don't* set
    -       the internal "pattern_type_option" to update the pattern type.
    -
    -     * If we see "grep.patternType!=default" we can set our internal
    -       "pattern_type_option" directly, it doesn't matter what the state of
    -       "grep.extendedRegexp" is, but we don't forget what it was, in case
    -       we see a "grep.patternType=default" again.
    -
    -     * If we see a "grep.patternType=default" we can set the pattern to
    -       ERE or BRE depending on whether we last saw a
    -       "grep.extendedRegexp=true" or
    -       "grep.extendedRegexp=[false|<unset>]".
    -
    -    We could equally call this new adjust_pattern_type() in
    -    compile_regexp(), i.e. this fixup on top of this passes all our
    -    tests (with -U0 for brevity):
    -
    -        @@ -60,0 +61 @@ static void adjust_pattern_type(enum grep_pattern_type *pto, const int ero)
    -        +static int ero = -1;
    -        @@ -65 +65,0 @@ int grep_config(const char *var, const char *value, void *cb)
    -        -       static int ero = -1;
    -        @@ -72 +71,0 @@ int grep_config(const char *var, const char *value, void *cb)
    -        -               adjust_pattern_type(&opt->pattern_type_option, ero);
    -        @@ -80 +78,0 @@ int grep_config(const char *var, const char *value, void *cb)
    -        -               adjust_pattern_type(&opt->pattern_type_option, ero);
    -        @@ -445,0 +444,2 @@ static void compile_regexp(struct grep_pat *p, struct grep_opt *opt)
    -        +       if (ero != -1)
    -        +               adjust_pattern_type(&opt->pattern_type_option, ero);
    -
    -    But doing it as we stream the git_config() makes it
    -    clear that we can determine the interplay between these two variables
    -    as we go. We don't need to wait until we see the last value of the two
    -    configuration variables.
    -
    -    This is true because of the rationale above, and because the
    -    subsequent code in compile_regexp() treats
    -    "pattern_type_option=GREP_PATTERN_TYPE_{UNSPECIFIED,BRE}"
    -    equally. I.e. we'll end up with different internal
    -    ""pattern_type_option" values there for:
    -
    -        # UNSPECIFIED
    -        -c grep.patternType=default
    -        # BRE
    -        -c grep.extendedRegexp=false -c grep.patternType=default
    -
    -    But the difference won't matter, which simplifies some of this logic,
    -    we never need to adjust a "grep.patternType" if we didn't see a
    -    "grep.extendedRegexp" before. We can also remove the
    -    "extended_regexp_option" member from "struct grep_opt" in favor of a
    -    static variable in grep_config().
    -
    -    The command-line parsing in cmd_grep() can then completely ignore
    -    "grep.extendedRegexp". Whatever effect it had before that step won't
    -    matter if we see -G, -E, -P etc.
    -
    -    See my 07a3d411739 (grep: remove regflags from the public grep_opt
    -    API, 2017-06-29) for addition of the two comments being removed here,
    -    i.e. the complexity noted in that commit is now going away.
    +        GIT_PERF_EXTRA=1 GIT_PERF_REPEAT_COUNT=10 GIT_PERF_MAKE_OPTS='-j8 USE_LIBPCRE=Y CFLAGS=-O3 LIBPCREDIR=/home/avar/g/pcre2/inst' ./run origin/next HEAD -- p4209-pickaxe.sh
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
    - ## builtin/grep.c ##
    -@@ builtin/grep.c: int cmd_grep(int argc, const char **argv, const char *prefix)
    - 	int i;
    - 	int dummy;
    - 	int use_index = 1;
    --	int pattern_type_arg = GREP_PATTERN_TYPE_UNSPECIFIED;
    - 	int allow_revs;
    + ## diff.h ##
    +@@ diff.h: struct diff_options {
    + 	struct repository *repo;
    + 	struct option *parseopts;
    + 
    ++	struct grep_opt *grep_filter;
    ++
    + 	int no_free;
    + };
      
    - 	struct option options[] = {
    -@@ builtin/grep.c: int cmd_grep(int argc, const char **argv, const char *prefix)
    - 			N_("descend at most <depth> levels"), PARSE_OPT_NONEG,
    - 			NULL, 1 },
    - 		OPT_GROUP(""),
    --		OPT_SET_INT('E', "extended-regexp", &pattern_type_arg,
    -+		OPT_SET_INT('E', "extended-regexp", &opt.pattern_type_option,
    - 			    N_("use extended POSIX regular expressions"),
    - 			    GREP_PATTERN_TYPE_ERE),
    --		OPT_SET_INT('G', "basic-regexp", &pattern_type_arg,
    -+		OPT_SET_INT('G', "basic-regexp", &opt.pattern_type_option,
    - 			    N_("use basic POSIX regular expressions (default)"),
    - 			    GREP_PATTERN_TYPE_BRE),
    --		OPT_SET_INT('F', "fixed-strings", &pattern_type_arg,
    -+		OPT_SET_INT('F', "fixed-strings", &opt.pattern_type_option,
    - 			    N_("interpret patterns as fixed strings"),
    - 			    GREP_PATTERN_TYPE_FIXED),
    --		OPT_SET_INT('P', "perl-regexp", &pattern_type_arg,
    -+		OPT_SET_INT('P', "perl-regexp", &opt.pattern_type_option,
    - 			    N_("use Perl-compatible regular expressions"),
    - 			    GREP_PATTERN_TYPE_PCRE),
    - 		OPT_GROUP(""),
    -@@ builtin/grep.c: int cmd_grep(int argc, const char **argv, const char *prefix)
    - 	argc = parse_options(argc, argv, prefix, options, grep_usage,
    - 			     PARSE_OPT_KEEP_DASHDASH |
    - 			     PARSE_OPT_STOP_AT_NON_OPTION);
    --	grep_commit_pattern_type(pattern_type_arg, &opt);
    +@@ diff.h: int git_config_rename(const char *var, const char *value);
    + #define DIFF_PICKAXE_KIND_G	8 /* grep in the patch */
    + #define DIFF_PICKAXE_KIND_OBJFIND	16 /* specific object IDs */
      
    - 	if (use_index && !startup_info->have_repository) {
    - 		int fallback = 0;
    ++#define DIFF_PICKAXE_KIND_GS_MASK (DIFF_PICKAXE_KIND_S | \
    ++				   DIFF_PICKAXE_KIND_G)
    + #define DIFF_PICKAXE_KINDS_MASK (DIFF_PICKAXE_KIND_S | \
    + 				 DIFF_PICKAXE_KIND_G | \
    + 				 DIFF_PICKAXE_KIND_OBJFIND)
     
    - ## grep.c ##
    -@@ grep.c: static int parse_pattern_type_arg(const char *opt, const char *arg)
    - 
    - define_list_config_array_extra(color_grep_slots, {"match"});
    + ## diffcore-pickaxe.c ##
    +@@
    + #include "diff.h"
    + #include "diffcore.h"
    + #include "xdiff-interface.h"
    +-#include "kwset.h"
    +-#include "commit.h"
    +-#include "quote.h"
    ++#include "grep.h"
      
    -+static void adjust_pattern_type(enum grep_pattern_type *pto, const int ero)
    -+{
    -+	if (*pto == GREP_PATTERN_TYPE_UNSPECIFIED)
    -+		*pto = ero ? GREP_PATTERN_TYPE_ERE : GREP_PATTERN_TYPE_BRE;
    -+}
    -+
    - /*
    -  * Read the configuration file once and store it in
    -  * the grep_defaults template.
    -@@ grep.c: int grep_config(const char *var, const char *value, void *cb)
    - {
    - 	struct grep_opt *opt = cb;
    - 	const char *slot;
    -+	static int ero = -1;
    + typedef int (*pickaxe_fn)(mmfile_t *one, mmfile_t *two,
    + 			  struct diff_options *o,
    +-			  regex_t *regexp, kwset_t kws);
    ++			  struct grep_opt *grep_filter);
      
    - 	if (userdiff_config(var, value) < 0)
    - 		return -1;
    + struct diffgrep_cb {
    +-	regex_t *regexp;
    ++	struct grep_opt	*grep_filter;
    + 	int hit;
    + };
      
    - 	if (!strcmp(var, "grep.extendedregexp")) {
    --		opt->extended_regexp_option = git_config_bool(var, value);
    -+		ero = git_config_bool(var, value);
    -+		adjust_pattern_type(&opt->pattern_type_option, ero);
    - 		return 0;
    - 	}
    +@@ diffcore-pickaxe.c: static int diffgrep_consume(void *priv, char *line, unsigned long len)
    + {
    + 	struct diffgrep_cb *data = priv;
    + 	regmatch_t regmatch;
    ++	struct grep_opt *grep_filter = data->grep_filter;
    ++	struct grep_pat *grep_pat = grep_filter->pattern_list;
      
    - 	if (!strcmp(var, "grep.patterntype")) {
    - 		opt->pattern_type_option = parse_pattern_type_arg(var, value);
    -+		if (ero == -1)
    -+			return 0;
    -+		adjust_pattern_type(&opt->pattern_type_option, ero);
    + 	if (line[0] != '+' && line[0] != '-')
      		return 0;
    + 	if (data->hit)
    + 		BUG("Already matched in diffgrep_consume! Broken xdiff_emit_line_fn?");
    +-	if (!regexec_buf(data->regexp, line + 1, len - 1, 1,
    +-			 &regmatch, 0)) {
    ++	if (patmatch(grep_pat, line + 1, line + len + 1, &regmatch, 0)) {
    + 		data->hit = 1;
    + 		return 1;
      	}
    +@@ diffcore-pickaxe.c: static int diffgrep_consume(void *priv, char *line, unsigned long len)
      
    -@@ grep.c: void grep_init(struct grep_opt *opt, struct repository *repo)
    - 	opt->header_tail = &opt->header_list;
    + static int diff_grep(mmfile_t *one, mmfile_t *two,
    + 		     struct diff_options *o,
    +-		     regex_t *regexp, kwset_t kws)
    ++		     struct grep_opt *grep_filter)
    + {
    + 	struct diffgrep_cb ecbdata;
    + 	xpparam_t xpp;
    +@@ diffcore-pickaxe.c: static int diff_grep(mmfile_t *one, mmfile_t *two,
    + 	 */
    + 	memset(&xpp, 0, sizeof(xpp));
    + 	memset(&xecfg, 0, sizeof(xecfg));
    +-	ecbdata.regexp = regexp;
    ++	ecbdata.grep_filter = grep_filter;
    + 	ecbdata.hit = 0;
    + 	xecfg.flags = XDL_EMIT_NO_HUNK_HDR;
    + 	xecfg.ctxlen = o->context;
    +@@ diffcore-pickaxe.c: static int diff_grep(mmfile_t *one, mmfile_t *two,
    + 	return 0;
      }
      
    --static void grep_set_pattern_type_option(enum grep_pattern_type pattern_type, struct grep_opt *opt)
    --{
    --	/*
    --	 * When committing to the pattern type by setting the relevant
    --	 * fields in grep_opt it's generally not necessary to zero out
    --	 * the fields we're not choosing, since they won't have been
    --	 * set by anything. The extended_regexp_option field is the
    --	 * only exception to this.
    --	 *
    --	 * This is because in the process of parsing grep.patternType
    --	 * & grep.extendedRegexp we set opt->pattern_type_option and
    --	 * opt->extended_regexp_option, respectively. We then
    --	 * internally use opt->extended_regexp_option to see if we're
    --	 * compiling an ERE. It must be unset if that's not actually
    --	 * the case.
    --	 */
    --	if (pattern_type != GREP_PATTERN_TYPE_ERE &&
    --	    opt->extended_regexp_option)
    --		opt->extended_regexp_option = 0;
    --
    --	switch (pattern_type) {
    --	case GREP_PATTERN_TYPE_UNSPECIFIED:
    --		/* fall through */
    --
    --	case GREP_PATTERN_TYPE_BRE:
    --		break;
    +-static unsigned int contains(mmfile_t *mf, regex_t *regexp, kwset_t kws,
    ++static unsigned int contains(mmfile_t *mf, struct grep_opt *grep_filter,
    + 			     unsigned int limit)
    + {
    ++
    + 	unsigned int cnt = 0;
    + 	unsigned long sz = mf->size;
    +-	const char *data = mf->ptr;
     -
    --	case GREP_PATTERN_TYPE_ERE:
    --		opt->extended_regexp_option = 1;
    --		break;
    +-	if (regexp) {
    +-		regmatch_t regmatch;
    +-		int flags = 0;
     -
    --	case GREP_PATTERN_TYPE_FIXED:
    --		opt->fixed = 1;
    --		break;
    +-		while (sz &&
    +-		       !regexec_buf(regexp, data, sz, 1, &regmatch, flags)) {
    +-			flags |= REG_NOTBOL;
    +-			data += regmatch.rm_eo;
    +-			sz -= regmatch.rm_eo;
    +-			if (sz && regmatch.rm_so == regmatch.rm_eo) {
    +-				data++;
    +-				sz--;
    +-			}
    +-			cnt++;
     -
    --	case GREP_PATTERN_TYPE_PCRE:
    --		opt->pcre2 = 1;
    --		break;
    --	}
    --}
    +-			if (limit && cnt == limit)
    +-				return cnt;
    +-		}
     -
    --void grep_commit_pattern_type(enum grep_pattern_type pattern_type, struct grep_opt *opt)
    --{
    --	if (pattern_type != GREP_PATTERN_TYPE_UNSPECIFIED)
    --		grep_set_pattern_type_option(pattern_type, opt);
    --	else if (opt->pattern_type_option != GREP_PATTERN_TYPE_UNSPECIFIED)
    --		grep_set_pattern_type_option(opt->pattern_type_option, opt);
    --	else if (opt->extended_regexp_option)
    --		/*
    --		 * This branch *must* happen after setting from the
    --		 * opt->pattern_type_option above, we don't want
    --		 * grep.extendedRegexp to override grep.patternType!
    --		 */
    --		grep_set_pattern_type_option(GREP_PATTERN_TYPE_ERE, opt);
    --}
    +-	} else { /* Classic exact string match */
    +-		while (sz) {
    +-			struct kwsmatch kwsm;
    +-			size_t offset = kwsexec(kws, data, sz, &kwsm);
    +-			if (offset == -1)
    +-				break;
    +-			sz -= offset + kwsm.size[0];
    +-			data += offset + kwsm.size[0];
    +-			cnt++;
     -
    - static struct grep_pat *create_grep_pat(const char *pat, size_t patlen,
    - 					const char *origin, int no,
    - 					enum grep_pat_token t,
    -@@ grep.c: static void compile_regexp(struct grep_pat *p, struct grep_opt *opt)
    +-			if (limit && cnt == limit)
    +-				return cnt;
    ++	char *data = mf->ptr;
    ++	regmatch_t regmatch;
    ++	int flags = 0;
    ++	struct grep_pat *grep_pat = grep_filter->pattern_list;
    ++
    ++	while (sz &&
    ++	       patmatch(grep_pat, data, data + sz, &regmatch, flags)) {
    ++		flags |= REG_NOTBOL;
    ++		data += regmatch.rm_eo;
    ++		sz -= regmatch.rm_eo;
    ++		if (sz && regmatch.rm_so == regmatch.rm_eo) {
    ++			data++;
    ++			sz--;
    + 		}
    ++		cnt++;
    ++		if (limit && cnt == limit)
    ++			return cnt;
    + 	}
    + 	return cnt;
    + }
      
    - 	p->word_regexp = opt->word_regexp;
    - 	p->ignore_case = opt->ignore_case;
    --	p->fixed = opt->fixed;
    -+	p->fixed = opt->pattern_type_option == GREP_PATTERN_TYPE_FIXED;
    + static int has_changes(mmfile_t *one, mmfile_t *two,
    + 		       struct diff_options *o,
    +-		       regex_t *regexp, kwset_t kws)
    ++		       struct grep_opt *grep_filter)
    + {
    +-	unsigned int c1 = one ? contains(one, regexp, kws, 0) : 0;
    +-	unsigned int c2 = two ? contains(two, regexp, kws, c1 + 1) : 0;
    ++	unsigned int c1 = one ? contains(one, grep_filter, 0) : 0;
    ++	unsigned int c2 = two ? contains(two, grep_filter, c1 + 1) : 0;
    + 	return c1 != c2;
    + }
      
    --	if (!opt->pcre2 &&
    -+	if (opt->pattern_type_option != GREP_PATTERN_TYPE_PCRE &&
    - 	    memchr(p->pattern, 0, p->patternlen))
    - 		die(_("given pattern contains NULL byte (via -f <file>). This is only supported with -P under PCRE v2"));
    + static int pickaxe_match(struct diff_filepair *p, struct diff_options *o,
    +-			 regex_t *regexp, kwset_t kws, pickaxe_fn fn)
    ++			 struct grep_opt *grep_filter, pickaxe_fn fn)
    + {
    + 	struct userdiff_driver *textconv_one = NULL;
    + 	struct userdiff_driver *textconv_two = NULL;
    +@@ diffcore-pickaxe.c: static int pickaxe_match(struct diff_filepair *p, struct diff_options *o,
    + 	mf1.size = fill_textconv(o->repo, textconv_one, p->one, &mf1.ptr);
    + 	mf2.size = fill_textconv(o->repo, textconv_two, p->two, &mf2.ptr);
      
    -@@ grep.c: static void compile_regexp(struct grep_pat *p, struct grep_opt *opt)
    - 		return;
    - 	}
    +-	ret = fn(&mf1, &mf2, o, regexp, kws);
    ++	ret = fn(&mf1, &mf2, o, grep_filter);
      
    --	if (opt->pcre2) {
    -+	if (opt->pattern_type_option == GREP_PATTERN_TYPE_PCRE) {
    - 		compile_pcre2_pattern(p, opt);
    - 		return;
    - 	}
    + 	if (textconv_one)
    + 		free(mf1.ptr);
    +@@ diffcore-pickaxe.c: static int pickaxe_match(struct diff_filepair *p, struct diff_options *o,
    + }
      
    - 	if (p->ignore_case)
    - 		regflags |= REG_ICASE;
    --	if (opt->extended_regexp_option)
    -+	if (opt->pattern_type_option == GREP_PATTERN_TYPE_ERE)
    - 		regflags |= REG_EXTENDED;
    - 	err = regcomp(&p->regexp, p->pattern, regflags);
    - 	if (err) {
    -
    - ## grep.h ##
    -@@ grep.h: struct grep_opt {
    - 	int unmatch_name_only;
    - 	int count;
    - 	int word_regexp;
    --	int fixed;
    - 	int all_match;
    - #define GREP_BINARY_DEFAULT	0
    - #define GREP_BINARY_NOMATCH	1
    -@@ grep.h: struct grep_opt {
    - 	int allow_textconv;
    - 	int extended;
    - 	int use_reflog_filter;
    --	int pcre2;
    - 	int relative;
    - 	int pathname;
    - 	int null_following_name;
    -@@ grep.h: struct grep_opt {
    - 	int max_depth;
    - 	int funcname;
    - 	int funcbody;
    --	int extended_regexp_option;
    - 	enum grep_pattern_type pattern_type_option;
    - 	int ignore_locale;
    - 	char colors[NR_GREP_COLORS][COLOR_MAXLEN];
    -@@ grep.h: struct grep_opt {
    + static void pickaxe(struct diff_queue_struct *q, struct diff_options *o,
    +-		    regex_t *regexp, kwset_t kws, pickaxe_fn fn)
    ++		    struct grep_opt *grep_filter, pickaxe_fn fn)
    + {
    + 	int i;
    + 	struct diff_queue_struct outq;
    +@@ diffcore-pickaxe.c: static void pickaxe(struct diff_queue_struct *q, struct diff_options *o,
    + 		/* Showing the whole changeset if needle exists */
    + 		for (i = 0; i < q->nr; i++) {
    + 			struct diff_filepair *p = q->queue[i];
    +-			if (pickaxe_match(p, o, regexp, kws, fn))
    ++			if (pickaxe_match(p, o, grep_filter, fn))
    + 				return; /* do not munge the queue */
    + 		}
      
    - int grep_config(const char *var, const char *value, void *);
    - void grep_init(struct grep_opt *, struct repository *repo);
    --void grep_commit_pattern_type(enum grep_pattern_type, struct grep_opt *opt);
    +@@ diffcore-pickaxe.c: static void pickaxe(struct diff_queue_struct *q, struct diff_options *o,
    + 		/* Showing only the filepairs that has the needle */
    + 		for (i = 0; i < q->nr; i++) {
    + 			struct diff_filepair *p = q->queue[i];
    +-			if (pickaxe_match(p, o, regexp, kws, fn))
    ++			if (pickaxe_match(p, o, grep_filter, fn))
    + 				diff_q(&outq, p);
    + 			else
    + 				diff_free_filepair(p);
    +@@ diffcore-pickaxe.c: static void pickaxe(struct diff_queue_struct *q, struct diff_options *o,
    + 	*q = outq;
    + }
      
    - void append_grep_pat(struct grep_opt *opt, const char *pat, size_t patlen, const char *origin, int no, enum grep_pat_token t);
    - void append_grep_pattern(struct grep_opt *opt, const char *pat, const char *origin, int no, enum grep_pat_token t);
    -
    - ## revision.c ##
    -@@ revision.c: int setup_revisions(int argc, const char **argv, struct rev_info *revs, struct s
    +-static void regcomp_or_die(regex_t *regex, const char *needle, int cflags)
    +-{
    +-	int err = regcomp(regex, needle, cflags);
    +-	if (err) {
    +-		/* The POSIX.2 people are surely sick */
    +-		char errbuf[1024];
    +-		regerror(err, regex, errbuf, 1024);
    +-		die("invalid regex: %s", errbuf);
    +-	}
    +-}
    +-
    + void diffcore_pickaxe(struct diff_options *o)
    + {
    + 	const char *needle = o->pickaxe;
    + 	int opts = o->pickaxe_opts;
    +-	regex_t regex, *regexp = NULL;
    +-	kwset_t kws = NULL;
    ++	struct grep_opt opt;
    + 	pickaxe_fn fn;
      
    - 	diff_setup_done(&revs->diffopt);
    + 	if (opts & ~DIFF_PICKAXE_KIND_OBJFIND &&
    + 	    (!needle || !*needle))
    + 		BUG("should have needle under -G or -S");
    +-	if (opts & (DIFF_PICKAXE_REGEX | DIFF_PICKAXE_KIND_G)) {
    +-		int cflags = REG_EXTENDED | REG_NEWLINE;
    ++	if (opts & (DIFF_PICKAXE_REGEX | DIFF_PICKAXE_KIND_GS_MASK)) {
    ++		grep_init(&opt, the_repository, NULL);
    ++#ifdef USE_LIBPCRE2
    ++		grep_commit_pattern_type(GREP_PATTERN_TYPE_PCRE, &opt);
    ++#else
    ++		grep_commit_pattern_type(GREP_PATTERN_TYPE_ERE, &opt);
    ++#endif
    ++
    + 		if (o->pickaxe_opts & DIFF_PICKAXE_IGNORE_CASE)
    +-			cflags |= REG_ICASE;
    +-		regcomp_or_die(&regex, needle, cflags);
    +-		regexp = &regex;
    ++			opt.ignore_case = 1;
    ++		if (opts & DIFF_PICKAXE_KIND_S &&
    ++		    !(opts & DIFF_PICKAXE_REGEX))
    ++			opt.fixed = 1;
    ++
    ++		append_grep_pattern(&opt, needle, "diffcore-pickaxe", 0, GREP_PATTERN);
    ++		compile_grep_patterns(&opt);
    + 
    + 		if (opts & DIFF_PICKAXE_KIND_G)
    + 			fn = diff_grep;
    ++		else if (opts & DIFF_PICKAXE_KIND_S)
    ++			fn = has_changes;
    + 		else if (opts & DIFF_PICKAXE_REGEX)
    + 			fn = has_changes;
    + 		else
    +@@ diffcore-pickaxe.c: void diffcore_pickaxe(struct diff_options *o)
    + 			 * t4209-log-pickaxe.sh.
    + 			 */
    + 			BUG("unreachable");
    +-	} else if (opts & DIFF_PICKAXE_KIND_S) {
    +-		if (o->pickaxe_opts & DIFF_PICKAXE_IGNORE_CASE &&
    +-		    has_non_ascii(needle)) {
    +-			struct strbuf sb = STRBUF_INIT;
    +-			int cflags = REG_NEWLINE | REG_ICASE;
    +-
    +-			basic_regex_quote_buf(&sb, needle);
    +-			regcomp_or_die(&regex, sb.buf, cflags);
    +-			strbuf_release(&sb);
    +-			regexp = &regex;
    +-		} else {
    +-			kws = kwsalloc(o->pickaxe_opts & DIFF_PICKAXE_IGNORE_CASE
    +-				       ? tolower_trans_tbl : NULL);
    +-			kwsincr(kws, needle, strlen(needle));
    +-			kwsprep(kws);
    +-		}
    +-		fn = has_changes;
    + 	} else if (opts & DIFF_PICKAXE_KIND_OBJFIND) {
    + 		fn = NULL;
    + 	} else {
    + 		BUG("unknown pickaxe_opts flag");
    + 	}
      
    --	grep_commit_pattern_type(GREP_PATTERN_TYPE_UNSPECIFIED,
    --				 &revs->grep_filter);
    - 	if (!is_encoding_utf8(get_log_output_encoding()))
    - 		revs->grep_filter.ignore_locale = 1;
    - 	compile_grep_patterns(&revs->grep_filter);
    +-	pickaxe(&diff_queued_diff, o, regexp, kws, fn);
    ++	pickaxe(&diff_queued_diff, o, &opt, fn);
    ++
    ++	if (opts & ~DIFF_PICKAXE_KIND_OBJFIND)
    ++		free_grep_patterns(&opt);
    + 
    +-	if (regexp)
    +-		regfree(regexp);
    +-	if (kws)
    +-		kwsfree(kws);
    + 	return;
    + }
 -:  ----------- >  3:  00c6bbb8091 Remove unused kwset.[ch]
 4:  6d91a765fd7 !  4:  c641139cee1 built-ins: trust the "prefix" from run_builtin()
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    built-ins: trust the "prefix" from run_builtin()
    +    diffcore-pickaxe: add --pickaxe-patch for use with -G
     
    -    Change code in "builtin/grep.c" and "builtin/ls-tree.c" to trust the
    -    "prefix" passed from "run_builtin()". The "prefix" we get from setup.c
    -    is either going to be NULL or a string of length >0, never "".
    +    Add the ability for the -G<regex> pickaxe to search only through any
    +    of the added, removed or context lines in the displayed diff. When
    +    combined with -W or -U<n> this allows searching not only through a
    +    change, but also the context that's adjacent to it.  would be
     
    -    So we can drop the "prefix && *prefix" checks added for
    -    "builtin/grep.c" in 0d042fecf2f (git-grep: show pathnames relative to
    -    the current directory, 2006-08-11), and for "builtin/ls-tree.c" in
    -    a69dd585fca (ls-tree: chomp leading directories when run from a
    -    subdirectory, 2005-12-23).
    +    This has been requested[1][2] a few times in the past, and isn't
    +    currently possible.
     
    -    As seen in code in revision.c that was added in cd676a51367 (diff
    -    --relative: output paths as relative to the current subdirectory,
    -    2008-02-12) we already have existing code that does away with this
    -    assertion.
    +    Instead users need to do -G<regex> and then write their own
    +    post-parsing script to see if the <regex> matched added or removed
    +    lines, or both. There was no way to match the adjacent context lines
    +    other than running and grepping the equivalent of a "log -p -U<n>".
     
    -    This makes it easier to reason about a subsequent change to the
    -    "prefix_length" code in grep.c in a subsequent commit, and since we're
    -    going to the trouble of doing that let's leave behind an assert() to
    -    promise this to any future callers.
    +    Perf test results of the whole thing:
     
    -    For "builtin/grep.c" it would be painful to pass the "prefix" down the
    -    callchain of:
    +    TURNS OUT I WAS USING USE_LIBPCRE= !!!
     
    -        cmd_grep -> grep_tree -> grep_submodule -> grep_cache -> grep_oid ->
    -        grep_source_name
    +    HEAD~8: contains() limit optimization
    +    HEAD~5: pickaxe -G:  early termination
    +    HEAD~4: pickaxe -G: always make the diff
    +    HEAD~2: use PCRE
     
    -    So for the code that needs it in grep_source_name() let's add a
    -    "grep_prefix" variable similar to the existing "ls_tree_prefix".
    +    Test                                                                      origin/next       HEAD~8                  HEAD~5                  HEAD~4                  HEAD~2
    +    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    +    4209.1: git log -S'int main' <limit-rev>..                                0.38(0.35+0.03)   0.39(0.34+0.04) +2.6%   0.38(0.34+0.04) +0.0%   0.39(0.34+0.04) +2.6%   0.56(0.52+0.03) +47.4%
    +    4209.2: git log -S'æ' <limit-rev>..                                       0.51(0.47+0.03)   0.51(0.46+0.04) +0.0%   0.51(0.46+0.04) +0.0%   0.51(0.45+0.05) +0.0%   0.39(0.36+0.02) -23.5%
    +    4209.3: git log --pickaxe-regex -S'(int|void|null)' <limit-rev>..         0.71(0.68+0.03)   0.71(0.67+0.03) +0.0%   0.71(0.67+0.04) +0.0%   0.71(0.64+0.07) +0.0%   0.70(0.65+0.05) -1.4%
    +    4209.4: git log --pickaxe-regex -S'if *\([^ ]+ & ' <limit-rev>..          0.57(0.53+0.04)   0.57(0.53+0.03) +0.0%   0.56(0.51+0.05) -1.8%   0.57(0.54+0.03) +0.0%   0.56(0.52+0.04) -1.8%
    +    4209.5: git log --pickaxe-regex -S'[àáâãäåæñøùúûüýþ]' <limit-rev>..       0.42(0.41+0.02)   0.42(0.38+0.04) +0.0%   0.42(0.40+0.02) +0.0%   0.42(0.38+0.04) +0.0%   0.42(0.36+0.06) +0.0%
    +    4209.6: git log -G'(int|void|null)' <limit-rev>..                         0.64(0.59+0.05)   0.64(0.58+0.06) +0.0%   0.63(0.54+0.09) -1.6%   0.63(0.57+0.06) -1.6%   0.63(0.57+0.06) -1.6%
    +    4209.7: git log -G'if *\([^ ]+ & ' <limit-rev>..                          0.65(0.58+0.07)   0.65(0.61+0.04) +0.0%   0.64(0.58+0.06) -1.5%   0.65(0.62+0.03) +0.0%   0.64(0.57+0.07) -1.5%
    +    4209.8: git log -G'[àáâãäåæñøùúûüýþ]' <limit-rev>..                       0.64(0.57+0.06)   0.64(0.56+0.07) +0.0%   0.63(0.58+0.04) -1.6%   0.63(0.57+0.06) -1.6%   0.62(0.55+0.07) -3.1%
    +    4209.9: git log -i -S'int main' <limit-rev>..                             0.39(0.35+0.03)   0.39(0.34+0.05) +0.0%   0.39(0.34+0.05) +0.0%   0.39(0.35+0.04) +0.0%   0.63(0.58+0.05) +61.5%
    +    4209.10: git log -i -S'æ' <limit-rev>..                                   0.39(0.36+0.03)   0.39(0.33+0.06) +0.0%   0.39(0.35+0.03) +0.0%   0.40(0.36+0.04) +2.6%   0.39(0.35+0.04) +0.0%
    +    4209.11: git log -i --pickaxe-regex -S'(int|void|null)' <limit-rev>..     0.90(0.88+0.02)   0.90(0.87+0.03) +0.0%   0.90(0.83+0.06) +0.0%   0.90(0.86+0.04) +0.0%   0.91(0.86+0.04) +1.1%
    +    4209.12: git log -i --pickaxe-regex -S'if *\([^ ]+ & ' <limit-rev>..      0.71(0.65+0.05)   0.71(0.65+0.05) +0.0%   0.70(0.64+0.06) -1.4%   0.70(0.65+0.05) -1.4%   0.70(0.67+0.03) -1.4%
    +    4209.13: git log -i --pickaxe-regex -S'[àáâãäåæñøùúûüýþ]' <limit-rev>..   0.43(0.40+0.03)   0.43(0.39+0.04) +0.0%   0.43(0.39+0.04) +0.0%   0.44(0.40+0.04) +2.3%   0.44(0.40+0.04) +2.3%
    +    4209.14: git log -i -G'(int|void|null)' <limit-rev>..                     0.65(0.58+0.07)   0.65(0.56+0.09) +0.0%   0.63(0.58+0.05) -3.1%   0.64(0.59+0.05) -1.5%   0.63(0.57+0.06) -3.1%
    +    4209.15: git log -i -G'if *\([^ ]+ & ' <limit-rev>..                      0.66(0.61+0.05)   0.66(0.60+0.06) +0.0%   0.65(0.59+0.06) -1.5%   0.66(0.61+0.05) +0.0%   0.65(0.59+0.06) -1.5%
    +    4209.16: git log -i -G'[àáâãäåæñøùúûüýþ]' <limit-rev>..                   0.64(0.58+0.06)   0.65(0.56+0.09) +1.6%   0.62(0.55+0.07) -3.1%   0.63(0.58+0.05) -1.6%   0.62(0.58+0.04) -3.1%
     
    -    While at it let's move the code in cmd_ls_tree() around so that we
    -    assign to the "ls_tree_prefix" right after declaring the variables,
    -    and stop assigning to "prefix". We only subsequently used that
    -    variable later in the function after clobbering it. Let's just use our
    -    own "grep_prefix" instead.
    -
    -    Let's also add an assert() in git.c, so that we'll make this promise
    -    about the "prefix" to any current and future callers, as well as to
    -    any readers of the code.
    -
    -    Code history:
    -
    -     * The strlen() in "grep.c" hasn't been used since 493b7a08d80 (grep:
    -       accept relative paths outside current working directory, 2009-09-05).
    -
    -       When that code was added in 0d042fecf2f (git-grep: show pathnames
    -       relative to the current directory, 2006-08-11) we used the length.
    -
    -       But since 493b7a08d80 we haven't used it for anything except a
    -       boolean check that we could have done on the "prefix" member
    -       itself.
    +    1. https://lore.kernel.org/git/xmqqwoqrr8y2.fsf@gitster-ct.c.googlers.com/
    +    2. https://lore.kernel.org/git/20190424102609.GA19697@vmlxhi-102.adit-jv.com/
     
         Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
    - ## builtin/grep.c ##
    -@@
    - #include "object-store.h"
    - #include "packfile.h"
    + ## Documentation/diff-options.txt ##
    +@@ Documentation/diff-options.txt: occurrences of that string did not change).
    + Unless `--text` is supplied patches of binary files without a textconv
    + filter will be ignored.
    + +
    ++When `--pickaxe-patch` is supplied the whole diff is searched instead
    ++of just added/removed lines. See below.
    +++
    + See the 'pickaxe' entry in linkgit:gitdiffcore[7] for more
    + information.
    + 
    +@@ Documentation/diff-options.txt: The object can be a blob or a submodule commit. It implies the `-t` option in
    + 	Treat the <string> given to `-S` as an extended POSIX regular
    + 	expression to match.
      
    -+static const char *grep_prefix;
    ++--pickaxe-patch::
    ++	When `-G` looks for a change a diff will be generated, and
    ++	only the added/removed lines will be matched against with the
    ++	"+" or "-" stripped.
    +++
    ++Supplying this option skips that pre-processing. This makes it
    ++possible to match only lines that added or removed something matching
    ++a <regex> with "\^\+<regex>" and "^-<regex>", respectively.
    +++
    ++It also allows for finding something in the diff context. E.g. "\^
    ++<regex>" will match the context lines (see `-U<n>` above) around the
    ++added/removed lines, and doing an unanchored match will match any of
    ++the the added/removed lines & diff context.
     +
    - static char const * const grep_usage[] = {
    - 	N_("git grep [<options>] [-e] <pattern> [<rev>...] [[--] <path>...]"),
    - 	NULL
    -@@ builtin/grep.c: static void grep_source_name(struct grep_opt *opt, const char *filename,
    - 	strbuf_reset(out);
    - 
    - 	if (opt->null_following_name) {
    --		if (opt->relative && opt->prefix_length) {
    -+		if (opt->relative && grep_prefix) {
    - 			struct strbuf rel_buf = STRBUF_INIT;
    - 			const char *rel_name =
    - 				relative_path(filename + tree_name_len,
    --					      opt->prefix, &rel_buf);
    -+					      grep_prefix, &rel_buf);
    - 
    - 			if (tree_name_len)
    - 				strbuf_add(out, filename, tree_name_len);
    -@@ builtin/grep.c: static void grep_source_name(struct grep_opt *opt, const char *filename,
    - 		return;
    - 	}
    + endif::git-format-patch[]
      
    --	if (opt->relative && opt->prefix_length)
    --		quote_path(filename + tree_name_len, opt->prefix, out, 0);
    -+	if (opt->relative && grep_prefix)
    -+		quote_path(filename + tree_name_len, grep_prefix, out, 0);
    - 	else
    - 		quote_c_style(filename + tree_name_len, out, NULL, 0);
    + -O<orderfile>::
    +
    + ## diff.c ##
    +@@ diff.c: void diff_setup_done(struct diff_options *options)
    + 		die(_("options '%s' and '%s' cannot be used together, use '%s' with '%s'"),
    + 			"-G", "--pickaxe-regex", "--pickaxe-regex", "-S");
      
    -@@ builtin/grep.c: int cmd_grep(int argc, const char **argv, const char *prefix)
    - 			   PARSE_OPT_NOCOMPLETE),
    - 		OPT_END()
    - 	};
    -+	grep_prefix = prefix;
    ++	if (HAS_MULTI_BITS(options->pickaxe_opts & DIFF_PICKAXE_KINDS_S_PATCH_MASK))
    ++		die(_("-S and --pickaxe-patch are mutually exclusive, use --pickaxe-patch with -G"));
    ++
    + 	if (HAS_MULTI_BITS(options->pickaxe_opts & DIFF_PICKAXE_KINDS_ALL_OBJFIND_MASK))
    + 		die(_("options '%s' and '%s' cannot be used together, use '%s' with '%s' and '%s'"),
    + 			"--pickaxe-all", "--find-object", "--pickaxe-all", "-G", "-S");
    +@@ diff.c: static void prep_parse_options(struct diff_options *options)
    + 		OPT_BIT_F(0, "pickaxe-regex", &options->pickaxe_opts,
    + 			  N_("treat <string> in -S as extended POSIX regular expression"),
    + 			  DIFF_PICKAXE_REGEX, PARSE_OPT_NONEG),
    ++		OPT_BIT_F(0, "pickaxe-patch", &options->pickaxe_opts,
    ++			  N_("have <string> in -G match the full diff hunk output"),
    ++			  DIFF_PICKAXE_PATCH, PARSE_OPT_NONEG),
    + 		OPT_FILENAME('O', NULL, &options->orderfile,
    + 			     N_("control the order in which files appear in the output")),
    + 		OPT_CALLBACK_F(0, "rotate-to", options, N_("<path>"),
    +
    + ## diff.h ##
    +@@ diff.h: int git_config_rename(const char *var, const char *value);
      
    - 	git_config(grep_cmd_config, NULL);
    --	grep_init(&opt, the_repository, prefix);
    -+	grep_init(&opt, the_repository);
    + #define DIFF_PICKAXE_ALL	1
    + #define DIFF_PICKAXE_REGEX	2
    ++#define DIFF_PICKAXE_PATCH	4
      
    - 	/*
    - 	 * If there is no -- then the paths must exist in the working
    -
    - ## builtin/ls-tree.c ##
    -@@ builtin/ls-tree.c: int cmd_ls_tree(int argc, const char **argv, const char *prefix)
    +-#define DIFF_PICKAXE_KIND_S	4 /* traditional plumbing counter */
    +-#define DIFF_PICKAXE_KIND_G	8 /* grep in the patch */
    +-#define DIFF_PICKAXE_KIND_OBJFIND	16 /* specific object IDs */
    ++#define DIFF_PICKAXE_KIND_S	8 /* traditional plumbing counter */
    ++#define DIFF_PICKAXE_KIND_G	16 /* grep in the patch */
    ++#define DIFF_PICKAXE_KIND_OBJFIND	32 /* specific object IDs */
      
    - 	git_config(git_default_config, NULL);
    - 	ls_tree_prefix = prefix;
    --	if (prefix && *prefix)
    -+	if (prefix)
    - 		chomp_prefix = strlen(prefix);
    + #define DIFF_PICKAXE_KIND_GS_MASK (DIFF_PICKAXE_KIND_S | \
    + 				   DIFF_PICKAXE_KIND_G)
    +@@ diff.h: int git_config_rename(const char *var, const char *value);
    + 				 DIFF_PICKAXE_KIND_OBJFIND)
    + #define DIFF_PICKAXE_KINDS_G_REGEX_MASK (DIFF_PICKAXE_KIND_G | \
    + 					 DIFF_PICKAXE_REGEX)
    ++#define DIFF_PICKAXE_KINDS_S_PATCH_MASK (DIFF_PICKAXE_KIND_S | \
    ++					 DIFF_PICKAXE_PATCH)
    + #define DIFF_PICKAXE_KINDS_ALL_OBJFIND_MASK (DIFF_PICKAXE_ALL | \
    + 					     DIFF_PICKAXE_KIND_OBJFIND)
    ++#define DIFF_PICKAXE_KINDS_ALL_OBJFIND_MASK (DIFF_PICKAXE_ALL | \
    ++					     DIFF_PICKAXE_KIND_OBJFIND)
    ++
    ++#define DIFF_PICKAXE_IGNORE_CASE	64
    + 
    +-#define DIFF_PICKAXE_IGNORE_CASE	32
      
    - 	argc = parse_options(argc, argv, prefix, ls_tree_options,
    + void diffcore_std(struct diff_options *);
    + void diffcore_fix_diff_index(void);
     
    - ## git.c ##
    -@@ git.c: static int run_builtin(struct cmd_struct *p, int argc, const char **argv)
    - 	} else {
    - 		prefix = NULL;
    + ## diffcore-pickaxe.c ##
    +@@ diffcore-pickaxe.c: typedef int (*pickaxe_fn)(mmfile_t *one, mmfile_t *two,
    + struct diffgrep_cb {
    + 	struct grep_opt	*grep_filter;
    + 	int hit;
    ++	int patch;
    + };
    + 
    + static int diffgrep_consume(void *priv, char *line, unsigned long len)
    +@@ diffcore-pickaxe.c: static int diffgrep_consume(void *priv, char *line, unsigned long len)
    + 	regmatch_t regmatch;
    + 	struct grep_opt *grep_filter = data->grep_filter;
    + 	struct grep_pat *grep_pat = grep_filter->pattern_list;
    ++	size_t off = data->patch ? 0 : 1;
    + 
    +-	if (line[0] != '+' && line[0] != '-')
    ++	if (off && line[0] != '+' && line[0] != '-')
    + 		return 0;
    + 	if (data->hit)
    + 		BUG("Already matched in diffgrep_consume! Broken xdiff_emit_line_fn?");
    +-	if (patmatch(grep_pat, line + 1, line + len + 1, &regmatch, 0)) {
    ++	if (patmatch(grep_pat, line + off, line + len + 1, &regmatch, 0)) {
    + 		data->hit = 1;
    + 		return 1;
      	}
    -+	assert(!prefix || *prefix);
    - 	precompose_argv_prefix(argc, argv, NULL);
    - 	if (use_pager == -1 && run_setup &&
    - 		!(p->option & DELAY_PAGER_CONFIG))
    +@@ diffcore-pickaxe.c: static int diff_grep(mmfile_t *one, mmfile_t *two,
    + 	ecbdata.hit = 0;
    + 	xecfg.flags = XDL_EMIT_NO_HUNK_HDR;
    + 	xecfg.ctxlen = o->context;
    ++	ecbdata.patch = o->pickaxe_opts & DIFF_PICKAXE_PATCH;
    + 	xecfg.interhunkctxlen = o->interhunkcontext;
    + 
    + 	/*
     
      ## grep.c ##
    -@@ grep.c: int grep_config(const char *var, const char *value, void *cb)
    -  * default values from the template we read the configuration
    -  * information in an earlier call to git_config(grep_config).
    -  */
    --void grep_init(struct grep_opt *opt, struct repository *repo, const char *prefix)
    -+void grep_init(struct grep_opt *opt, struct repository *repo)
    +@@ grep.c: static void compile_fixed_regexp(struct grep_pat *p, struct grep_opt *opt)
    + static void compile_regexp(struct grep_pat *p, struct grep_opt *opt)
      {
    - 	*opt = grep_defaults;
    - 
    - 	opt->repo = repo;
    --	opt->prefix = prefix;
    --	opt->prefix_length = (prefix && *prefix) ? strlen(prefix) : 0;
    - 	opt->pattern_tail = &opt->pattern_list;
    - 	opt->header_tail = &opt->header_list;
    - }
    -
    - ## grep.h ##
    -@@ grep.h: struct grep_opt {
    - 	 */
    - 	struct repository *repo;
    - 
    --	const char *prefix;
    --	int prefix_length;
    - 	int linenum;
    - 	int columnnum;
    - 	int invert;
    -@@ grep.h: struct grep_opt {
    - };
    - 
    - int grep_config(const char *var, const char *value, void *);
    --void grep_init(struct grep_opt *, struct repository *repo, const char *prefix);
    -+void grep_init(struct grep_opt *, struct repository *repo);
    - void grep_commit_pattern_type(enum grep_pattern_type, struct grep_opt *opt);
    + 	int err;
    +-	int regflags = REG_NEWLINE;
    ++	int regflags = 0; //REG_NEWLINE;
      
    - void append_grep_pat(struct grep_opt *opt, const char *pat, size_t patlen, const char *origin, int no, enum grep_pat_token t);
    + 	p->word_regexp = opt->word_regexp;
    + 	p->ignore_case = opt->ignore_case;
     
    - ## revision.c ##
    -@@ revision.c: void repo_init_revisions(struct repository *r,
    - 	revs->commit_format = CMIT_FMT_DEFAULT;
    - 	revs->expand_tabs_in_log_default = 8;
    + ## t/t4013-diff-various.sh ##
    +@@ t/t4013-diff-various.sh: log -SF master --max-count=1
    + log -SF master --max-count=2
    + log -GF master
    + log -GF -p master
    +-log -GF -p --pickaxe-all master
    ++log -GD -U1 -s --pickaxe-patch --pretty=oneline master
    ++log -GD -U0 -s --pickaxe-patch --pretty=oneline master
    + log -IA -IB -I1 -I2 -p master
    + log --decorate --all
    + log --decorate=full --all
    +
    + ## t/t4013/diff.log_-GD_-U0_-s_--pickaxe-patch_--pretty=oneline_master (new) ##
    +@@
    ++$ git log -GD -U0 -s --pickaxe-patch --pretty=oneline master
    ++1bde4ae5f36c8d9abe3a0fce0c6aab3c4a12fe44 Second
    ++$
    +
    + ## t/t4013/diff.log_-GD_-U1_-s_--pickaxe-patch_--pretty=oneline_master (new) ##
    +@@
    ++$ git log -GD -U1 -s --pickaxe-patch --pretty=oneline master
    ++9a6d4949b6b76956d9d5e26f2791ec2ceff5fdc0 Third
    ++1bde4ae5f36c8d9abe3a0fce0c6aab3c4a12fe44 Second
    ++$
    +
    + ## t/t4209-log-pickaxe.sh ##
    +@@ t/t4209-log-pickaxe.sh: test_expect_success 'usage' '
    + 	test_expect_code 128 git log -Gregex -Sstring 2>err &&
    + 	grep "cannot be used together" err &&
    + 
    ++	test_expect_code 128 git log -Sstring --pickaxe-patch 2>err &&
    ++	test_i18ngrep "mutually exclusive" err &&
    ++
    + 	test_expect_code 128 git log -Gregex --find-object=HEAD 2>err &&
    + 	grep "cannot be used together" err &&
      
    --	grep_init(&revs->grep_filter, revs->repo, prefix);
    -+	grep_init(&revs->grep_filter, revs->repo);
    - 	revs->grep_filter.status_only = 1;
    +@@ t/t4209-log-pickaxe.sh: test_expect_success 'log -S --pickaxe-regex looks into binary files' '
    + 	test_cmp log full-log
    + '
      
    - 	repo_diff_setup(revs->repo, &revs->diffopt);
    ++test_expect_success 'setup log -G --pickaxe-patch' '
    ++	git checkout --orphan G-patch &&
    ++	test_write_lines A B C D E F G >file &&
    ++	git add file &&
    ++	git commit --allow-empty-message file &&
    ++	sed "s/B/2/" <file >tmp &&
    ++	mv tmp file &&
    ++	git add file &&
    ++	git commit --allow-empty-message file &&
    ++	sed -e "s/D/4/" <file >tmp &&
    ++	mv tmp file &&
    ++	git add file &&
    ++	git commit --allow-empty-message file &&
    ++	git rm file &&
    ++	git commit --allow-empty-message &&
    ++	git log --oneline -1 HEAD~0 >file.fourth &&
    ++	git log --oneline -1 HEAD~1 >file.third &&
    ++	git log --oneline -1 HEAD~2 >file.second &&
    ++	git log --oneline -1 HEAD~3 >file.first
    ++'
    ++
    ++test_expect_success 'log -G --pickaxe-patch skips header and range information' '
    ++	git log --pickaxe-patch -p -G"(@@|file)" >log &&
    ++	test_must_be_empty log
    ++'
    ++
    ++test_expect_success 'log -G --pickaxe-patch searching in context' '
    ++	git log --oneline --pickaxe-patch -G"^ F" -U2 -s >log &&
    ++	test_cmp file.third log &&
    ++	git log --oneline --pickaxe-patch -G"^ F" -U1 -s >log &&
    ++	test_must_be_empty log
    ++'
    ++
    ++test_expect_success 'log -G --pickaxe-patch searching added / removed lines (skip create/delete)' '
    ++	git log --oneline --pickaxe-patch -G"^-[D2]" -s HEAD~1 >log &&
    ++	test_cmp file.third log &&
    ++	git log --oneline --pickaxe-patch -G"^\+[D2]" -s -1 >log &&
    ++	test_cmp file.second log
    ++'
    ++
    ++test_expect_success 'log -G --pickaxe-patch searching created / deleted files' '
    ++	git log --oneline --pickaxe-patch -G"^\+A" -s >log &&
    ++	test_cmp file.first log &&
    ++	git log --oneline --pickaxe-patch -G"^\-A" -s >log &&
    ++	test_cmp file.fourth log
    ++'
    ++
    + test_done
 2:  0edcdb50afd !  5:  2ff4562d536 log tests: check if grep_config() is called by "log"-like cmds
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    log tests: check if grep_config() is called by "log"-like cmds
    +    wip reg_newline etc. test
     
    -    Extend the tests added in my 9df46763ef1 (log: add exhaustive tests
    -    for pattern style options & config, 2017-05-20) to check not only
    -    whether "git log" handles "grep.patternType", but also "git show"
    -    etc.
    -
    -    It's sufficient to check whether we match a "fixed" or a "basic" regex
    -    here to see if these codepaths correctly invoked grep_config(). We
    -    don't need to check the details of their regular expression matching
    -    as the "log" test does.
    -
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    + ## grep.c ##
    +@@ grep.c: static void compile_fixed_regexp(struct grep_pat *p, struct grep_opt *opt)
    + static void compile_regexp(struct grep_pat *p, struct grep_opt *opt)
    + {
    + 	int err;
    +-	int regflags = 0; //REG_NEWLINE;
    ++	int regflags = 0;
    + 
    + 	p->word_regexp = opt->word_regexp;
    + 	p->ignore_case = opt->ignore_case;
     
    - ## t/t4202-log.sh ##
    -@@ t/t4202-log.sh: test_expect_success !FAIL_PREREQS 'log with various grep.patternType configurati
    - 	)
    + ## t/t4209-log-pickaxe.sh ##
    +@@ t/t4209-log-pickaxe.sh: test_expect_success 'log -S --no-textconv (missing textconv tool)' '
    + test_expect_success 'setup log -[GS] plain & regex' '
    + 	test_create_repo GS-plain &&
    + 	test_commit -C GS-plain --append A data.txt "a" &&
    +-	test_commit -C GS-plain --append B data.txt "a a" &&
    ++	test_commit -C GS-plain --append B data.txt "aa" &&
    + 	test_commit -C GS-plain --append C data.txt "b" &&
    + 	test_commit -C GS-plain --append D data.txt "[b]" &&
    + 	test_commit -C GS-plain E data.txt "" &&
    +@@ t/t4209-log-pickaxe.sh: test_expect_success 'setup log -[GS] plain & regex' '
    + 	git -C GS-plain log --grep="[ABE]" >A-to-B-then-E-log &&
    + 	git -C GS-plain log --grep="[CDE]" >C-to-D-then-E-log &&
    + 	git -C GS-plain log --grep="[DE]" >D-then-E-log &&
    ++	git -C GS-plain log --grep="[AE]" >A-then-E-log &&
    + 	git -C GS-plain log >full-log
      '
      
    -+for cmd in show whatchanged reflog format-patch
    -+do
    -+	case "$cmd" in
    -+	format-patch) myarg="HEAD~.." ;;
    -+	*) myarg= ;;
    -+	esac
    -+
    -+	test_expect_success "$cmd: understands grep.patternType, like 'log'" '
    -+		git init "pattern-type-$cmd" &&
    -+		(
    -+			cd "pattern-type-$cmd" &&
    -+			test_commit 1 file A &&
    -+			test_commit "(1|2)" file B 2 &&
    +@@ t/t4209-log-pickaxe.sh: test_expect_success 'log -G trims diff new/old [-+]' '
    + 	git -C GS-plain log -G"[+-]a" >log &&
    + 	test_must_be_empty log &&
    + 	git -C GS-plain log -G"^a" >log &&
    +-	test_cmp log A-to-B-then-E-log
    ++	test_cmp A-to-B-then-E-log log
    ++'
     +
    -+			git -c grep.patternType=fixed $cmd --grep="..." $myarg >actual &&
    -+			test_must_be_empty actual &&
    -+
    -+			git -c grep.patternType=basic $cmd --grep="..." $myarg >actual &&
    -+			test_file_not_empty actual
    -+		)
    -+	'
    -+done
    -+test_done
    -+
    - test_expect_success 'log --author' '
    - 	cat >expect <<-\EOF &&
    - 	Author: <BOLD;RED>A U<RESET> Thor <author@example.com>
    ++test_expect_success 'log -S --pickaxe-regex uses REG_NOTBOL for subsequent matches' '
    ++	git -C GS-plain log -S"^a" --pickaxe-regex >log &&
    ++	test_cmp A-then-E-log log
    + '
    + 
    + test_expect_success 'log -S<pat> is not a regex, but -S<pat> --pickaxe-regex is' '
 6:  d9cf9bf5e37 !  6:  2b1bcafb143 grep API: call grep_config() after grep_init()
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    grep API: call grep_config() after grep_init()
    +    only compile pattern once: TODO, free it
     
    -    The grep_init() function used the odd pattern of initializing the
    -    passed-in "struct grep_opt" with a statically defined "grep_defaults"
    -    struct, which would be modified in-place when we invoked
    -    grep_config().
    +    That's more like it:
     
    -    So we effectively (b) initialized config, (a) then defaults, (c)
    -    followed by user options. Usually those are ordered as "a", "b" and
    -    "c" instead.
    +    GIT_TEST_LONG= GIT_PERF_REPEAT_COUNT=10 GIT_PERF_MAKE_OPTS='-j8 USE_LIBPCRE=1 CFLAGS=-O3 LIBPCREDIR=/home/avar/g/pcre2/inst' ./run origin/next HEAD -- p4209-pickaxe.sh
    +    Test                                                                      origin/next       HEAD
    +    ------------------------------------------------------------------------------------------------------------------
    +    4209.1: git log -S'int main' <limit-rev>..                                0.38(0.36+0.01)   0.37(0.33+0.04) -2.6%
    +    4209.2: git log -S'æ' <limit-rev>..                                       0.51(0.47+0.04)   0.32(0.27+0.05) -37.3%
    +    4209.3: git log --pickaxe-regex -S'(int|void|null)' <limit-rev>..         0.72(0.68+0.03)   0.57(0.54+0.03) -20.8%
    +    4209.4: git log --pickaxe-regex -S'if *\([^ ]+ & ' <limit-rev>..          0.60(0.55+0.02)   0.39(0.34+0.05) -35.0%
    +    4209.5: git log --pickaxe-regex -S'[àáâãäåæñøùúûüýþ]' <limit-rev>..       0.43(0.40+0.03)   0.50(0.44+0.06) +16.3%
    +    4209.6: git log -G'(int|void|null)' <limit-rev>..                         0.64(0.55+0.09)   0.63(0.56+0.05) -1.6%
    +    4209.7: git log -G'if *\([^ ]+ & ' <limit-rev>..                          0.64(0.59+0.05)   0.63(0.56+0.06) -1.6%
    +    4209.8: git log -G'[àáâãäåæñøùúûüýþ]' <limit-rev>..                       0.63(0.54+0.08)   0.62(0.55+0.06) -1.6%
    +    4209.9: git log -i -S'int main' <limit-rev>..                             0.39(0.35+0.03)   0.38(0.35+0.02) -2.6%
    +    4209.10: git log -i -S'æ' <limit-rev>..                                   0.39(0.33+0.06)   0.32(0.28+0.04) -17.9%
    +    4209.11: git log -i --pickaxe-regex -S'(int|void|null)' <limit-rev>..     0.90(0.84+0.05)   0.58(0.53+0.04) -35.6%
    +    4209.12: git log -i --pickaxe-regex -S'if *\([^ ]+ & ' <limit-rev>..      0.71(0.64+0.06)   0.40(0.37+0.03) -43.7%
    +    4209.13: git log -i --pickaxe-regex -S'[àáâãäåæñøùúûüýþ]' <limit-rev>..   0.43(0.40+0.03)   0.50(0.46+0.04) +16.3%
    +    4209.14: git log -i -G'(int|void|null)' <limit-rev>..                     0.64(0.57+0.06)   0.62(0.56+0.05) -3.1%
    +    4209.15: git log -i -G'if *\([^ ]+ & ' <limit-rev>..                      0.65(0.59+0.06)   0.63(0.54+0.08) -3.1%
    +    4209.16: git log -i -G'[àáâãäåæñøùúûüýþ]' <limit-rev>..                   0.63(0.55+0.08)   0.62(0.56+0.05) -1.6%
     
    -    As the comments being removed here show the previous behavior needed
    -    to be carefully explained as we'd potentially share the populated
    -    configuration among different instances of grep_init(). In practice we
    -    didn't do that, but now that it can't be a concern anymore let's
    -    remove those comments.
    -
    -    This does not change the behavior of any of the configuration
    -    variables or options. That would have been the case if we didn't move
    -    around the grep_config() call in "builtin/log.c". But now that we call
    -    "grep_config" after "git_log_config" and "git_format_config" we'll
    -    need to pass in the already initialized "struct grep_opt *".
    -
    -    See 6ba9bb76e02 (grep: copy struct in one fell swoop, 2020-11-29) and
    -    7687a0541e0 (grep: move the configuration parsing logic to grep.[ch],
    -    2012-10-09) for the commits that added the comments.
    -
    -    The memcpy() pattern here will be optimized away and follows the
    -    convention of other *_init() functions. See 5726a6b4012 (*.c *_init():
    -    define in terms of corresponding *_INIT macro, 2021-07-01).
    -
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    -
    - ## builtin/grep.c ##
    -@@ builtin/grep.c: static int wait_all(void)
    + ## diff.h ##
    +@@
    + #include "pathspec.h"
    + #include "object.h"
    + #include "oidset.h"
    ++#include "xdiff-interface.h"
    ++#include "grep.h"
      
    - static int grep_cmd_config(const char *var, const char *value, void *cb)
    - {
    --	int st = grep_config(var, value, NULL);
    -+	int st = grep_config(var, value, cb);
    - 	if (git_color_default_config(var, value, NULL) < 0)
    - 		st = -1;
    - 
    -@@ builtin/grep.c: int cmd_grep(int argc, const char **argv, const char *prefix)
    - 	};
    - 	grep_prefix = prefix;
    + /**
    +  * The diff API is for programs that compare two sets of files (e.g. two trees,
    +@@ diff.h: enum diff_submodule_format {
    + 	DIFF_SUBMODULE_INLINE_DIFF
    + };
      
    --	git_config(grep_cmd_config, NULL);
    - 	grep_init(&opt, the_repository);
    -+	git_config(grep_cmd_config, &opt);
    ++typedef int (*pickaxe_fn)(mmfile_t *one, mmfile_t *two,
    ++			  struct diff_options *o,
    ++			  struct grep_opt *grep_filter);
    ++
    + /**
    +  * the set of options the calling program wants to affect the operation of
    +  * diffcore library with.
    +@@ diff.h: struct diff_options {
    + 	 */
    + 	const char *pickaxe;
    + 	unsigned pickaxe_opts;
    ++	int pickaxed_compiled;
    ++	pickaxe_fn pickaxe_fn;
    ++	struct grep_opt pickaxe_grep_opt;
      
    - 	/*
    - 	 * If there is no -- then the paths must exist in the working
    + 	/* -I<regex> */
    + 	regex_t **ignore_regex;
     
    - ## builtin/log.c ##
    -@@ builtin/log.c: static int git_log_config(const char *var, const char *value, void *cb)
    - 		return 0;
    - 	}
    + ## diffcore-pickaxe.c ##
    +@@
    + #include "xdiff-interface.h"
    + #include "grep.h"
      
    --	if (grep_config(var, value, cb) < 0)
    --		return -1;
    - 	if (git_gpg_config(var, value, cb) < 0)
    - 		return -1;
    - 	return git_diff_ui_config(var, value, cb);
    -@@ builtin/log.c: int cmd_whatchanged(int argc, const char **argv, const char *prefix)
    - 	git_config(git_log_config, NULL);
    +-typedef int (*pickaxe_fn)(mmfile_t *one, mmfile_t *two,
    +-			  struct diff_options *o,
    +-			  struct grep_opt *grep_filter);
    +-
    + struct diffgrep_cb {
    + 	struct grep_opt	*grep_filter;
    + 	int hit;
    +@@ diffcore-pickaxe.c: static void pickaxe(struct diff_queue_struct *q, struct diff_options *o,
    + 	*q = outq;
    + }
      
    - 	repo_init_revisions(the_repository, &rev, prefix);
    -+	git_config(grep_config, &rev.grep_filter);
    -+
    - 	rev.diff = 1;
    - 	rev.simplify_history = 0;
    - 	memset(&opt, 0, sizeof(opt));
    -@@ builtin/log.c: int cmd_show(int argc, const char **argv, const char *prefix)
    +-void diffcore_pickaxe(struct diff_options *o)
    ++static void compile_pickaxe(struct diff_options *o)
    + {
    + 	const char *needle = o->pickaxe;
    + 	int opts = o->pickaxe_opts;
    +-	struct grep_opt opt;
    + 	pickaxe_fn fn;
      
    - 	memset(&match_all, 0, sizeof(match_all));
    - 	repo_init_revisions(the_repository, &rev, prefix);
    -+	git_config(grep_config, &rev.grep_filter);
    ++	assert(!o->pickaxed_compiled);
    ++	o->pickaxed_compiled = 1;
     +
    - 	rev.diff = 1;
    - 	rev.always_show_header = 1;
    - 	rev.no_walk = 1;
    -@@ builtin/log.c: int cmd_log_reflog(int argc, const char **argv, const char *prefix)
    + 	if (opts & ~DIFF_PICKAXE_KIND_OBJFIND &&
    + 	    (!needle || !*needle))
    + 		BUG("should have needle under -G or -S");
    + 	if (opts & (DIFF_PICKAXE_REGEX | DIFF_PICKAXE_KIND_GS_MASK)) {
    +-		grep_init(&opt, the_repository, NULL);
    ++		grep_init(&o->pickaxe_grep_opt, the_repository, NULL);
    + #ifdef USE_LIBPCRE2
    +-		grep_commit_pattern_type(GREP_PATTERN_TYPE_PCRE, &opt);
    ++		grep_commit_pattern_type(GREP_PATTERN_TYPE_PCRE, &o->pickaxe_grep_opt);
    + #else
    +-		grep_commit_pattern_type(GREP_PATTERN_TYPE_ERE, &opt);
    ++		grep_commit_pattern_type(GREP_PATTERN_TYPE_ERE, &o->pickaxe_grep_opt);
    + #endif
      
    - 	repo_init_revisions(the_repository, &rev, prefix);
    - 	init_reflog_walk(&rev.reflog_info);
    -+	git_config(grep_config, &rev.grep_filter);
    -+
    - 	rev.verbose_header = 1;
    - 	memset(&opt, 0, sizeof(opt));
    - 	opt.def = "HEAD";
    -@@ builtin/log.c: int cmd_log(int argc, const char **argv, const char *prefix)
    - 	git_config(git_log_config, NULL);
    + 		if (o->pickaxe_opts & DIFF_PICKAXE_IGNORE_CASE)
    +-			opt.ignore_case = 1;
    ++			o->pickaxe_grep_opt.ignore_case = 1;
    + 		if (opts & DIFF_PICKAXE_KIND_S &&
    + 		    !(opts & DIFF_PICKAXE_REGEX))
    +-			opt.fixed = 1;
    ++			o->pickaxe_grep_opt.fixed = 1;
      
    - 	repo_init_revisions(the_repository, &rev, prefix);
    -+	git_config(grep_config, &rev.grep_filter);
    -+
    - 	rev.always_show_header = 1;
    - 	memset(&opt, 0, sizeof(opt));
    - 	opt.def = "HEAD";
    -@@ builtin/log.c: int cmd_format_patch(int argc, const char **argv, const char *prefix)
    - 	extra_hdr.strdup_strings = 1;
    - 	extra_to.strdup_strings = 1;
    - 	extra_cc.strdup_strings = 1;
    -+
    - 	init_log_defaults();
    - 	init_display_notes(&notes_opt);
    - 	git_config(git_format_config, NULL);
    - 	repo_init_revisions(the_repository, &rev, prefix);
    -+	git_config(grep_config, &rev.grep_filter);
    +-		append_grep_pattern(&opt, needle, "diffcore-pickaxe", 0, GREP_PATTERN);
    +-		compile_grep_patterns(&opt);
    ++		append_grep_pattern(&o->pickaxe_grep_opt, needle, "diffcore-pickaxe", 0, GREP_PATTERN);
    ++		fprintf(stderr, "compiling for %s\n", needle);
    ++		compile_grep_patterns(&o->pickaxe_grep_opt);
    + 
    + 		if (opts & DIFF_PICKAXE_KIND_G)
    + 			fn = diff_grep;
    +@@ diffcore-pickaxe.c: void diffcore_pickaxe(struct diff_options *o)
    + 			 * t4209-log-pickaxe.sh.
    + 			 */
    + 			BUG("unreachable");
     +
    - 	rev.show_notes = show_notes;
    - 	memcpy(&rev.notes_opt, &notes_opt, sizeof(notes_opt));
    - 	rev.commit_format = CMIT_FMT_EMAIL;
    -
    - ## grep.c ##
    -@@ grep.c: static void std_output(struct grep_opt *opt, const void *buf, size_t size)
    - 	fwrite(buf, size, 1, stdout);
    - }
    ++		o->pickaxe_fn = fn;
    + 	} else if (opts & DIFF_PICKAXE_KIND_OBJFIND) {
    + 		fn = NULL;
    + 	} else {
    + 		BUG("unknown pickaxe_opts flag");
    + 	}
    ++}
      
    --static struct grep_opt grep_defaults = {
    --	.relative = 1,
    --	.pathname = 1,
    --	.max_depth = -1,
    --	.pattern_type_option = GREP_PATTERN_TYPE_UNSPECIFIED,
    --	.colors = {
    --		[GREP_COLOR_CONTEXT] = "",
    --		[GREP_COLOR_FILENAME] = "",
    --		[GREP_COLOR_FUNCTION] = "",
    --		[GREP_COLOR_LINENO] = "",
    --		[GREP_COLOR_COLUMNNO] = "",
    --		[GREP_COLOR_MATCH_CONTEXT] = GIT_COLOR_BOLD_RED,
    --		[GREP_COLOR_MATCH_SELECTED] = GIT_COLOR_BOLD_RED,
    --		[GREP_COLOR_SELECTED] = "",
    --		[GREP_COLOR_SEP] = GIT_COLOR_CYAN,
    --	},
    --	.only_matching = 0,
    --	.color = -1,
    --	.output = std_output,
    --};
    --
    - static const char *color_grep_slots[] = {
    - 	[GREP_COLOR_CONTEXT]	    = "context",
    - 	[GREP_COLOR_FILENAME]	    = "filename",
    -@@ grep.c: define_list_config_array_extra(color_grep_slots, {"match"});
    -  */
    - int grep_config(const char *var, const char *value, void *cb)
    - {
    --	struct grep_opt *opt = &grep_defaults;
    -+	struct grep_opt *opt = cb;
    - 	const char *slot;
    +-	pickaxe(&diff_queued_diff, o, &opt, fn);
    ++void diffcore_pickaxe(struct diff_options *o)
    ++{
    ++	if (!o->pickaxed_compiled)
    ++		compile_pickaxe(o);
    ++	pickaxe(&diff_queued_diff, o, &o->pickaxe_grep_opt, o->pickaxe_fn);
      
    - 	if (userdiff_config(var, value) < 0)
    - 		return -1;
    +-	if (opts & ~DIFF_PICKAXE_KIND_OBJFIND)
    +-		free_grep_patterns(&opt);
    ++	/*if (opts & ~DIFF_PICKAXE_KIND_OBJFIND)
    ++		free_grep_patterns(&o->pickaxe_grep_opt);*/
      
    --	/*
    --	 * The instance of grep_opt that we set up here is copied by
    --	 * grep_init() to be used by each individual invocation.
    --	 * When populating a new field of this structure here, be
    --	 * sure to think about ownership -- e.g., you might need to
    --	 * override the shallow copy in grep_init() with a deep copy.
    --	 */
    --
    - 	if (!strcmp(var, "grep.extendedregexp")) {
    - 		opt->extended_regexp_option = git_config_bool(var, value);
    - 		return 0;
    -@@ grep.c: int grep_config(const char *var, const char *value, void *cb)
    - 	return 0;
    + 	return;
      }
    - 
    --/*
    -- * Initialize one instance of grep_opt and copy the
    -- * default values from the template we read the configuration
    -- * information in an earlier call to git_config(grep_config).
    -- */
    - void grep_init(struct grep_opt *opt, struct repository *repo)
    - {
    --	*opt = grep_defaults;
    -+	struct grep_opt blank = GREP_OPT_INIT;
    -+	memcpy(opt, &blank, sizeof(*opt));
    - 
    - 	opt->repo = repo;
    - 	opt->pattern_tail = &opt->pattern_list;
    -
    - ## grep.h ##
    -@@ grep.h: struct grep_opt {
    - 	void *output_priv;
    - };
    - 
    -+#define GREP_OPT_INIT { \
    -+	.relative = 1, \
    -+	.pathname = 1, \
    -+	.max_depth = -1, \
    -+	.pattern_type_option = GREP_PATTERN_TYPE_UNSPECIFIED, \
    -+	.colors = { \
    -+		[GREP_COLOR_CONTEXT] = "", \
    -+		[GREP_COLOR_FILENAME] = "", \
    -+		[GREP_COLOR_FUNCTION] = "", \
    -+		[GREP_COLOR_LINENO] = "", \
    -+		[GREP_COLOR_COLUMNNO] = "", \
    -+		[GREP_COLOR_MATCH_CONTEXT] = GIT_COLOR_BOLD_RED, \
    -+		[GREP_COLOR_MATCH_SELECTED] = GIT_COLOR_BOLD_RED, \
    -+		[GREP_COLOR_SELECTED] = "", \
    -+		[GREP_COLOR_SEP] = GIT_COLOR_CYAN, \
    -+	}, \
    -+	.only_matching = 0, \
    -+	.color = -1, \
    -+	.output = std_output, \
    -+}
    -+
    - int grep_config(const char *var, const char *value, void *);
    - void grep_init(struct grep_opt *, struct repository *repo);
    - void grep_commit_pattern_type(enum grep_pattern_type, struct grep_opt *opt);
 8:  7dbeafde26b !  7:  7db49ee116e grep.c: do "if (bool && memchr())" not "if (memchr() && bool)"
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    grep.c: do "if (bool && memchr())" not "if (memchr() && bool)"
    +    Revert "wip reg_newline etc. test"
     
    -    Change code in compile_regexp() to check the cheaper boolean
    -    "!opt->pcre2" condition before the "memchr()" search.
    -
    -    This doesn't noticeably optimize anything, but makes the code more
    -    obvious and conventional. The line wrapping being added here also
    -    makes a subsequent commit smaller.
    -
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    +    This reverts commit 3d49287f57d1c02241b52a41c0e9b143cabb590e.
     
      ## grep.c ##
    -@@ grep.c: static void compile_regexp(struct grep_pat *p, struct grep_opt *opt)
    +@@ grep.c: static void compile_fixed_regexp(struct grep_pat *p, struct grep_opt *opt)
    + static void compile_regexp(struct grep_pat *p, struct grep_opt *opt)
    + {
    + 	int err;
    +-	int regflags = 0;
    ++	int regflags = 0;//REG_NEWLINE
    + 
    + 	p->word_regexp = opt->word_regexp;
      	p->ignore_case = opt->ignore_case;
    - 	p->fixed = opt->fixed;
    +
    + ## t/t4209-log-pickaxe.sh ##
    +@@ t/t4209-log-pickaxe.sh: test_expect_success 'log -S --no-textconv (missing textconv tool)' '
    + test_expect_success 'setup log -[GS] plain & regex' '
    + 	test_create_repo GS-plain &&
    + 	test_commit -C GS-plain --append A data.txt "a" &&
    +-	test_commit -C GS-plain --append B data.txt "aa" &&
    ++	test_commit -C GS-plain --append B data.txt "a a" &&
    + 	test_commit -C GS-plain --append C data.txt "b" &&
    + 	test_commit -C GS-plain --append D data.txt "[b]" &&
    + 	test_commit -C GS-plain E data.txt "" &&
    +@@ t/t4209-log-pickaxe.sh: test_expect_success 'setup log -[GS] plain & regex' '
    + 	git -C GS-plain log --grep="[ABE]" >A-to-B-then-E-log &&
    + 	git -C GS-plain log --grep="[CDE]" >C-to-D-then-E-log &&
    + 	git -C GS-plain log --grep="[DE]" >D-then-E-log &&
    +-	git -C GS-plain log --grep="[AE]" >A-then-E-log &&
    + 	git -C GS-plain log >full-log
    + '
      
    --	if (memchr(p->pattern, 0, p->patternlen) && !opt->pcre2)
    -+	if (!opt->pcre2 &&
    -+	    memchr(p->pattern, 0, p->patternlen))
    - 		die(_("given pattern contains NULL byte (via -f <file>). This is only supported with -P under PCRE v2"));
    +@@ t/t4209-log-pickaxe.sh: test_expect_success 'log -G trims diff new/old [-+]' '
    + 	git -C GS-plain log -G"[+-]a" >log &&
    + 	test_must_be_empty log &&
    + 	git -C GS-plain log -G"^a" >log &&
    +-	test_cmp A-to-B-then-E-log log
    +-'
    +-
    +-test_expect_success 'log -S --pickaxe-regex uses REG_NOTBOL for subsequent matches' '
    +-	git -C GS-plain log -S"^a" --pickaxe-regex >log &&
    +-	test_cmp A-then-E-log log
    ++	test_cmp log A-to-B-then-E-log
    + '
      
    - 	p->is_fixed = is_fixed(p->pattern, p->patternlen);
    + test_expect_success 'log -S<pat> is not a regex, but -S<pat> --pickaxe-regex is' '
 3:  e1b4b5b77e0 !  8:  c33b6317dc3 grep tests: add missing "grep.patternType" config tests
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    grep tests: add missing "grep.patternType" config tests
    +    free stuff, is the objfind a bug?
     
    -    Extend the grep tests to assert that setting
    -    "grep.patternType=extended" followed by "grep.patternType=default"
    -    will behave as if "--basic-regexp" was provided, and not as
    -    "--extended-regexp". In a subsequent commit we'll need to treat
    -    "grep.patternType=default" as a special-case, but let's make sure we
    -    ignore it if it's being set to "default" following an earlier
    -    non-"default" "grep.patternType" setting.
    -
    -    Let's also test what happens when we have a sequence of "extended"
    -    followed by "default" and "fixed". In that case the "fixed" should
    -    prevail, as well as tests to check that a "grep.extendedRegexp=true"
    -    followed by a "grep.extendedRegexp=false" behaves as though
    -    "grep.extendedRegexp" wasn't provided.
    -
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    -    Signed-off-by: Junio C Hamano <gitster@pobox.com>
    -
    - ## t/t7810-grep.sh ##
    -@@ t/t7810-grep.sh: do
    - 		test_cmp expected actual
    - 	'
    + ## diff.c ##
    +@@ diff.c: static void diff_free_ignore_regex(struct diff_options *options)
    + 	free(options->ignore_regex);
    + }
      
    -+	test_expect_success "grep $L with grep.extendedRegexp is last-one-wins" '
    -+		echo "${HC}ab:a+bc" >expected &&
    -+		git \
    -+			-c grep.extendedRegexp=true \
    -+			-c grep.patternType=basic \
    -+			-c grep.extendedRegexp=false \
    -+			grep "a+b*c" $H ab >actual &&
    -+		test_cmp expected actual
    -+	'
    -+
    -+	test_expect_success "grep $L with grep.extendedRegexp is last-one-wins & defers to grep.patternType" '
    -+		echo "${HC}ab:abc" >expected &&
    -+		git \
    -+			-c grep.extendedRegexp=true \
    -+			-c grep.patternType=extended \
    -+			-c grep.extendedRegexp=false \
    -+			grep "a+b*c" $H ab >actual &&
    -+		test_cmp expected actual
    -+	'
    -+
    -+	test_expect_success "grep $L with grep.extendedRegexp and grep.patternType are both last-one-wins independently (BRE)" '
    -+		echo "${HC}ab:abc" >expected &&
    -+		git \
    -+			-c grep.patternType=fixed \
    -+			-c grep.extendedRegexp=true \
    -+			-c grep.patternType=default \
    -+			grep "a+b*c" $H ab >actual &&
    -+		test_cmp expected actual
    -+	'
    -+
    -+	test_expect_success "grep $L with grep.extendedRegexp and grep.patternType are both last-one-wins independently (ERE)" '
    -+		echo "${HC}ab:a+bc" >expected &&
    -+		git \
    -+			-c grep.patternType=default \
    -+			-c grep.extendedRegexp=true \
    -+			-c grep.patternType=basic \
    -+			grep "a+b*c" $H ab >actual &&
    -+		test_cmp expected actual
    -+	'
    ++static void diff_free_pickaxe(struct diff_options *options)
    ++{
    ++	free_grep_patterns(&options->pickaxe_grep_opt);
    ++}
     +
    -+	test_expect_success "grep $L with grep.patternType=extended and grep.patternType=default" '
    -+		echo "${HC}ab:a+bc" >expected &&
    -+		git \
    -+			-c grep.patternType=extended \
    -+			-c grep.patternType=default \
    -+			grep "a+b*c" $H ab >actual &&
    -+		test_cmp expected actual
    -+	'
    -+
    -+	test_expect_success "grep $L with grep.patternType=[extended -> default -> fixed]" '
    -+		echo "${HC}ab:a+b*c" >expected &&
    -+		git \
    -+			-c grep.patternType=extended \
    -+			-c grep.patternType=default \
    -+			-c grep.patternType=fixed \
    -+			grep "a+b*c" $H ab >actual &&
    -+		test_cmp expected actual
    -+	'
    -+
    - 	test_expect_success "grep $L with grep.patternType=extended and grep.extendedRegexp=false" '
    - 		echo "${HC}ab:abc" >expected &&
    - 		git \
    -@@ t/t7810-grep.sh: do
    - 		test_cmp expected actual
    - 	'
    + void diff_free(struct diff_options *options)
    + {
    + 	if (options->no_free)
    +@@ diff.c: void diff_free(struct diff_options *options)
      
    -+	test_expect_success "grep $L with grep.extendedRegexp=false and grep.patternType=default" '
    -+		echo "${HC}ab:abc" >expected &&
    -+		git \
    -+			-c grep.extendedRegexp=false \
    -+			-c grep.patternType=extended \
    -+			grep "a+b*c" $H ab >actual &&
    -+		test_cmp expected actual
    -+	'
    -+
    - 	test_expect_success "grep $L with grep.extendedRegexp=true and grep.patternType=basic" '
    - 		echo "${HC}ab:a+bc" >expected &&
    - 		git \
    + 	diff_free_file(options);
    + 	diff_free_ignore_regex(options);
    ++	diff_free_pickaxe(options);
    + }
    + 
    + void diff_flush(struct diff_options *options)
    +
    + ## diffcore-pickaxe.c ##
    +@@ diffcore-pickaxe.c: void diffcore_pickaxe(struct diff_options *o)
    + 		compile_pickaxe(o);
    + 	pickaxe(&diff_queued_diff, o, &o->pickaxe_grep_opt, o->pickaxe_fn);
    + 
    +-	/*if (opts & ~DIFF_PICKAXE_KIND_OBJFIND)
    +-		free_grep_patterns(&o->pickaxe_grep_opt);*/
    +-
    + 	return;
    + }
 5:  844b4727ca3 !  9:  6e035e891cd grep.c: don't pass along NULL callback value
    @@ Metadata
     Author: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
     
      ## Commit message ##
    -    grep.c: don't pass along NULL callback value
    +    better?
     
    -    Change grep_cmd_config() to stop passing around the always-NULL "cb"
    -    value. When this code was added in 7e8f59d577e (grep: color patterns
    -    in output, 2009-03-07) it was non-NULL, but when that changed in
    -    15fabd1bbd4 (builtin/grep.c: make configuration callback more
    -    reusable, 2012-10-09) this code was left behind.
    -
    -    In a subsequent change I'll start using the "cb" value, this will make
    -    it clear which functions we call need it, and which don't.
    -
    -    Signed-off-by: Ævar Arnfjörð Bjarmason <avarab@gmail.com>
    -
    - ## builtin/grep.c ##
    -@@ builtin/grep.c: static int wait_all(void)
    + ## diff.c ##
    +@@ diff.c: static void diff_free_ignore_regex(struct diff_options *options)
      
    - static int grep_cmd_config(const char *var, const char *value, void *cb)
    + static void diff_free_pickaxe(struct diff_options *options)
      {
    --	int st = grep_config(var, value, cb);
    --	if (git_color_default_config(var, value, cb) < 0)
    -+	int st = grep_config(var, value, NULL);
    -+	if (git_color_default_config(var, value, NULL) < 0)
    - 		st = -1;
    +-	free_grep_patterns(&options->pickaxe_grep_opt);
    ++	if (options->pickaxe_opts & DIFF_PICKAXE_KINDS_MASK)
    ++		free_grep_patterns(&options->pickaxe_grep_opt);
    + }
      
    - 	if (!strcmp(var, "grep.threads")) {
    + void diff_free(struct diff_options *options)
 7:  57ecc5c0d65 <  -:  ----------- grep.h: make "grep_opt.pattern_type_option" use its enum
 -:  ----------- > 10:  cbbd47bc5b7 fixup earlier, ./t7810-grep.sh (and maybe ./t4014-format-patch.sh?) fails without this
 -:  ----------- > 11:  b4c0140812d remove ad-hoc debug
 -:  ----------- > 12:  f718ac37e7b fixup for being on top of avar/drop-grep-prefix-length now
-- 
2.35.0.rc1.864.g57621b115b6

